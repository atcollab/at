
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>at.physics package &#8212; pyAT 0.2 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=62ba249389abaaa9ffc34bf36a076bdc1d65ee18" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/custom_at.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=f31d14ad54b65d19161ba51d4ffff3a77ae00456"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="at.plot package" href="at.plot.html" />
    <link rel="prev" title="at.matching package" href="at.matching.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/company_logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">pyAT 0.2 documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting started:
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="getting_started.html">
   pyAT
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  How to:
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="howto/Installation.html">
   Installation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="howto/Primer.html">
   PyAT Primer
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="howto/CavityControl.html">
   Cavity Control
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="howto/Collective.html">
   Collective
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Modules:
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="at.acceptance.html">
   at.acceptance package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="at.collective.html">
   at.collective package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="at.lattice.html">
   at.lattice package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="at.load.html">
   at.load package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="at.matching.html">
   at.matching package
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   at.physics package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="at.plot.html">
   at.plot package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="at.tracking.html">
   at.tracking package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="at.constants.html">
   at.constants module
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/atcollab/at"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#submodules">
   Submodules
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.amat">
   at.physics.amat module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.diffmatrix">
   at.physics.diffmatrix module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.energy_loss">
   at.physics.energy_loss module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.fastring">
   at.physics.fastring module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.harmonic_analysis">
   at.physics.harmonic_analysis module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.linear">
   at.physics.linear module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.matrix">
   at.physics.matrix module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.nonlinear">
   at.physics.nonlinear module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.orbit">
   at.physics.orbit module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.radiation">
   at.physics.radiation module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.revolution">
   at.physics.revolution module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.ring_parameters">
   at.physics.ring_parameters module
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>at.physics package</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#submodules">
   Submodules
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.amat">
   at.physics.amat module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.diffmatrix">
   at.physics.diffmatrix module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.energy_loss">
   at.physics.energy_loss module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.fastring">
   at.physics.fastring module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.harmonic_analysis">
   at.physics.harmonic_analysis module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.linear">
   at.physics.linear module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.matrix">
   at.physics.matrix module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.nonlinear">
   at.physics.nonlinear module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.orbit">
   at.physics.orbit module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.radiation">
   at.physics.radiation module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.revolution">
   at.physics.revolution module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-at.physics.ring_parameters">
   at.physics.ring_parameters module
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section id="module-at.physics">
<span id="at-physics-package"></span><h1>at.physics package<a class="headerlink" href="#module-at.physics" title="Permalink to this headline">#</a></h1>
<p>Accelerator physics functions</p>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">#</a></h2>
</section>
<section id="module-at.physics.amat">
<span id="at-physics-amat-module"></span><h2>at.physics.amat module<a class="headerlink" href="#module-at.physics.amat" title="Permalink to this headline">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="at.physics.amat.a_matrix">
<span class="sig-name descname"><span class="pre">a_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.amat.a_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>A, eigval = a_matrix(T)
Find the A matrix from one turn map matrix T such that:</p>
<blockquote>
<div><p>[Rotx  0    0  ]</p>
</div></blockquote>
<dl class="simple">
<dt>inv(A)*T*A=[ 0   Rotz  0  ]</dt><dd><p>[ 0    0   Rots]</p>
</dd>
</dl>
<p>Order it so that it is close to the order of x,y,z
also ensure that positive modes are before negative so that
one has proper symplecticity
B. Nash July 18, 2013</p>
<p>INPUT
T       (m, m)  transfer matrix for 1 turn</p>
<p>OUTPUT
A       (m, m)  A-matrix
eigval  (m,)    vector of Eigen values of T</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.amat.amat">
<span class="sig-name descname"><span class="pre">amat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.amat.amat" title="Permalink to this definition">#</a></dt>
<dd><p>A = amat(T)
Find the A matrix from one turn map matrix T
Provided for backward compatibility, see ” A, eigval = a_matrix(T)”</p>
<p>INPUT
T       (m, m)  transfer matrix for 1 turn</p>
<p>OUTPUT
A       (m, m)  A-matrix</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.amat.get_mode_matrices">
<span class="sig-name descname"><span class="pre">get_mode_matrices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.amat.get_mode_matrices" title="Permalink to this definition">#</a></dt>
<dd><p>Given a (m, m) A matrix , find the R-matrices of the m/2 normal modes</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.amat.get_tunes_damp">
<span class="sig-name descname"><span class="pre">get_tunes_damp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.amat.get_tunes_damp" title="Permalink to this definition">#</a></dt>
<dd><p>mode_emit, damping_rates, tunes = get_tunes_damp(T, R)</p>
<dl>
<dt>INPUT</dt><dd><p>T                   (m, m) transfer matrix for 1 turn
R                   (m, m) beam matrix (optional)</p>
<p>m can be 2 (single plane), 4 (betatron motion) or 6 (full motion)</p>
</dd>
<dt>OUTPUT</dt><dd><p>record array with the following fields:
tunes               (m/2,) tunes of the m/2 normal modes
damping_rates       (m/2,) damping rates of the m/2 normal modes
mode_matrices       (m/2, m, m) the R-matrices of the m/2 normal modes
mode_emittances     Only if R is specified: (m/2,) emittance of each</p>
<blockquote>
<div><p>of the m/2 normal modes</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.amat.jmat">
<span class="sig-name descname"><span class="pre">jmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.amat.jmat" title="Permalink to this definition">#</a></dt>
<dd><p>Return the antisymetric block diagonal matrix [[0, 1][-1, 0]]</p>
<dl class="simple">
<dt>INPUT</dt><dd><p>ind     1, 2 or 3. Matrix dimension</p>
</dd>
<dt>OUTPUT</dt><dd><p>jm      block diagonal matrix, (2, 2) or (4, 4) or (6, 6)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.amat.jmatswap">
<span class="sig-name descname"><span class="pre">jmatswap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.amat.jmatswap" title="Permalink to this definition">#</a></dt>
<dd><p>Modified version of jmat to deal with the swap of the
longitudinal coordinates</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.amat.symplectify">
<span class="sig-name descname"><span class="pre">symplectify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.amat.symplectify" title="Permalink to this definition">#</a></dt>
<dd><p>symplectify makes a matrix more symplectic
follow Healy algorithm as described by McKay
BNL-75461-2006-CP</p>
</dd></dl>

</section>
<section id="module-at.physics.diffmatrix">
<span id="at-physics-diffmatrix-module"></span><h2>at.physics.diffmatrix module<a class="headerlink" href="#module-at.physics.diffmatrix" title="Permalink to this headline">#</a></h2>
<p>Computation of the radiation diffusion matrix</p>
<dl class="py function">
<dt class="sig sig-object py" id="at.physics.diffmatrix.find_mpole_raddiff_matrix">
<span class="sig-name descname"><span class="pre">find_mpole_raddiff_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.diffmatrix.find_mpole_raddiff_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>diffmatrix=find_mpole_raddiff_matrix(element, orbit, energy)</p>
<dl class="simple">
<dt>element:   element structure with field names consistent with</dt><dd><p>a multipole transverse field model.</p>
</dd>
</dl>
<p>orbit:     (6,) vector of the closed orbit at the entrance
energy:    ring energy</p>
<p>calculate radiation diffusion matrix B defined in [2]
for multipole elements in MATLAB Accelerator Toolbox
A.Terebilo 8/14/00</p>
<p>References
[1] M.Sands ‘The Physics of Electron Storage Rings
[2] Ohmi, Kirata, Oide ‘From the beam-envelope matrix to synchrotron
radiation integrals’, Phys.Rev.E  Vol.49 p.751 (1994)</p>
</dd></dl>

</section>
<section id="module-at.physics.energy_loss">
<span id="at-physics-energy-loss-module"></span><h2>at.physics.energy_loss module<a class="headerlink" href="#module-at.physics.energy_loss" title="Permalink to this headline">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="at.physics.energy_loss.ELossMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ELossMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.energy_loss.ELossMethod" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>Enum class for energy loss methods</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.physics.energy_loss.ELossMethod.INTEGRAL">
<span class="sig-name descname"><span class="pre">INTEGRAL</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#at.physics.energy_loss.ELossMethod.INTEGRAL" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="at.physics.energy_loss.ELossMethod.TRACKING">
<span class="sig-name descname"><span class="pre">TRACKING</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#at.physics.energy_loss.ELossMethod.TRACKING" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.energy_loss.get_energy_loss">
<span class="sig-name descname"><span class="pre">get_energy_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">ELossMethod.INTEGRAL</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.energy_loss.get_energy_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the energy loss per turn [eV]</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring                        lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><dl>
<dt>method=ELossMethod.INTEGRAL method for energy loss computation</dt><dd><p>The enum class ELossMethod declares 2 values
INTEGRAL: The losses are obtained from</p>
<blockquote>
<div><p>Losses = Cgamma / 2pi * EGeV^4 * i2
Takes into account bending magnets and wigglers.</p>
</div></blockquote>
<dl class="simple">
<dt>TRACKING: The losses are obtained by tracking without cavities.</dt><dd><p>Needs radiation ON, takes into account all radiating elements.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.energy_loss.get_timelag_fromU0">
<span class="sig-name descname"><span class="pre">get_timelag_fromU0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">ELossMethod.INTEGRAL</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cavpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.energy_loss.get_timelag_fromU0" title="Permalink to this definition">#</a></dt>
<dd><p>Get the TimeLag attribute of RF cavities based on frequency,
voltage and energy loss per turn, so that the synchronous phase is zero.
An error occurs if all cavities do not have the same frequency.
Used in set_cavity_phase()</p>
<dl class="simple">
<dt>PARAMETERS</dt><dd><p>ring        lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>method=ELossMethod.INTEGRAL</dt><dd><p>method for energy loss computation. See “get_energy_loss”.</p>
</dd>
<dt>cavpts=None Cavity location. If None, use all cavities.</dt><dd><p>This allows to ignore harmonic cavities.</p>
</dd>
</dl>
</dd>
<dt>RETURN</dt><dd><p>timelag     Timelag
ts          Time difference with the present value</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.energy_loss.set_cavity_phase">
<span class="sig-name descname"><span class="pre">set_cavity_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">ELossMethod.TRACKING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cavpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.energy_loss.set_cavity_phase" title="Permalink to this definition">#</a></dt>
<dd><p>Adjust the TimeLag attribute of RF cavities based on frequency,
voltage and energy loss per turn, so that the synchronous phase is zero.
An error occurs if all cavities do not have the same frequency.</p>
<p>!!!!WARNING!!!: This function changes the time reference,
this should be avoided</p>
<blockquote>
<div><dl class="simple">
<dt>PARAMETERS</dt><dd><p>ring        lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>method=ELossMethod.INTEGRAL</dt><dd><p>method for energy loss computation.
See “get_energy_loss”.</p>
</dd>
<dt>cavpts=None         Cavity location. If None, use all cavities.</dt><dd><p>This allows to ignore harmonic cavities.</p>
</dd>
<dt>copy=False          If True, returns a shallow copy of ring with new</dt><dd><p>cavity elements. Otherwise, modify ring in-place.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

</section>
<section id="module-at.physics.fastring">
<span id="at-physics-fastring-module"></span><h2>at.physics.fastring module<a class="headerlink" href="#module-at.physics.fastring" title="Permalink to this headline">#</a></h2>
<p>Functions relating to fast_ring</p>
<dl class="py function">
<dt class="sig sig-object py" id="at.physics.fastring.fast_ring">
<span class="sig-name descname"><span class="pre">fast_ring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.fastring.fast_ring" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Computes a fast ring consisting of:</dt><dd><p>-1 RF cavity per distinct frequency
-6x6 transfer map
-detuning and chromaticity element
-quantum diffusion element (for radiation ring)</p>
</dd>
</dl>
<p>2 rings are returned one with radiation one without
The original ring is copied such that it is not modified
It is possible to split the original ring in multiple fastrings
using split_inds argument
fr,frrad = at.fast_ring(ring)
fr,frrad = at.fast_ring(ring, split_inds=[100,200])</p>
<dl class="simple">
<dt>PARAMETERS</dt><dd><p>ring            lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><p>split_inds=[]   List of indexes where to split the ring</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-at.physics.harmonic_analysis">
<span id="at-physics-harmonic-analysis-module"></span><h2>at.physics.harmonic_analysis module<a class="headerlink" href="#module-at.physics.harmonic_analysis" title="Permalink to this headline">#</a></h2>
<p>Original author of HarmonicAnalysis class
Jaime Maria Coello De Portugal - Martinez Vazquez</p>
<p>Written while at CERN circa 2016
This is a reduced version keeping only the key components.
Full code can be found at: <a class="reference external" href="https://github.com/pylhc/harpy">https://github.com/pylhc/harpy</a></p>
<dl class="py class">
<dt class="sig sig-object py" id="at.physics.harmonic_analysis.HarmonicAnalysis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HarmonicAnalysis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_pad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hann</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.harmonic_analysis.HarmonicAnalysis" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="at.physics.harmonic_analysis.HarmonicAnalysis.get_coefficient_for_freq">
<span class="sig-name descname"><span class="pre">get_coefficient_for_freq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">freq</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.harmonic_analysis.HarmonicAnalysis.get_coefficient_for_freq" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.physics.harmonic_analysis.HarmonicAnalysis.get_signal">
<span class="sig-name descname"><span class="pre">get_signal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.harmonic_analysis.HarmonicAnalysis.get_signal" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.physics.harmonic_analysis.HarmonicAnalysis.laskar_method">
<span class="sig-name descname"><span class="pre">laskar_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_harmonics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.harmonic_analysis.HarmonicAnalysis.laskar_method" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.harmonic_analysis.get_spectrum_harmonic">
<span class="sig-name descname"><span class="pre">get_spectrum_harmonic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_harmonics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'laskar'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hann</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.harmonic_analysis.get_spectrum_harmonic" title="Permalink to this definition">#</a></dt>
<dd><p>INPUT
cent: centroid motions of the particle
num_harmonics: number of harmonic components to compute (before mask
applied, default=20)
method: laskar or fft [default=laskar]
hann: flag to turn on hanning window [default-&gt; False]</p>
<p>OUTPUT
freq,amp: numpy arrays for the frequency and amplitude</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.harmonic_analysis.get_tunes_harmonic">
<span class="sig-name descname"><span class="pre">get_tunes_harmonic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cents</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_harmonics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hann</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.harmonic_analysis.get_tunes_harmonic" title="Permalink to this definition">#</a></dt>
<dd><p>INPUT
cents: are the centroid motions of the particles
method: laskar or fft
num_harmonics: number of harmonic components to compute (before mask
applied, default=20)
fmin/fmax: determine the boundaries within which the tune is located
[default 0-&gt;1]
hann: flag to turn on hanning window [default-&gt; False]</p>
<p>OUTPUT
tunes: numpy array of length len(cents), max of the spectrum within
fmin:fmax</p>
</dd></dl>

</section>
<section id="module-at.physics.linear">
<span id="at-physics-linear-module"></span><h2>at.physics.linear module<a class="headerlink" href="#module-at.physics.linear" title="Permalink to this headline">#</a></h2>
<p>Coupled or non-coupled 4x4 linear motion</p>
<dl class="py function">
<dt class="sig sig-object py" id="at.physics.linear.avlinopt">
<span class="sig-name descname"><span class="pre">avlinopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.linear.avlinopt" title="Permalink to this definition">#</a></dt>
<dd><p>Perform linear analysis of a lattice and returns average
beta, dispersion and phase advance</p>
<p>lindata,avebeta,avemu,avedisp,tune,chrom = avlinopt(lattice, dp, refpts)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
dp=0.0          momentum deviation.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-8   momentum deviation used for computation of</p>
<blockquote>
<div><p>chromaticities and dispersion</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>lindata         linear optics at the points refered to by refpts, if</dt><dd><p>refpts is None an empty lindata structure is returned.
See linopt4 for details</p>
</dd>
</dl>
<p>avebeta         Average beta functions [betax,betay] at refpts
avemu           Average phase advances [mux,muy] at refpts
avedisp         Average dispersion [Dx,Dx’,Dy,Dy’] at refpts
avespos         Average s position at refpts
tune            [tune_A, tune_B], linear tunes for the two normal modes</p>
<blockquote>
<div><p>of linear motion [1]</p>
</div></blockquote>
<p>chrom           [ksi_A , ksi_B], chromaticities ksi = d(nu)/(dP/P).</p>
</dd>
</dl>
<p>See also linopt4, get_optics</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.linear.get_chrom">
<span class="sig-name descname"><span class="pre">get_chrom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linopt'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cavpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.linear.get_chrom" title="Permalink to this definition">#</a></dt>
<dd><p>gets the chromaticity using several available methods</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description.</p>
</dd>
<dt>KEYWORDS</dt><dd><blockquote>
<div><p>dp=None         Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>method=’linopt’ ‘linopt’ returns the tunes from the linopt function</dt><dd><p>‘laskar’ tracks a single particle and computes the
tunes with NAFF</p>
</dd>
<dt>DPStep=1.0E-6   momentum step used for the computation of</dt><dd><p>chromaticities</p>
</dd>
</dl>
</div></blockquote>
<p>for the ‘laskar’ method only:</p>
<blockquote>
<div><p>nturns=512      number of turns
amplitude=1.0E-6 amplitude of oscillation
remove_dc=False Remove the mean of oscillation data
num_harmonics   number of harmonic components to compute</p>
<blockquote>
<div><p>(before mask applied, default=20)</p>
</div></blockquote>
<dl class="simple">
<dt>fmin/fmax       determine the boundaries within which the tune is</dt><dd><p>located [default 0-&gt;1]</p>
</dd>
</dl>
<p>hann=False      flag to turn on Hanning window</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>chromaticities = np.array([Q’x,Q’y])</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.linear.get_optics">
<span class="sig-name descname"><span class="pre">get_optics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method=&lt;function</span> <span class="pre">linopt6&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.linear.get_optics" title="Permalink to this definition">#</a></dt>
<dd><p>Perform linear analysis of a fully coupled lattice</p>
<p>elemdata0, beamdata, elemdata = get_optics(lattice, refpts, <a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl>
<dt>method=linopt6  Method used for the analysis of the transfer matrix.</dt><dd><p>Can be None at.linopt2, at.linopt4, at.linopt6
linopt2:    no longitudinal motion, no H/V coupling,
linopt4:    no longitudinal motion, Sagan/Rubin</p>
<blockquote>
<div><p>4D-analysis of coupled motion,</p>
</div></blockquote>
<dl class="simple">
<dt>linopt6:    with or without longitudinal motion, normal</dt><dd><p>mode analysis</p>
</dd>
</dl>
</dd>
</dl>
<p>dp=None         Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     computes chromatic amplitude functions (W) [4].</dt><dd><p>Needs to compute the optics at 2 different momentum
deviations around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘R’ or ‘alpha’ and ‘beta’   (mandatory)
‘closed_orbit’,             (default 0)
‘dispersion’                (default 0)
If present, the attribute ‘R’ will be used, otherwise
the attributes ‘alpha’ and ‘beta’ will be used. All
other attributes are ignored.</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>elemdata0       linear optics data at the entrance/end of the ring
beamdata        lattice properties
elemdata        linear optics at the points refered to by refpts, if</p>
<blockquote>
<div><p>refpts is None an empty elemdata structure is returned.</p>
</div></blockquote>
<p>elemdata is a record array with fields depending on the
selected method.
See the help for linopt6, linopt4, linopt2, linopt_auto.</p>
<p>beamdata is a record with fields:
tune            Fractional tunes
chromaticity    Chromaticities
damping_time    Damping times [s] (only if radiation is ON)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.linear.get_tune">
<span class="sig-name descname"><span class="pre">get_tune</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linopt'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.linear.get_tune" title="Permalink to this definition">#</a></dt>
<dd><p>gets the tune using several available methods</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description.</p>
</dd>
<dt>KEYWORDS</dt><dd><blockquote>
<div><p>dp=None         Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>method=’linopt’ ‘linopt’ returns the tunes from the linopt function</dt><dd><p>‘fft’ tracks a single particle and computes the
tunes with fft ‘laskar’ tracks a single particle
and computes the tunes with NAFF</p>
</dd>
</dl>
</div></blockquote>
<p>for the ‘fft’ and ‘laskar’ methods only:</p>
<blockquote>
<div><p>nturns=512      number of turns
amplitude=1.0E-6 amplitude of oscillation
remove_dc=False Remove the mean of oscillation data
num_harmonics   number of harmonic components to compute</p>
<blockquote>
<div><p>(before mask applied, default=20)</p>
</div></blockquote>
<dl class="simple">
<dt>fmin/fmax       determine the boundaries within which the tune is</dt><dd><p>located [default 0-&gt;1]</p>
</dd>
</dl>
<p>hann=False      flag to turn on Hanning window</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>tunes = np.array([Qx,Qy])</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.linear.linopt">
<span class="sig-name descname"><span class="pre">linopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_chrom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.linear.linopt" title="Permalink to this definition">#</a></dt>
<dd><p>Perform linear analysis of a H/V coupled lattice following Sagan/Rubin
4D-analysis of coupled motion</p>
<p>lindata0, tune, chrom, lindata = linopt(lattice, dp, refpts, <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
dp=0.0          momentum deviation.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     computes chromatic amplitude functions (W) [4].</dt><dd><p>Needs to compute the optics at 2 different momentum
deviations around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of</p>
<blockquote>
<div><p>chromaticities and dispersion</p>
</div></blockquote>
<dl class="simple">
<dt>coupled=True    if False, simplify the calculations by assuming</dt><dd><p>no H/V coupling</p>
</dd>
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘alpha’ and ‘beta’  (mandatory)
‘closed_orbit’,     (default 0)
‘dispersion’        (default 0)
All other attributes are ignored.</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>lindata0        linear optics data at the entrance of the ring
tune            [tune_A, tune_B], linear tunes for the two normal modes</p>
<blockquote>
<div><p>of linear motion [1]</p>
</div></blockquote>
<dl class="simple">
<dt>chrom           [ksi_A , ksi_B], chromaticities ksi = d(nu)/(dP/P).</dt><dd><p>Only computed if ‘get_chrom’ is True</p>
</dd>
<dt>lindata         linear optics at the points refered to by refpts, if</dt><dd><p>refpts is None an empty lindata structure is returned.</p>
</dd>
</dl>
<p>lindata is a record array with fields:
idx             element index in the ring
s_pos           longitudinal position [m]
m44             (4, 4) transfer matrix M from the beginning of ring</p>
<blockquote>
<div><p>to the entrance of the element [2]</p>
</div></blockquote>
<p>closed_orbit    (6,) closed orbit vector
dispersion      (4,) dispersion vector
beta            [betax, betay] vector
alpha           [alphax, alphay] vector
mu              [mux, muy], betatron phase (modulo 2*pi)
W               (2,) chromatic amplitude function (only if get_w==True)
All values given at the entrance of each element specified in refpts.
In case coupled == True additional outputs are available:
gamma           gamma parameter of the transformation to eigenmodes
A               (2, 2) matrix A in [3]
B               (2, 2) matrix B in [3]
C               (2, 2) matrix C in [3]
Field values can be obtained with either
lindata[‘idx’]    or
lindata.idx</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] D.Edwards,L.Teng IEEE Trans.Nucl.Sci. NS-20, No.3, p.885-888, 1973
[2] E.Courant, H.Snyder
[3] D.Sagan, D.Rubin Phys.Rev.Spec.Top.-Accelerators and beams,</p>
<blockquote>
<div><p>vol.2 (1999)</p>
</div></blockquote>
<p>[4] Brian W. Montague Report LEP Note 165, CERN, 1979</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.linear.linopt2">
<span class="sig-name descname"><span class="pre">linopt2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.linear.linopt2" title="Permalink to this definition">#</a></dt>
<dd><p>Perform linear analysis of an uncoupled lattice</p>
<p>elemdata0, beamdata, elemdata = linopt2(ring, refpts, <a href="#id5"><span class="problematic" id="id6">**</span></a>kwargs)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
dct=None        path lengthening. If specified, dp is ignored and the</p>
<blockquote>
<div><p>off-momentum is deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     computes chromatic amplitude functions (W) [4].</dt><dd><p>Needs to compute the optics at 2 different momentum
deviations around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of</p>
<blockquote>
<div><p>chromaticities and dispersion</p>
</div></blockquote>
<dl class="simple">
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘alpha’ and ‘beta’  (mandatory)
‘closed_orbit’,     (default 0)
‘dispersion’        (default 0)
All other attributes are ignored.</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>lindata0        linear optics data at the entrance of the ring
beamdata        lattice properties
lindata         linear optics at the points refered to by refpts, if</p>
<blockquote>
<div><p>refpts is None an empty lindata structure is returned.</p>
</div></blockquote>
<p>lindata is a record array with fields:
s_pos           longitudinal position [m]
M               (4, 4) transfer matrix M from the beginning of ring</p>
<blockquote>
<div><p>to the entrance of the element [2]</p>
</div></blockquote>
<p>closed_orbit    (6,) closed orbit vector
dispersion      (4,) dispersion vector
beta            [betax, betay] vector
alpha           [alphax, alphay] vector
mu              [mux, muy], betatron phase (modulo 2*pi)
W               (2,) chromatic amplitude function (only if get_w==True)
All values given at the entrance of each element specified in refpts.
Field values can be obtained with either
lindata[‘idx’]    or
lindata.idx</p>
<p>beamdata is a record with fields:
tune            Fractional tunes
chromaticity    Chromaticities, only computed if get_chrom=True</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] D.Edwards,L.Teng IEEE Trans.Nucl.Sci. NS-20, No.3, p.885-888, 1973
[2] E.Courant, H.Snyder
[3] D.Sagan, D.Rubin Phys.Rev.Spec.Top.-Accelerators and beams,</p>
<blockquote>
<div><p>vol.2 (1999)</p>
</div></blockquote>
<p>[4] Brian W. Montague Report LEP Note 165, CERN, 1979</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.linear.linopt4">
<span class="sig-name descname"><span class="pre">linopt4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.linear.linopt4" title="Permalink to this definition">#</a></dt>
<dd><p>Perform linear analysis of a H/V coupled lattice following Sagan/Rubin
4D-analysis of coupled motion</p>
<p>elemdata0, beamdata, elemdata = linopt4(lattice, refpts, <a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
dct=None        path lengthening. If specified, dp is ignored and the</p>
<blockquote>
<div><p>off-momentum is deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     computes chromatic amplitude functions (W) [4].</dt><dd><p>Needs to compute the optics at 2 different momentum
deviations around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of</p>
<blockquote>
<div><p>chromaticities and dispersion</p>
</div></blockquote>
<dl class="simple">
<dt>twiss_in=None   Initial twiss to compute transfer line optics of the</dt><dd><p>type lindata, the initial orbit in twiss_in is ignored,
only the beta and alpha are required other quatities
set to 0 if absent</p>
</dd>
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘alpha’ and ‘beta’  (mandatory)
‘closed_orbit’,     (default 0)
‘dispersion’        (default 0)
All other attributes are ignored.</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>lindata0        linear optics data at the entrance of the ring
beamdata        lattice properties
lindata         linear optics at the points refered to by refpts, if</p>
<blockquote>
<div><p>refpts is None an empty lindata structure is returned.</p>
</div></blockquote>
<p>lindata is a record array with fields:
s_pos           longitudinal position [m]
M               (4, 4) transfer matrix M from the beginning of ring</p>
<blockquote>
<div><p>to the entrance of the element [2]</p>
</div></blockquote>
<p>closed_orbit    (6,) closed orbit vector
dispersion      (4,) dispersion vector
beta            [betax, betay] vector
alpha           [alphax, alphay] vector
mu              [mux, muy], betatron phase (modulo 2*pi)
gamma           gamma parameter of the transformation to eigenmodes [3]
W               (2,) chromatic amplitude function (only if get_w==True)
All values given at the entrance of each element specified in refpts.
Field values can be obtained with either
lindata[‘idx’]    or
lindata.idx</p>
<p>beamdata is a record with fields:
tune            Fractional tunes
chromaticity    Chromaticities, only computed if get_chrom==True</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] D.Edwards,L.Teng IEEE Trans.Nucl.Sci. NS-20, No.3, p.885-888, 1973
[2] E.Courant, H.Snyder
[3] D.Sagan, D.Rubin Phys.Rev.Spec.Top.-Accelerators and beams,</p>
<blockquote>
<div><p>vol.2 (1999)</p>
</div></blockquote>
<p>[4] Brian W. Montague Report LEP Note 165, CERN, 1979</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.linear.linopt6">
<span class="sig-name descname"><span class="pre">linopt6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.linear.linopt6" title="Permalink to this definition">#</a></dt>
<dd><p>Perform linear analysis of a fully coupled lattice using normal modes</p>
<p>elemdata0, beamdata, elemdata = linopt6(lattice, refpts, <a href="#id9"><span class="problematic" id="id10">**</span></a>kwargs)</p>
<p>For circular machines, linopt6 analyses
the 4x4 1-turn transfer matrix if radiation is OFF, or
the 6x6 1-turn transfer matrix if radiation is ON.</p>
<dl>
<dt>For a transfer line, The “twiss_in” intput must contain either:</dt><dd><ul class="simple">
<li><p>a field ‘R’, as provided by ATLINOPT6, or</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>the fields ‘beta’ and ‘alpha’, as provided by linopt and linopt6</p></li>
</ul>
</div></blockquote>
</dd>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
refpts=None     elements at which data is returned.</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=None         Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     compute chromatic amplitude functions (W) [3]. Needs to</dt><dd><p>compute the optics at 2 different momentum deviations
around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of</p>
<blockquote>
<div><p>the closed orbit</p>
</div></blockquote>
<dl class="simple">
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘R’ or ‘alpha’ and ‘beta’   (mandatory)
‘closed_orbit’,             (default 0)
‘dispersion’                (default 0)
If present, the attribute ‘R’ will be used, otherwise
the attributes ‘alpha’ and ‘beta’ will be used. All
other attributes are ignored.</p>
</dd>
</dl>
<p>cavpts=None     Cavity location for off-momentum tuning</p>
</dd>
<dt>OUTPUT</dt><dd><p>elemdata0       linear optics data at the entrance of the ring
beamdata        lattice properties
elemdata        linear optics at the points refered to by refpts, if</p>
<blockquote>
<div><p>refpts is None an empty elemdata structure is returned.</p>
</div></blockquote>
<p>elemdata is a record array with fields:
s_pos           longitudinal position [m]
M               Transfer matrix from the entrance of the line (6, 6)
closed_orbit    (6,) closed orbit vector
dispersion      (4,) dispersion vector
A               A-matrix (6, 6)
R               R-matrices (3, 6, 6)
beta            [betax, betay] vector
alpha           [alphax, alphay] vector
mu              [mux, muy], betatron phases
W               (2,) chromatic amplitude function (only if get_w==True)</p>
<p>All values given at the entrance of each element specified in refpts.
Field values can be obtained with either
elemdata[‘beta’]    or
elemdata.beta</p>
<p>beamdata is a record with fields:
tune            Fractional tunes
chromaticity    Chromaticities, only computed if get_chrom==True
damping_time    Damping times [s] (only if radiation is ON)</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] Etienne Forest, Phys. Rev. E 58, 2481 – Published 1 August 1998
[2] Andrzej Wolski, Phys. Rev. ST Accel. Beams 9, 024001 –</p>
<blockquote>
<div><p>Published 3 February 2006</p>
</div></blockquote>
<p>[3] Brian W. Montague Report LEP Note 165, CERN, 1979</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-at.physics.matrix">
<span id="at-physics-matrix-module"></span><h2>at.physics.matrix module<a class="headerlink" href="#module-at.physics.matrix" title="Permalink to this headline">#</a></h2>
<p>transfer matrix related functions</p>
<p>A collection of functions to compute 4x4 and 6x6 transfer matrices</p>
<dl class="py function">
<dt class="sig sig-object py" id="at.physics.matrix.find_elem_m66">
<span class="sig-name descname"><span class="pre">find_elem_m66</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.matrix.find_elem_m66" title="Permalink to this definition">#</a></dt>
<dd><p>Numerically find the 6x6 transfer matrix of a single element</p>
<dl>
<dt>INPUT</dt><dd><p>elem                AT element</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit=None          closed orbit at the entrance of the element,</dt><dd><p>default: 0.0</p>
</dd>
</dl>
<p>XYStep=1.e-8        transverse step for numerical computation</p>
</dd>
<dt>OUTPUT</dt><dd><p>m66                 (6, 6) transfer matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.matrix.find_m44">
<span class="sig-name descname"><span class="pre">find_m44</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.matrix.find_m44" title="Permalink to this definition">#</a></dt>
<dd><p>find_m44 numerically finds the 4x4 transfer matrix of an accelerator
lattice for a particle with relative momentum deviation DP</p>
<p>IMPORTANT!!! find_m44 assumes constant momentum deviation.
PassMethod used for any element in the lattice SHOULD NOT
1.  change the longitudinal momentum dP</p>
<blockquote>
<div><p>(cavities , magnets with radiation, …)</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>have any time dependence (localized impedance, fast kickers, …)</p></li>
</ol>
<dl>
<dt>m44, t = find_m44(lattice, dp=0.0, refpts)</dt><dd><p>return 4x4 transfer matrices between the entrance of the first element
and each element indexed by refpts.</p>
<blockquote>
<div><p>m44:    full one-turn matrix at the entrance of the first element
t:      4x4 transfer matrices between the entrance of the first</p>
<blockquote>
<div><p>element and each element indexed by refpts:
(Nrefs, 4, 4) array</p>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
<p>Unless an input orbit is introduced, find_m44 assumes that the lattice is
a ring and first finds the closed orbit.</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description
dp              momentum deviation. Defaults to 0
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for mstack.</p>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>dct=None        path lengthening. If specified, dp is ignored and</dt><dd><p>the off-momentum is deduced from the path lengthening.</p>
</dd>
<dt>orbit=None      avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>keep_lattice=False  When True, assume no lattice change since the</dt><dd><p>previous tracking.</p>
</dd>
<dt>full=False      When True, matrices are full 1-turn matrices at</dt><dd><p>the entrance of each
element indexed by refpts.</p>
</dd>
<dt>orbit=None      Avoids looking for the closed orbit if is already</dt><dd><p>known (6,) array</p>
</dd>
</dl>
<p>XYStep=1.e-8    transverse step for numerical computation</p>
</dd>
</dl>
<p>See also find_m66, find_orbit4</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.matrix.find_m66">
<span class="sig-name descname"><span class="pre">find_m66</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.matrix.find_m66" title="Permalink to this definition">#</a></dt>
<dd><p>find_m66 numerically finds the 6x6 transfer matrix of an accelerator
lattice by differentiation of lattice_pass near the closed orbit.
find_m66 uses find_orbit6 to search for the closed orbit in 6-D
In order for this to work the ring MUST have a CAVITY element</p>
<dl>
<dt>m66, t = find_m66(lattice, refpts)</dt><dd><dl class="simple">
<dt>m66:    full one-turn 6-by-6 matrix at the entrance of the</dt><dd><p>first element.</p>
</dd>
<dt>t:      6x6 transfer matrices between the entrance of the first</dt><dd><p>element and each element indexed by refpts (nrefs, 6, 6) array.</p>
</dd>
</dl>
</dd>
<dt>PARAMETERS</dt><dd><p>ring            lattice description
dp              momentum deviation. Defaults to 0
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for mstack.</p>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>keep_lattice=False  When True, assume no lattice change since the</dt><dd><p>previous tracking.</p>
</dd>
<dt>orbit=None          Avoids looking for the closed orbit if is already</dt><dd><p>known (6,) array</p>
</dd>
</dl>
<p>XYStep=1.e-8        transverse step for numerical computation</p>
</dd>
</dl>
<p>See also find_m44, find_orbit6</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.matrix.gen_m66_elem">
<span class="sig-name descname"><span class="pre">gen_m66_elem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">o4b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">o4e</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.matrix.gen_m66_elem" title="Permalink to this definition">#</a></dt>
<dd><p>converts a ring to a linear 6x6 matrix tracking elemtn</p>
</dd></dl>

</section>
<section id="module-at.physics.nonlinear">
<span id="at-physics-nonlinear-module"></span><h2>at.physics.nonlinear module<a class="headerlink" href="#module-at.physics.nonlinear" title="Permalink to this headline">#</a></h2>
<p>Function to compute quantities related to non-linear optics</p>
<dl class="py function">
<dt class="sig sig-object py" id="at.physics.nonlinear.chromaticity">
<span class="sig-name descname"><span class="pre">chromaticity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linopt'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dpm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.nonlinear.chromaticity" title="Permalink to this definition">#</a></dt>
<dd><p>This function uses computes the tunes to compute the tune for
the specified momentum offsets. Then it fits this data and returns
the chromaticity up to the given order (npoints&gt;order)
OUTPUT</p>
<blockquote>
<div><p>(fitx, fity), dpa, qz</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.nonlinear.detuning">
<span class="sig-name descname"><span class="pre">detuning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nturns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.nonlinear.detuning" title="Permalink to this definition">#</a></dt>
<dd><p>This function uses tunes_vs_amp to compute the tunes for
the specified amplitudes. Then it fits this data and returns
result for dQx/dx, dQy/dx, dQx/dy, dQy/dy</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.nonlinear.gen_detuning_elem">
<span class="sig-name descname"><span class="pre">gen_detuning_elem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.nonlinear.gen_detuning_elem" title="Permalink to this definition">#</a></dt>
<dd><p>Generates an element that for detuning with amplitude</p>
</dd></dl>

</section>
<section id="module-at.physics.orbit">
<span id="at-physics-orbit-module"></span><h2>at.physics.orbit module<a class="headerlink" href="#module-at.physics.orbit" title="Permalink to this headline">#</a></h2>
<p>Closed orbit related functions</p>
<dl class="py function">
<dt class="sig sig-object py" id="at.physics.orbit.find_orbit">
<span class="sig-name descname"><span class="pre">find_orbit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.orbit.find_orbit" title="Permalink to this definition">#</a></dt>
<dd><p>find_orbit finds the closed orbit by numerically getting the fixed point
of the one turn map M calculated with lattice_pass.</p>
<p>Depending on the the lattice, find_orbit will:
- use find_orbit6 if ring.radiation is ON,
- use find_sync_orbit if ring.radiation is OFF and dct is specified,
- use find_orbit4 otherwise</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            Sequence of AT elements
refpts          elements at which data is returned.</p>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>orbit0          ((6,) closed orbit vector at the entrance of the</dt><dd><p>1-st element</p>
</dd>
<dt>orbit           (6, Nrefs) closed orbit vector at each location</dt><dd><p>specified in refpts</p>
</dd>
</dl>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0            Momentum deviation, when radiation is OFF
dct=0            Path lengthening, when radiation ids OFF
keep_lattice    Assume no lattice change since the previous tracking.</p>
<blockquote>
<div><p>Default: False</p>
</div></blockquote>
<dl class="simple">
<dt>guess=None      Initial guess for the closed orbit. It may help</dt><dd><p>convergence.</p>
</dd>
<dt>orbit=None      Orbit at entrance of the lattice, if known. find_orbit</dt><dd><p>will then propagate it to the selected reference points</p>
</dd>
</dl>
<p>For other keywords, refer to the underlying methods</p>
</dd>
</dl>
<p>See also find_orbit4, find_sync_orbit, find_orbit6</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.orbit.find_orbit4">
<span class="sig-name descname"><span class="pre">find_orbit4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.orbit.find_orbit4" title="Permalink to this definition">#</a></dt>
<dd><p>findorbit4 finds the closed orbit in the 4-d transverse phase
space by numerically solving for a fixed point of the one turn
map M calculated with lattice_pass.</p>
<blockquote>
<div><p>(X, PX, Y, PY, dP, CT2 ) = M (X, PX, Y, PY, dP, CT1)</p>
</div></blockquote>
<p>under the CONSTANT MOMENTUM constraint dP and with NO constraint
on the 6-th coordinate CT</p>
<p>IMPORTANT!!! findorbit4 imposes a constraint on dP and relaxes
the constraint on the revolution frequency. A physical storage
ring does exactly the opposite: the momentum deviation of a
particle on the closed orbit settles at the value
such that the revolution is synchronous with the RF cavity</p>
<blockquote>
<div><p>HarmNumber*Frev = Frf</p>
</div></blockquote>
<p>To impose this artificial constraint in find_orbit4, PassMethod
used for any element SHOULD NOT
1.  change the longitudinal momentum dP (cavities , magnets with radiation)
2.  have any time dependence (localized impedance, fast kickers etc)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be OFF)
dp              momentum deviation. Defaults to 0
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for orbit.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>orbit0          ((6,) closed orbit vector at the entrance of the</dt><dd><p>1-st element (x,px,y,py)</p>
</dd>
<dt>orbit           (6, Nrefs) closed orbit vector at each location</dt><dd><p>specified in refpts</p>
</dd>
</dl>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>dct=None        path lengthening. If specified, dp is ignored and</dt><dd><p>the off-momentum is deduced from the path lengthening.</p>
</dd>
<dt>orbit=None      avoids looking for initial the closed orbit if is</dt><dd><p>already known ((6,) array). find_orbit4 propagates it
to the specified refpts.</p>
</dd>
<dt>guess           (6,) initial value for the closed orbit. It may help</dt><dd><p>convergence. Default: (0, 0, 0, 0, 0, 0)</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Default: False</p>
</dd>
</dl>
<p>convergence     Convergence criterion. Default: 1.e-12
max_iterations  Maximum number of iterations. Default: 20
XYStep          Step size. Default: DConstant.XYStep</p>
</dd>
</dl>
<p>See also find_sync_orbit, find_orbit6.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.orbit.find_orbit6">
<span class="sig-name descname"><span class="pre">find_orbit6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.orbit.find_orbit6" title="Permalink to this definition">#</a></dt>
<dd><p>find_orbit6 finds the closed orbit in the full 6-D phase space
by numerically solving  for a fixed point of the one turn
map M calculated with lattice_pass</p>
<p>(X, PX, Y, PY, DP, CT2 ) = M (X, PX, Y, PY, DP, CT1)</p>
<p>with constraint  CT2 - CT1 = C*HarmNumber(1/Frf - 1/Frf0)</p>
<p>IMPORTANT!!! find_orbit6 is a realistic simulation
1.  The Frf frequency in the RF cavities (may be different from Frf0)</p>
<blockquote>
<div><p>imposes the synchronous condition
CT2 - CT1 = C*HarmNumber(1/Frf - 1/Frf0)</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>The algorithm numerically calculates
6-by-6 Jacobian matrix J6. In order for (J-E) matrix
to be non-singular it is NECESSARY to use a realistic
PassMethod for cavities with non-zero momentum kick
(such as RFCavityPass).</p></li>
<li><p>find_orbit6 can find orbits with radiation.
In order for the solution to exist the cavity must supply
adequate energy compensation.
In the simplest case of a single cavity, it must have
‘Voltage’ field set so that Voltage &gt; Erad - energy loss per turn</p></li>
<li><p>There is a family of solutions that correspond to different RF buckets
They differ in the 6-th coordinate by C*Nb/Frf. Nb = 1 .. HarmNum-1</p></li>
<li><p>The value of the 6-th coordinate found at the cavity gives
the equilibrium RF phase. If there is no radiation the phase is 0;</p></li>
</ol>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be ON)
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for orbit.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>orbit0          ((6,) closed orbit vector at the entrance of the</dt><dd><p>1-st element (x,px,y,py)</p>
</dd>
<dt>orbit           (6, Nrefs) closed orbit vector at each location</dt><dd><p>specified in refpts</p>
</dd>
</dl>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit=None      avoids looking for initial the closed orbit if is</dt><dd><p>already known ((6,) array). find_orbit6 propagates it
to the specified refpts.</p>
</dd>
<dt>guess           Initial value for the closed orbit. It may help</dt><dd><p>convergence. The default is computed from the energy
loss of the ring</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Default: False</p>
</dd>
<dt>method          Method for energy loss computation</dt><dd><p>(see get_energy_loss)
default: ELossMethod.TRACKING</p>
</dd>
<dt>cavpts=None     Cavity location. If None, use all cavities.</dt><dd><p>This is used to compute the initial synchronous phase.</p>
</dd>
</dl>
<p>convergence     Convergence criterion. Default: 1.e-12
max_iterations  Maximum number of iterations. Default: 20
XYStep          Step size. Default: DConstant.XYStep
DPStep          Step size. Default: DConstant.DPStep</p>
</dd>
</dl>
<p>See also find_orbit4, find_sync_orbit.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.orbit.find_sync_orbit">
<span class="sig-name descname"><span class="pre">find_sync_orbit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.orbit.find_sync_orbit" title="Permalink to this definition">#</a></dt>
<dd><p>find_sync_orbit finds the closed orbit, synchronous with the RF cavity
and momentum deviation dP (first 5 components of the phase space vector)
% by numerically solving  for a fixed point
% of the one turn map M calculated with lattice_pass</p>
<blockquote>
<div><p>(X, PX, Y, PY, dP, CT2 ) = M (X, PX, Y, PY, dP, CT1)</p>
</div></blockquote>
<p>under the constraint dCT = CT2 - CT1 = C/Frev - C/Frev0, where
Frev0 = Frf0/HarmNumber is the design revolution frequency
Frev  = (Frf0 + dFrf)/HarmNumber is the imposed revolution frequency</p>
<p>IMPORTANT!!!  find_sync_orbit imposes a constraint (CT2 - CT1) and
dP2 = dP1 but no constraint on the value of dP1, dP2
The algorithm assumes time-independent fixed-momentum ring
to reduce the dimensionality of the problem.</p>
<p>To impose this artificial constraint in find_sync_orbit
PassMethod used for any element SHOULD NOT
1.  change the longitudinal momentum dP (cavities , magnets with radiation)
2.  have any time dependence (localized impedance, fast kickers etc).</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be OFF)
dct             Path length deviation. Default: 0
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for orbit.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>orbit0          ((6,) closed orbit vector at the entrance of the</dt><dd><p>1-st element (x,px,y,py)</p>
</dd>
<dt>orbit           (6, Nrefs) closed orbit vector at each location</dt><dd><p>specified in refpts</p>
</dd>
</dl>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit=None      avoids looking for initial the closed orbit if is</dt><dd><p>already known ((6,) array). find_sync_orbit propagates
it to the specified refpts.</p>
</dd>
<dt>guess           (6,) initial value for the closed orbit. It may help</dt><dd><p>convergence. Default: (0, 0, 0, 0, 0, 0)</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Default: False</p>
</dd>
</dl>
<p>convergence     Convergence criterion. Default: 1.e-12
max_iterations  Maximum number of iterations. Default: 20
XYStep          Step size. Default: DConstant.XYStep</p>
</dd>
</dl>
<p>See also find_orbit4, find_orbit6.</p>
</dd></dl>

</section>
<section id="module-at.physics.radiation">
<span id="at-physics-radiation-module"></span><h2>at.physics.radiation module<a class="headerlink" href="#module-at.physics.radiation" title="Permalink to this headline">#</a></h2>
<p>Radiation and equilibrium emittances</p>
<dl class="py function">
<dt class="sig sig-object py" id="at.physics.radiation.gen_quantdiff_elem">
<span class="sig-name descname"><span class="pre">gen_quantdiff_elem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.radiation.gen_quantdiff_elem" title="Permalink to this definition">#</a></dt>
<dd><p>Generates a quantum diffusion element</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.radiation.get_radiation_integrals">
<span class="sig-name descname"><span class="pre">get_radiation_integrals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">twiss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.radiation.get_radiation_integrals" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the 5 radiation integrals for uncoupled lattices.</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description.</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>twiss=None      linear optics at all points (from linopt). If None,</dt><dd><p>it will be computed.</p>
</dd>
</dl>
<p>dp=0.0          Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl>
<dt>method=linopt6  Method used for the analysis of the transfer matrix.</dt><dd><p>See get_optics.
linopt6: default
linopt2: faster if no longitudinal motion and</p>
<blockquote>
<div><p>no H/V coupling,</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>i1, i2, i3, i4, i5</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.radiation.ohmi_envelope">
<span class="sig-name descname"><span class="pre">ohmi_envelope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.radiation.ohmi_envelope" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the equilibrium beam envelope in a
circular accelerator using Ohmi’s beam envelope formalism [1]</p>
<p>emit0, beamdata, emit = ohmi_envelope(ring[, refpts])</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            Lattice object.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit=None          Avoids looking for the closed orbit if it is</dt><dd><p>already known ((6,) array)</p>
</dd>
<dt>keep_lattice=False  Assume no lattice change since the previous</dt><dd><p>tracking</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>emit0               emittance data at the start/end of the ring
beamdata            beam parameters at the start of the ring
emit                emittance data at the points refered to by refpts,</p>
<blockquote>
<div><p>if refpts is None an empty structure is returned.</p>
</div></blockquote>
<p>emit is a record array with fields:
r66                 (6, 6) equilibrium envelope matrix R
r44                 (4, 4) betatron emittance matrix (dpp = 0)
m66                 (6, 6) transfer matrix from the start of the ring
orbit6              (6,) closed orbit
emitXY              (2,) betatron emittance projected on xxp and yyp
emitXYZ             (3,) 6x6 emittance projected on xxp, yyp, ldp</p>
<p>beamdata is a record array with fields:
tunes               tunes of the 3 normal modes
damping_rates       damping rates of the 3 normal modes
mode_matrices       R-matrices of the 3 normal modes
mode_emittances     equilibrium emittances of the 3 normal modes</p>
<p>Field values can be obtained with either
emit[‘r66’]    or
emit.r66</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] K.Ohmi et al. Phys.Rev.E. Vol.49. (1994)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.radiation.quantdiffmat">
<span class="sig-name descname"><span class="pre">quantdiffmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.radiation.quantdiffmat" title="Permalink to this definition">#</a></dt>
<dd><p>This function computes the diffusion matrix of the whole ring</p>
<dl class="simple">
<dt>PARAMETERS</dt><dd><p>ring            lattice description.
orbit=None      initial orbit</p>
</dd>
<dt>OUTPUT</dt><dd><p>diffusion matrix (6,6)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.radiation.tapering">
<span class="sig-name descname"><span class="pre">tapering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multipoles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.radiation.tapering" title="Permalink to this definition">#</a></dt>
<dd><p>Scales magnet strength with local energy to cancel the closed orbit
and optics errors due to synchrotron radiations. PolynomB is used for
dipoles such that the machine geometry is maintained. This is the ideal
tapering scheme where magnets and multipoles components (PolynomB and
PolynomA) are scaled individually.
!!! WARNING: This method works only for lattices without errors and
corrections: if not all corrections and field errors will also be
scaled !!!
tapering(ring) or ring.tapering()
PARAMETERS</p>
<blockquote>
<div><p>ring            lattice description.</p>
</div></blockquote>
<dl>
<dt>KEYWORDS</dt><dd><p>multipoles=True scale all multipoles
method          Method for energy loss computation</p>
<blockquote>
<div><p>(see get_energy_loss)</p>
</div></blockquote>
<p>niter=1         number of iteration
XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of orbit6</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-at.physics.revolution">
<span id="at-physics-revolution-module"></span><h2>at.physics.revolution module<a class="headerlink" href="#module-at.physics.revolution" title="Permalink to this headline">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="at.physics.revolution.get_mcf">
<span class="sig-name descname"><span class="pre">get_mcf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.revolution.get_mcf" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the momentum compaction factor</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be OFF)</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
keep_lattice    Assume no lattice change since the previous tracking.</p>
<blockquote>
<div><p>Defaults to False</p>
</div></blockquote>
<p>dp_step=1.0E-6  momentum deviation used for differentiation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.revolution.get_revolution_frequency">
<span class="sig-name descname"><span class="pre">get_revolution_frequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.revolution.get_revolution_frequency" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the revolution frequency of the full ring [Hz]</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
dct=0.0         Path length deviation
keep_lattice    Assume no lattice change since the previous tracking.</p>
<blockquote>
<div><p>Defaults to False</p>
</div></blockquote>
<p>dp_step=1.0E-6  momentum deviation used for differentiation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.revolution.get_slip_factor">
<span class="sig-name descname"><span class="pre">get_slip_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.revolution.get_slip_factor" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the slip factor</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be OFF)</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
keep_lattice    Assume no lattice change since the previous tracking.</p>
<blockquote>
<div><p>Defaults to False</p>
</div></blockquote>
<p>dp_step=1.0E-6  momentum deviation used for differentiation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.revolution.set_rf_frequency">
<span class="sig-name descname"><span class="pre">set_rf_frequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.revolution.set_rf_frequency" title="Permalink to this definition">#</a></dt>
<dd><p>Set the RF frequency</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description
frequency       RF frequency [Hz]. Default: nominal frequency.</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          Momentum deviation.
dct=0.0         Path length deviation
cavpts=None     If None, look for ring.cavpts, or otherwise take all</p>
<blockquote>
<div><p>cavities.</p>
</div></blockquote>
<dl class="simple">
<dt>array=False     If False, frequency is applied to the selected cavities</dt><dd><p>with the lowest frequency. The frequency of all the
other selected cavities is scaled by the same ratio.
If True, directly apply frequency to the selected
cavities. The value must be broadcastable to the number
of cavities.</p>
</dd>
<dt>copy=False      If True, returns a shallow copy of ring with new</dt><dd><p>cavity elements. Otherwise, modify ring in-place</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-at.physics.ring_parameters">
<span id="at-physics-ring-parameters-module"></span><h2>at.physics.ring_parameters module<a class="headerlink" href="#module-at.physics.ring_parameters" title="Permalink to this headline">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="at.physics.ring_parameters.RingParameters">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RingParameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.ring_parameters.RingParameters" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class for pretty printing the ring properties</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.physics.ring_parameters.RingParameters.props">
<span class="sig-name descname"><span class="pre">props</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{'E0':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Energy:</span> <span class="pre">{0:e}</span> <span class="pre">eV',</span> <span class="pre">'J':</span> <span class="pre">'Damping</span> <span class="pre">partition</span> <span class="pre">numbers:</span> <span class="pre">{0}',</span> <span class="pre">'Tau':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Damping</span> <span class="pre">times:</span> <span class="pre">{0}</span> <span class="pre">s',</span> <span class="pre">'U0':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Energy</span> <span class="pre">loss</span> <span class="pre">/</span> <span class="pre">turn:</span> <span class="pre">{0:e}</span> <span class="pre">eV',</span> <span class="pre">'alphac':</span> <span class="pre">'</span> <span class="pre">Momentum</span> <span class="pre">compact.</span> <span class="pre">factor:</span> <span class="pre">{0:e}',</span> <span class="pre">'chromaticities':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Chromaticities:</span> <span class="pre">{0}',</span> <span class="pre">'emittances':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Mode</span> <span class="pre">emittances:</span> <span class="pre">{0}',</span> <span class="pre">'etac':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Slip</span> <span class="pre">factor:</span> <span class="pre">{0:e}',</span> <span class="pre">'f_s':</span> <span class="pre">'</span>&#160;&#160;&#160; <span class="pre">Synchrotron</span> <span class="pre">frequency:</span> <span class="pre">{0:g}</span> <span class="pre">Hz',</span> <span class="pre">'fulltunes':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Tunes:</span> <span class="pre">{0}',</span> <span class="pre">'i1':</span> <span class="pre">'</span> <span class="pre">Radiation</span> <span class="pre">integrals</span> <span class="pre">-</span> <span class="pre">I1:</span> <span class="pre">{0}</span> <span class="pre">m',</span> <span class="pre">'i2':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">I2:</span> <span class="pre">{0}</span> <span class="pre">m^-1',</span> <span class="pre">'i3':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">I3:</span> <span class="pre">{0}</span> <span class="pre">m^-2',</span> <span class="pre">'i4':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">I4:</span> <span class="pre">{0}</span> <span class="pre">m^-1',</span> <span class="pre">'i5':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">I5:</span> <span class="pre">{0}</span> <span class="pre">m^-1',</span> <span class="pre">'phi_s':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Synchrotron</span> <span class="pre">phase:</span> <span class="pre">{0:g}</span> <span class="pre">rd',</span> <span class="pre">'sigma_e':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Energy</span> <span class="pre">spread:</span> <span class="pre">{0:g}',</span> <span class="pre">'sigma_l':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Bunch</span> <span class="pre">length:</span> <span class="pre">{0:g}</span> <span class="pre">m',</span> <span class="pre">'tunes':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Frac.</span> <span class="pre">tunes:</span> <span class="pre">{0}',</span> <span class="pre">'tunes6':</span> <span class="pre">'</span>&#160; <span class="pre">Frac.</span> <span class="pre">tunes</span> <span class="pre">(6D</span> <span class="pre">motion):</span> <span class="pre">{0}',</span> <span class="pre">'voltage':</span> <span class="pre">'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Cavities</span> <span class="pre">voltage:</span> <span class="pre">{0}</span> <span class="pre">V'}</span></em><a class="headerlink" href="#at.physics.ring_parameters.RingParameters.props" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.ring_parameters.envelope_parameters">
<span class="sig-name descname"><span class="pre">envelope_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.ring_parameters.envelope_parameters" title="Permalink to this definition">#</a></dt>
<dd><p>Compute ring parameters from ohmi_envelope</p>
<dl>
<dt>INPUT</dt><dd><p>ring            Lattice object.</p>
</dd>
<dt>KEYWORD</dt><dd><p>params=None     RingParam object to be updated.</p>
</dd>
<dt>OUTPUT</dt><dd><p>params          RingParam object. The computed attributes are,</p>
<blockquote>
<div><p>tunes6          (3,) fractional (H, V, Long.) tunes (6D motion)
emittances      (3,) Mode emittances
J               (3,) Damping partition numbers
Tau             (3,) Damping times [s]
sigma_e         Energy spread
sigma_l         Bunch length [m]
voltage         Total accelerating voltage [V]
phi_s           Synchrotron phase [rad]
f_s             Synchrotron frequency [Hz]</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.physics.ring_parameters.radiation_parameters">
<span class="sig-name descname"><span class="pre">radiation_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.physics.ring_parameters.radiation_parameters" title="Permalink to this definition">#</a></dt>
<dd><p>Compute ring parameters from the radiation integrals. Valid for
uncoupled lattices with no RF cavity or radiating element.</p>
<dl>
<dt>INPUT</dt><dd><p>ring            Lattice object.</p>
</dd>
<dt>KEYWORD</dt><dd><p>params=None     RingParam object to be updated.
dp=0.0          Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl>
<dt>method=linopt6  Method used for the analysis of the transfer matrix.</dt><dd><p>See get_optics.
linopt6: default
linopt2: faster if no longitudinal motion and</p>
<blockquote>
<div><p>no H/V coupling,</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>params          RingParam object. The computed attributes are,</p>
<blockquote>
<div><p>tunes           (3,) fractional (H, V, Long.) tunes
fulltunes       (3,) full tunes
chromaticities  (2,) H, V Chromaticities
alphac          Momentum compaction factor
etac            Frequency slip factor
E0              Energy [eV]
U0              nergy loss / turn [eV]
i1              Radiation integrals - I1 [m]
i2                                    I2 [m^-1]
i3                                    I3 [m^-2]
i4                                    I4 [m^-1]
i5                                    I5 [m^-1]
emittances      (3,) Mode emittances
J               (3,) Damping partition numbers
Tau             (3,) Damping times [s]
sigma_e         Energy spread
sigma_l         Bunch length [m]
voltage         Total accelerating voltage [V]
phi_s           Synchrotron phase [rad]
f_s             Synchrotron frequency [Hz]</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</section>
</section>


              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="at.matching.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">at.matching package</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="at.plot.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">at.plot package</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By ATCollab<br/>
  
      &copy; Copyright 2022, ATCollab.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>