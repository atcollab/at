<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Installation &mdash; pyAT 0.2 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="at.acceptance package" href="at.acceptance.html" />
    <link rel="prev" title="pyAT Examples" href="examples_link.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> pyAT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="readme_link.html">pyAT</a></li>
<li class="toctree-l1"><a class="reference internal" href="developers_link.html">pyAT Developer Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="developers_link.html#release-procedure">Release procedure</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_link.html">pyAT Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">How to:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="#pyat-primer">pyAT Primer</a></li>
<li class="toctree-l1"><a class="reference internal" href="#cavity-control">Cavity Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="#collective-effects">Collective effects</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="at.acceptance.html">at.acceptance package</a></li>
<li class="toctree-l1"><a class="reference internal" href="at.collective.html">at.collective package</a></li>
<li class="toctree-l1"><a class="reference internal" href="at.lattice.html">at.lattice package</a></li>
<li class="toctree-l1"><a class="reference internal" href="at.load.html">at.load package</a></li>
<li class="toctree-l1"><a class="reference internal" href="at.matching.html">at.matching package</a></li>
<li class="toctree-l1"><a class="reference internal" href="at.physics.html">at.physics package</a></li>
<li class="toctree-l1"><a class="reference internal" href="at.plot.html">at.plot package</a></li>
<li class="toctree-l1"><a class="reference internal" href="at.tracking.html">at.tracking package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pyAT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Installation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/installation_link.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="installation">
<h1>Installation<a class="headerlink" href="#installation" title="Permalink to this headline"></a></h1>
<p>—
title: PyAT
—
pyAT is a Python interface to Accelerator Toolbox. It uses the ‘pass methods’ defined in Accelerator Toolbox, implemented by compiling the C code used in the AT ‘integrators’ into a Python extension. These pass methods are used by higher-level functions to provide physics results.</p>
<p>## Requirements
pyAT supports Python 3.6 to 3.9.
## Installation
### From PyPI
Install accelerator-toolbox from PyPI:
<code class="docutils literal notranslate"><span class="pre">`shell</span>
<span class="pre">$</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">accelerator-toolbox</span>
<span class="pre">``</span></code></p>
<p>### From GitHub
1. Install git on your computer.</p>
<ol class="arabic simple" start="2">
<li><dl class="simple">
<dt>Download the latest version of AT:</dt><dd><p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>shell</p>
</dd>
<dt>$ git clone <a class="reference external" href="https://github.com/atcollab/at.git">https://github.com/atcollab/at.git</a></dt><dd><p><a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
</dd>
</dl>
</li>
<li><p>Go to the pyAT installation directory
<code class="docutils literal notranslate"><span class="pre">`shell</span>
<span class="pre">$</span> <span class="pre">cd</span> <span class="pre">at/pyat</span>
<span class="pre">`</span></code></p></li>
<li><p>Build and install
<code class="docutils literal notranslate"><span class="pre">`shell</span>
<span class="pre">$</span> <span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span>
<span class="pre">`</span></code></p></li>
</ol>
<p>## Usage
Example usage::
<code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">from</span> <span class="pre">at.load</span> <span class="pre">import</span> <span class="pre">load_mat</span>
<span class="pre">from</span> <span class="pre">at.physics</span> <span class="pre">import</span> <span class="pre">linopt</span>
<span class="pre">ring</span> <span class="pre">=</span> <span class="pre">load_mat('test_matlab/hmba.mat')</span>
<span class="pre">linopt(ring,</span> <span class="pre">refpts=range(5))</span>
<span class="pre">`</span></code></p>
<p>For more examples of how to use pyAT, see <code class="docutils literal notranslate"><span class="pre">pyat_examples.rst</span></code>.</p>
</section>
<section id="pyat-primer">
<h1>pyAT Primer<a class="headerlink" href="#pyat-primer" title="Permalink to this headline"></a></h1>
<p>—
title: AT Primer
—
## Introduction</p>
<p>The Accelerator Toolbox (AT) is a toolbox of functions in Matlab for
charged particle beam simulation. It was created by Andrei Terebilo in
the late 1990’s. The original papers still serve as a good introduction
to AT. The AT described in those papers is AT1.3, the latest version
produced by Terebilo. The next version of AT is considered AT2.0. Here
we provide examples showing some of the changes from AT1.3, but also
serving as an introduction for someone just starting AT.</p>
<p>### Coordinates</p>
<p>The 6-d phase space coordinates used in AT are as follows
$$vec Z = pmatrix{xcr frac{p_x}{p_0}=x’(1+delta) cr y cr frac{p_y}{p_0}=y’(1+delta) cr delta=frac{left(p_z-p_0right)}{p_0} cr ctau}$$</p>
<p>$$p_0$$ is the reference momentum. $$tau$$ is the
time lag relative to the ideal particle.</p>
<p>## Creation of Elements and Lattices</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">import</span> <span class="pre">at</span>
<span class="pre">import</span> <span class="pre">at.plot</span>
<span class="pre">import</span> <span class="pre">numpy</span> <span class="pre">as</span> <span class="pre">np</span>
<span class="pre">import</span> <span class="pre">matplotlib.pyplot</span> <span class="pre">as</span> <span class="pre">plt</span>
<span class="pre">from</span> <span class="pre">math</span> <span class="pre">import</span> <span class="pre">pi</span>
<span class="pre">plt.rcParams[&quot;figure.figsize&quot;]</span> <span class="pre">=</span> <span class="pre">(9.0,</span> <span class="pre">6.0)</span>
<span class="pre">`</span></code></p>
<p>A lattice in AT is a object of the <strong>Lattice</strong> class containing the lattice elements. These elements may be created using element creation functions. These functions output objects inheriting from the <strong>Element</strong> base class. For example, a quadrupole may be created with the function <strong>Quadrupole</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">QF=at.Quadrupole('QF',0.5,1.2)</span>
<span class="pre">print(QF)</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><dl class="simple">
<dt>Quadrupole:</dt><dd><p>FamName : QF
Length : 0.5
PassMethod : StrMPoleSymplectic4Pass
NumIntSteps : 10
MaxOrder : 1
PolynomA : [0. 0.]
PolynomB : [0.  1.2]
K : 1.2</p>
</dd>
</dl>
</div></blockquote>
<p>We note that the family name of this quadrupole is ’QF’ and the pass
method is <cite>QuadMPoleFringePass</cite>. The fields following are parameters
necessary to be able to pass an electron through this quadrupole (i.e.,
the set of arguments required by the pass method). We now create some
other elements needed in a FODO lattice:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">Dr</span> <span class="pre">=</span> <span class="pre">at.Drift('Dr',</span> <span class="pre">0.5)</span>
<span class="pre">HalfDr</span> <span class="pre">=</span> <span class="pre">at.Drift('Dr2',</span> <span class="pre">0.25)</span>
<span class="pre">QD</span> <span class="pre">=</span> <span class="pre">at.Quadrupole('QD',</span> <span class="pre">0.5,</span> <span class="pre">-1.2)</span>
<span class="pre">Bend</span> <span class="pre">=</span> <span class="pre">at.Dipole('Bend',</span> <span class="pre">1,</span> <span class="pre">2*pi/40)</span>
<span class="pre">`</span></code></p>
<p>In addition to <strong>Quadrupole</strong> that we already saw, we have created a
drift (region with no magnetic field), using <strong>Drift</strong>. Besides the
family name, the only other needed field is the length. Since we split
the cell in the center of the drift, we have also created a half drift
element. The drifts are 0.5 meters long and the half drift is 0.25
meters long. We have defined a sector dipole, or bend magnet using
<strong>Dipole</strong>. The family name is ’Bend’. The second field is the length
of the magnet and we have given it a length of 1 meter. Next is the
bending angle. We have defined just an arc of a FODO lattice here, so we
don’t have to bend by all of $$2pi$$ here. We choose to have 20 total
such arcs, for a realistic field strength, and thus we define the
bending angle to be $$2pi/40$$ since there are two bends per cell.</p>
<p>A cell of a FODO lattice may now be constructed as follows</p>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a>python
FODOcell = at.Lattice([HalfDr, Bend, Dr, QF, Dr, Bend, Dr, QD, HalfDr],</p>
<blockquote>
<div><p>name=’Simple FODO cell’, energy=1E9)</p>
</div></blockquote>
<p>print(FODOcell)
<a href="#id13"><span class="problematic" id="id14">``</span></a><a href="#id15"><span class="problematic" id="id16">`</span></a></p>
<blockquote>
<div><p>Lattice(&lt;9 elements&gt;, name=’Simple FODO cell’, energy=1000000000.0, periodicity=1)</p>
</div></blockquote>
<p>As mentioned, this cell is only 1/20 of a FODO lattice. The entire
lattice may be created by repeating this cell 20 times as follows</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">FODO</span> <span class="pre">=</span> <span class="pre">FODOcell*20</span>
<span class="pre">print(FODO)</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>Lattice(&lt;180 elements&gt;, name=’Simple FODO cell’, energy=1000000000.0, periodicity=1)</p>
</div></blockquote>
<p>We have now created a valid AT lattice, using drifts, dipoles, and
quadrupoles. We will later add some sextupoles to this lattice, and also
an RF cavity, but one could track particles through this lattice, as is.</p>
<p>For completeness, we list all of the AT element creation functions:
<strong>Aperture</strong>, <strong>Corrector</strong>, <strong>Drift</strong>, <strong>M66</strong>, <strong>Marker</strong>, <strong>Monitor</strong>, <strong>ThinMultipole</strong>, <strong>Multipole</strong>, <strong>Octupole</strong>, <strong>Quadrupole</strong>, <strong>RFcavity</strong>, <strong>Sextupole</strong>, <strong>Wiggler</strong>.</p>
<p>## Lattice Querying and Manipulation</p>
<p>There are many parameters in a storage ring lattice. We need tools to
view these parameters and to change them.</p>
<p>### Selecting elements
We have seen how to concatenate elements to form a lattice. To extract elements, two indexing methods may be used, similar to indexing in numpy arrays:
- Integer array indexing: elements are identified by the array of their indices. For instance, the elements at locations 3 and 7 of <cite>FODOcell</cite> may be selected with:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">list(FODOcell[3,</span> <span class="pre">7])</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>[Quadrupole(‘QF’, 0.5, 1.2), Quadrupole(‘QD’, 0.5, -1.2)]</p>
</div></blockquote>
<ul class="simple">
<li><p>Boolean array indexing; elements are identified by a Boolean array, as long as the Lattice, where selected elements are identified by a True value. The same elements as in the previous example may be selected with:</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">mask=np.zeros(len(FODOcell),</span> <span class="pre">dtype=bool)</span>
<span class="pre">mask[3]</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">mask[7]</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">list(FODOcell[mask])</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>[Quadrupole(‘QF’, 0.5, 1.2), Quadrupole(‘QD’, 0.5, -1.2)]</p>
</div></blockquote>
<p>Many AT function have an input argument, usually named ‘refpts’ using such indexing methods to select the “points of interest” in the function output. Please note that:
- The corresponding locations in the ring are the <strong>entrances</strong> of the selected ring elements,
- as a special case, a value of “len(ring)” (normally out-of-range element) is used to indicate the <strong>exit</strong> of the <strong>last</strong> element (think of it as the entrance of the 2nd turn).</p>
<p>Such indexes can be generated with the <strong>get_cells</strong> function, which returns a boolean index of elements selected by the value of any of their attributes or by an user-supplied check function:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">refqf</span> <span class="pre">=</span> <span class="pre">at.get_cells(FODOcell,</span> <span class="pre">'FamName',</span> <span class="pre">'QF')</span>&#160;&#160; <span class="pre">#</span> <span class="pre">FamName</span> <span class="pre">attribute</span> <span class="pre">==</span> <span class="pre">QF</span>
<span class="pre">print(list(FODOcell[refqf]))</span>
<span class="pre">refqd</span> <span class="pre">=</span> <span class="pre">at.get_cells(FODOcell,</span> <span class="pre">'FamName',</span> <span class="pre">'QD')</span>&#160;&#160; <span class="pre">#</span> <span class="pre">FamName</span> <span class="pre">attribute</span> <span class="pre">==</span> <span class="pre">QD</span>
<span class="pre">print(list(FODOcell[refqd]))</span>
<span class="pre">refbends</span> <span class="pre">=</span> <span class="pre">at.get_cells(FODOcell,</span> <span class="pre">'BendingAngle')</span> <span class="pre">#</span> <span class="pre">Existing</span> <span class="pre">BendingAngle</span> <span class="pre">attribute</span>
<span class="pre">print(list(FODOcell[refbends]))</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>[Quadrupole(‘QF’, 0.5, 1.2)]
[Quadrupole(‘QD’, 0.5, -1.2)]
[Dipole(‘Bend’, 1.0, 0.15707963267948966, 0.0), Dipole(‘Bend’, 1.0, 0.15707963267948966, 0.0)]</p>
</div></blockquote>
<p>Using predefined check functions we can write:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">refq1</span> <span class="pre">=</span> <span class="pre">at.get_cells(FODOcell,</span> <span class="pre">at.checktype(at.Quadrupole))</span>&#160;&#160; <span class="pre">#</span> <span class="pre">class</span> <span class="pre">==</span> <span class="pre">Quadrupole</span>
<span class="pre">print(list(FODOcell[refq1]))</span>
<span class="pre">refq2</span> <span class="pre">=</span> <span class="pre">at.get_cells(FODOcell,</span> <span class="pre">at.checkname('Q[FD]'))</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">name</span> <span class="pre">matches</span> <span class="pre">a</span> <span class="pre">pattern</span>
<span class="pre">print(list(FODOcell[refq2]))</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>[Quadrupole(‘QF’, 0.5, 1.2), Quadrupole(‘QD’, 0.5, -1.2)]
[Quadrupole(‘QF’, 0.5, 1.2), Quadrupole(‘QD’, 0.5, -1.2)]</p>
</div></blockquote>
<p>Both methods select the same elements. Since <strong>get_cells</strong> returns numpy boolean arrays, the same result can also be obtained as:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">print(list(FODOcell[refqf</span> <span class="pre">|</span> <span class="pre">refqd]))</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>[Quadrupole(‘QF’, 0.5, 1.2), Quadrupole(‘QD’, 0.5, -1.2)]</p>
</div></blockquote>
<p>### Iterating over selected elements
The <strong>select</strong> method of the lattice object returns an iterator over the selected elements:</p>
<p><a href="#id17"><span class="problematic" id="id18">``</span></a><a href="#id19"><span class="problematic" id="id20">`</span></a>python
for elem in FODOcell.select(refqf | refqd):</p>
<blockquote>
<div><p>print(elem)</p>
</div></blockquote>
<p><a href="#id21"><span class="problematic" id="id22">``</span></a><a href="#id23"><span class="problematic" id="id24">`</span></a></p>
<blockquote>
<div><dl class="simple">
<dt>Quadrupole:</dt><dd><p>FamName : QF
Length : 0.5
PassMethod : StrMPoleSymplectic4Pass
NumIntSteps : 10
MaxOrder : 1
PolynomA : [0. 0.]
PolynomB : [0.  1.2]
K : 1.2</p>
</dd>
<dt>Quadrupole:</dt><dd><p>FamName : QD
Length : 0.5
PassMethod : StrMPoleSymplectic4Pass
NumIntSteps : 10
MaxOrder : 1
PolynomA : [0. 0.]
PolynomB : [ 0.  -1.2]
K : -1.2</p>
</dd>
</dl>
</div></blockquote>
<p>### Extracting attribute values
Following the previous example, we can get the quadrupole stengths (PolynomB[1]) with:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">np.array([elem.PolynomB[1]</span> <span class="pre">for</span> <span class="pre">elem</span> <span class="pre">in</span> <span class="pre">FODOcell.select(refqf</span> <span class="pre">|</span> <span class="pre">refqd)])</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>array([ 1.2, -1.2])</p>
</div></blockquote>
<p>The same result is provided by the <strong>get_value_refpts</strong> convenience function:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">at.get_value_refpts(FODOcell,</span> <span class="pre">refqf</span> <span class="pre">|</span> <span class="pre">refqd,</span> <span class="pre">'PolynomB',</span> <span class="pre">index=1)</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>array([ 1.2, -1.2])</p>
</div></blockquote>
<p>### Setting attribute values
Similarly, using a the Lattice iterator, we can write:</p>
<p><a href="#id25"><span class="problematic" id="id26">``</span></a><a href="#id27"><span class="problematic" id="id28">`</span></a>python
new_strengths = [1.1, -1.3]
for elem, strength in zip(FODOcell.select(refqf | refqd), new_strengths):</p>
<blockquote>
<div><p>elem.PolynomB[1] = strength</p>
</div></blockquote>
<p># Check the result:
np.array([elem.PolynomB[1] for elem in FODOcell.select(refqf | refqd)])
<a href="#id29"><span class="problematic" id="id30">``</span></a><a href="#id31"><span class="problematic" id="id32">`</span></a></p>
<blockquote>
<div><p>array([ 1.1, -1.3])</p>
</div></blockquote>
<p>Or with the <strong>set_value_refpts</strong> function:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">initial_strengths</span> <span class="pre">=</span> <span class="pre">[1.2,</span> <span class="pre">-1.2]</span>
<span class="pre">at.set_value_refpts(FODOcell,</span> <span class="pre">refqf</span> <span class="pre">|</span> <span class="pre">refqd,</span> <span class="pre">'PolynomB',</span> <span class="pre">initial_strengths,</span> <span class="pre">index=1)</span>
<span class="pre">#</span> <span class="pre">Check</span> <span class="pre">the</span> <span class="pre">result:</span>
<span class="pre">at.get_value_refpts(FODOcell,</span> <span class="pre">refqf</span> <span class="pre">|</span> <span class="pre">refqd,</span> <span class="pre">'PolynomB',</span> <span class="pre">index=1)</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>array([ 1.2, -1.2])</p>
</div></blockquote>
<p>## Tracking</p>
<p>Once a lattice is defined, electrons may be tracked through it.
<strong>lattice_pass</strong> is the function that does the tracking. An example of its
use is as follows:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">nturns=200</span>
<span class="pre">Z01</span> <span class="pre">=</span> <span class="pre">np.array([.001,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span>
<span class="pre">Z02</span> <span class="pre">=</span> <span class="pre">np.array([.002,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span>
<span class="pre">Z03</span> <span class="pre">=</span> <span class="pre">np.array([.003,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span>
<span class="pre">Z1=at.lattice_pass(FODO,Z01,nturns)</span>
<span class="pre">Z2=at.lattice_pass(FODO,Z02,nturns)</span>
<span class="pre">Z3=at.lattice_pass(FODO,Z03,nturns)</span>
<span class="pre">plt.plot(Z1[0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">:],</span> <span class="pre">Z1[1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">:],'.')</span>
<span class="pre">plt.plot(Z2[0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">:],</span> <span class="pre">Z2[1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">:],'.')</span>
<span class="pre">plt.plot(Z3[0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">:],</span> <span class="pre">Z3[1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">:],'.')</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>[&lt;matplotlib.lines.Line2D at 0x12e0514d0&gt;]</p>
</div></blockquote>
<p>![png][figure 1]</p>
<p>In this example, we started with one initial condition, and all subsequent turns are returned by <strong>lattice_pass</strong>. We may also start with multiple initial conditions:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">Z0=np.asfortranarray(np.vstack((Z01,Z02,Z03)).T)</span>
<span class="pre">print('Z0.shape:',</span> <span class="pre">Z0.shape)</span>
<span class="pre">Z=at.lattice_pass(FODO,Z0,nturns)</span>
<span class="pre">print('</span> <span class="pre">Z.shape:',</span> <span class="pre">Z.shape)</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><dl class="simple">
<dt>Z0.shape: (6, 3)</dt><dd><p>Z.shape: (6, 3, 1, 200)</p>
</dd>
</dl>
</div></blockquote>
<p>Now the same plot can be obtained with:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">plt.plot(Z[0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">:],</span> <span class="pre">Z[1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">:],'.')</span>
<span class="pre">plt.plot(Z[0,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">:],</span> <span class="pre">Z[1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">:],'.')</span>
<span class="pre">plt.plot(Z[0,</span> <span class="pre">2,</span> <span class="pre">0,</span> <span class="pre">:],</span> <span class="pre">Z[1,</span> <span class="pre">2,</span> <span class="pre">0,</span> <span class="pre">:],'.')</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>[&lt;matplotlib.lines.Line2D at 0x12e16f150&gt;]</p>
</div></blockquote>
<p>![png][figure 2]</p>
<p>## Computation of beam parameters</p>
<p>Now that particles can be tracked through the lattice, we can use the
tracking to understand different properties of the lattice. First, we
would like to understand the linear properties such as Twiss parameters,
tunes, chromaticities, etc. These can all be calculated with the
function <strong>get_optics</strong>.</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">[_,</span> <span class="pre">beamdata,</span> <span class="pre">_]</span> <span class="pre">=</span> <span class="pre">at.get_optics(FODO,</span> <span class="pre">get_chrom=True)</span>
<span class="pre">`</span></code></p>
<p>The first argument is the FODO lattice we have created. The second argument says we want to compute the optional chromaticity.</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">print(beamdata.tune)</span>
<span class="pre">print(beamdata.chromaticity)</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>[0.21993568 0.91777806]
[-6.3404156  -6.19856968]</p>
</div></blockquote>
<p>which tells us the tunes are $$nu_x = 0.2199$$ and $$nu_y = 0.9178$$ and
the chromaticities are $$xi_x = -6.34$$, $$xi_y = -6.20$$.</p>
<p>How did AT calculate these quantities? Without digging into the details of <strong>get_optics</strong>, you could still figure it out, just based on the ability to track with the <strong>lattice_pass</strong> function. In fact, AT computes the one-turn transfer matrix by tracking several initial conditions and interpolating. The one turn transfer matrix (here we focus on 4x4) is computed with the function <strong>find_m44</strong> contained within <strong>get_optics</strong>. Calling this on the FODO lattice, we find</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">m44,</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">at.find_m44(FODO,0)</span>
<span class="pre">print(m44)</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><dl class="simple">
<dt>[[-0.6518562   1.90977797  0.          0.        ]</dt><dd><p>[-0.87430341  1.02741279  0.          0.        ]
[ 0.          0.         -0.1807342  -3.24829821]
[ 0.          0.          0.41466639  1.91972581]]</p>
</dd>
</dl>
</div></blockquote>
<p>The 0 as the second argument tells us to compute with $$delta=0$$. We
note that the ring is uncoupled, and computing the eigenvalues of
submatrices, we derive the tunes reported in <strong>get_optics</strong> above.</p>
<p>Computing the tunes with varying $$delta$$ allows the computation
of the chromaticity.</p>
<p>Now, suppose we would like to change the tunes in our FODO lattice. We
know that we should change the quadrupole strengths, but we may not know
exactly what values to use.</p>
<p>Here we reach the question of tuning. How do we set the parameters for
these quadrupoles in order to correct the tunes? In principle we have
the tools that we need. We can set the values of the quadrupoles using
the function <strong>set_value_refpts</strong> and then recompute the chromaticity with
<strong>get_optics</strong>. But we still don’t know what values to actually give the
quadrupoles. One could compute the value, or instead use an optimization
routine to vary the values until the correct output tunes are achieved.
This is the approach followed with the function <strong>fit_tune</strong>.</p>
<p>This allows you to vary quadrupole strengths until the desired tune
values are reached. It is used as follows:</p>
<p>First, we need to select two variable quadrupoles. As FODO has been built, the same quadrupole QF is used in each cell, so varying its strength will affect all cells. We just need to select the 1st one in the ring:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">refqf</span> <span class="pre">=</span> <span class="pre">at.get_cells(FODO,</span> <span class="pre">at.checkname('QF'))</span> <span class="pre">#</span> <span class="pre">Select</span> <span class="pre">all</span> <span class="pre">QFs</span>
<span class="pre">refqf1</span> <span class="pre">=</span> <span class="pre">np.flatnonzero(refqf)[0]</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">Get</span> <span class="pre">the</span> <span class="pre">1st</span> <span class="pre">one</span>
<span class="pre">refqd</span> <span class="pre">=</span> <span class="pre">at.get_cells(FODO,</span> <span class="pre">at.checkname('QD'))</span> <span class="pre">#</span> <span class="pre">Select</span> <span class="pre">all</span> <span class="pre">QDs</span>
<span class="pre">refqd1</span> <span class="pre">=</span> <span class="pre">np.flatnonzero(refqd)[0]</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">Get</span> <span class="pre">the</span> <span class="pre">1st</span> <span class="pre">one</span>
<span class="pre">`</span></code></p>
<p>Then we can call the fitting function to set the tunes to $$nu_x = 0.15$$ and $$nu_y = 0.75$$ using the quadrupoles QF and QD.</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">at.fit_tune(FODO,</span> <span class="pre">refqf,</span> <span class="pre">refqd,</span> <span class="pre">[0.15,</span> <span class="pre">0.75])</span>
<span class="pre">`</span></code></p>
<p>Let’s check the result:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">[_,</span> <span class="pre">beamdata,</span> <span class="pre">_]=at.get_optics(FODO)</span>
<span class="pre">beamdata.tune</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>array([0.15000008, 0.75000007])</p>
</div></blockquote>
<p>Giving satisfactory results for the tunes.</p>
<p>Now, in case you have some experience with storage ring dynamics, you
will know that these negative chromaticity values will lead to
instability and thus our FODO lattice, as is, is not acceptable. To fix
this problem, we add sextupoles to our lattice. We define a focusing and
defocussing sextupoles (0.1 meter long) as follows:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">SF</span> <span class="pre">=</span> <span class="pre">at.Sextupole('SF',</span> <span class="pre">0.1,</span> <span class="pre">1)</span>
<span class="pre">SD</span> <span class="pre">=</span> <span class="pre">at.Sextupole('SD',</span> <span class="pre">0.1,</span> <span class="pre">-1)</span>
<span class="pre">drs</span> <span class="pre">=</span> <span class="pre">at.Drift('DRS',</span> <span class="pre">0.2)</span>
<span class="pre">`</span></code></p>
<p>Now we want to add these to the lattice at locations where they will be
effective. We will put them in the middle of the 0.5 meter drift
sections: SF before the QF and SD before the QD. Let’s locate the drifts:</p>
<dl class="simple">
<dt><a href="#id33"><span class="problematic" id="id34">``</span></a><a href="#id35"><span class="problematic" id="id36">`</span></a>python</dt><dd><p>np.nonzero(at.get_cells(FODOcell, at.checkname(“Dr”)))</p>
</dd>
</dl>
<p><a href="#id37"><span class="problematic" id="id38">``</span></a><a href="#id39"><span class="problematic" id="id40">`</span></a></p>
<blockquote>
<div><p>(array([2, 4, 6]),)</p>
</div></blockquote>
<p>We will insert SF in the middle of element 2 and SD in the middle of element 6. Since the Lattice object is derived from the python <cite>list</cite>, we can use all the <cite>list</cite> methods to do this. For instance:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">FODOcellSext</span> <span class="pre">=</span> <span class="pre">FODOcell.copy()</span>
<span class="pre">FODOcellSext[6:7]</span> <span class="pre">=</span> <span class="pre">[drs,SD,drs]</span>
<span class="pre">FODOcellSext[2:3]</span> <span class="pre">=</span> <span class="pre">[drs,SF,drs]</span>
<span class="pre">FODOSext</span> <span class="pre">=</span> <span class="pre">FODOcellSext*20</span>
<span class="pre">print(FODOSext)</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>Lattice(&lt;260 elements&gt;, name=’Simple FODO cell’, energy=1000000000.0, periodicity=1)</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">[_,</span> <span class="pre">beamdata,</span> <span class="pre">_]</span> <span class="pre">=</span> <span class="pre">at.get_optics(FODOSext,</span> <span class="pre">get_chrom=True)</span>
<span class="pre">print(beamdata.tune)</span>
<span class="pre">print(beamdata.chromaticity)</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>[0.15000008 0.75000007]
[-4.74321243 -5.38710732]</p>
</div></blockquote>
<p>The tunes of FODOSext are identical to the ones of FODO. Now we need to tune the sextupoles. For this, we will use the function <strong>fit_chrom</strong>. This function works analogously to <strong>fit_tune</strong> except the sextupoles are varied instead of the quadrupoles. Let’s locate the first sextupoles:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">refsext</span> <span class="pre">=</span> <span class="pre">at.get_cells(FODOSext,</span> <span class="pre">at.checktype(at.Sextupole))</span> <span class="pre">#</span> <span class="pre">Select</span> <span class="pre">all</span> <span class="pre">sextpoles</span>
<span class="pre">refsf,refsd</span> <span class="pre">=</span> <span class="pre">np.flatnonzero(refsext)[:2]</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">Take</span> <span class="pre">the</span> <span class="pre">1st</span> <span class="pre">ones</span>
<span class="pre">`</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">at.fit_chrom(FODOSext,</span> <span class="pre">refsf,</span> <span class="pre">refsd,</span> <span class="pre">[0.5,</span> <span class="pre">0.5])</span>
<span class="pre">`</span></code></p>
<p>After changing the tunes and fixing the chromaticities, we find:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">[_,</span> <span class="pre">beamdata,</span> <span class="pre">_]</span> <span class="pre">=</span> <span class="pre">at.get_optics(FODOSext,</span> <span class="pre">get_chrom=True)</span>
<span class="pre">print(beamdata.tune)</span>
<span class="pre">print(beamdata.chromaticity)</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>[0.15000008 0.75000007]
[0.49999996 0.5       ]</p>
</div></blockquote>
<p>You may have noticed that we ignored two outputs of <strong>get_optics</strong>. They contains linear optics parameters that vary around the ring. These are the Twiss parameters, dispersions, phase advance, and coupling parameters. ;**elemdata0** is their values at the entrance of the ring, <strong>elemdata</strong> is the values at the selected points of interest. To compute them at all lattice elements, we call:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">[elemdata0,</span> <span class="pre">beamdata,</span> <span class="pre">elemdata]</span> <span class="pre">=</span> <span class="pre">at.get_optics(FODOcellSext,</span> <span class="pre">range(len(FODOcellSext)+1))</span>
<span class="pre">`</span></code></p>
<p>Examining <strong>elemdata</strong>, we find:</p>
<p><a href="#id41"><span class="problematic" id="id42">``</span></a><a href="#id43"><span class="problematic" id="id44">`</span></a>python
print(‘elemdata.shape:’, elemdata.shape)
print(‘elemdata.fields:’)
for fld in elemdata.dtype.fields.keys():</p>
<blockquote>
<div><p>print(fld)</p>
</div></blockquote>
<p><a href="#id45"><span class="problematic" id="id46">``</span></a><a href="#id47"><span class="problematic" id="id48">`</span></a></p>
<blockquote>
<div><p>elemdata.shape: (14,)
elemdata.fields:
alpha
beta
mu
R
A
dispersion
closed_orbit
M
s_pos</p>
</div></blockquote>
<ul class="simple">
<li><p>’s_pos’ is the set of $$s$$ positions,</p></li>
<li><p>’closed_orbit’ is the $$x,x’,y,y’$$ coordinate vector of the closed orbit,</p></li>
<li><p>’dispersion’ is the $$eta_x,eta’_x,eta_y,eta’_y$$ coordinate vector of dispersion,</p></li>
<li><p>’M’ is the local $$4times 4$$ transfer matrix,</p></li>
<li><p>’beta’ gives the horizontal and vertical $$beta$$ functions,</p></li>
<li><p>’alpha’ gives the Twiss parameters $$alpha_{x,y}$$,</p></li>
<li><p>’mu’ gives the phase advances (times $$2pi$$).</p></li>
</ul>
<p>Let us use these results to plot the beta functions around the ring.</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">plt.plot(elemdata.s_pos,</span> <span class="pre">elemdata.beta)</span>
<span class="pre">plt.xlabel('s</span> <span class="pre">[m]')</span>
<span class="pre">plt.ylabel(r'$\beta$</span> <span class="pre">[m]')</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>Text(0, 0.5, ‘$\beta$ [m]’)</p>
</div></blockquote>
<p>![png][figure 3]</p>
<p>We may also plot the lattice parameters using a dedicated function
called <strong>atplot</strong> with the command</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">FODOcellSext.plot_beta()</span>
<span class="pre">`</span></code></p>
<p>![png][figure 4]</p>
<blockquote>
<div><dl class="simple">
<dt>(&lt;AxesSubplot:title={‘left’:’Simple FODO cell’,’center’:’Optical functions’}, xlabel=’s [m]’, ylabel=’$\beta$ [m]’&gt;,</dt><dd><p>&lt;AxesSubplot:ylabel=’dispersion [m]’&gt;,
&lt;AxesSubplot:&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>Note that the magnets are displayed below the function, giving a convenient visualization. Also note that the lattice functions are smoother than those we saw before. They have been computed at more positions, by slicing the magnets in the <strong>plot_beta</strong> function.</p>
<p>## Beam sizes</p>
<p>The parameters computed thus far use only the tracking through the
lattice, with no radiation effects. In reality, for electrons, we know
that there are radiation effects which cause a damping and diffusion and
determine equilibrium emittances and beam sizes. This is computed in AT
by the <strong>ohmi_envelope</strong> function using the Ohmi envelope formalism.</p>
<p>In order to use <strong>ohmi_envelope</strong>, we first need to make sure the beam is stable
longitudinally as well, requiring us to add an RF cavity to our FODO
lattice. Let’s add an inactive cavity with the command</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">RFC</span> <span class="pre">=</span> <span class="pre">at.RFCavity('RFC',</span> <span class="pre">0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0,</span> <span class="pre">1,</span> <span class="pre">1.0E9,</span> <span class="pre">PassMethod='IdentityPass')</span>
<span class="pre">FODOSext.insert(0,</span> <span class="pre">RFC)</span>
<span class="pre">`</span></code></p>
<p>Now, we need to set the values of the RF cavity. This can be done with
the function <strong>set_cavity</strong> as follows</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">FODOSext.set_cavity(Voltage=0.5E6,</span> <span class="pre">Frequency=at.Frf.NOMINAL,</span> <span class="pre">HarmNumber=100)</span>
<span class="pre">print(RFC)</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><dl class="simple">
<dt>RFCavity:</dt><dd><p>FamName : RFC
Length : 0.0
PassMethod : IdentityPass
Voltage : 500000.0
Frequency : 299792457.9999997
HarmNumber : 100
Energy : 1000000000.0
TimeLag : 0.0</p>
</dd>
</dl>
</div></blockquote>
<p>which says that the RF cavity has a voltage of 0.5 MV and harmonic number of 100.</p>
<p><strong>radiation_parameters</strong> gives a summary of the lattice properties, using the classical radiation integrals:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">print(at.radiation_parameters(FODOSext))</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>Frac. tunes: [0.15000008 0.75000007 0.01845048]</dt><dd><p>Tunes: [5.15000008 4.75000007]</p>
</dd>
</dl>
</div></blockquote>
<p>Chromaticities: [0.49999996 0.5       ]</p>
</div></blockquote>
<dl>
<dt>Momentum compact. factor: 4.279526e-02</dt><dd><blockquote>
<div><dl class="simple">
<dt>Slip factor: -4.279500e-02</dt><dd><p>Energy: 1.000000e+09 eV</p>
</dd>
</dl>
</div></blockquote>
<p>Energy loss / turn: 1.389569e+04 eV</p>
</dd>
<dt>Radiation integrals - I1: 4.279525789329349 m</dt><dd><blockquote>
<div><p>I2: 0.9869604401089351 m^-1
I3: 0.15503138340149902 m^-2
I4: 0.1055930664123509 m^-1
I5: 0.020912848215876745 m^-1</p>
</div></blockquote>
<p>Mode emittances: [3.48204791e-08            nan            nan]</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>Damping partition numbers: [0.89301186 1.         2.10698814]</dt><dd><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>Damping times: [0.05376155 0.04800971 0.02278594] s
Energy spread: 0.000330764</p>
<blockquote>
<div><p>Bunch length: 0.0122102 m</p>
</div></blockquote>
</div></blockquote>
<p>Cavities voltage: 500000.0 V</p>
</div></blockquote>
<p>Synchrotron phase: 3.1138 rd</p>
</div></blockquote>
<p>Synchrotron frequency; 55313.2 Hz</p>
</dd>
</dl>
</div></blockquote>
<p>We may now turn radiation ON and call the function <strong>ohmi_envelope</strong> as follows</p>
<p><a href="#id49"><span class="problematic" id="id50">``</span></a><a href="#id51"><span class="problematic" id="id52">`</span></a>python
FODOSext.radiation_on()
_, beamdata, _ = at.ohmi_envelope(FODOSext)
print(‘beamdata.fields:’)
for fld in beamdata.dtype.fields.keys():</p>
<blockquote>
<div><p>print(fld)</p>
</div></blockquote>
<p><a href="#id53"><span class="problematic" id="id54">``</span></a><a href="#id55"><span class="problematic" id="id56">`</span></a></p>
<blockquote>
<div><p>beamdata.fields:
tunes
damping_rates
mode_matrices
mode_emittances</p>
</div></blockquote>
<ul class="simple">
<li><p>’tunes’ gives the 3 tunes of the 6D motion;</p></li>
<li><p>’damping_rates’,</p></li>
<li><p>’mode_matrices’ are the sigma matrices of the 3 independent motions</p></li>
<li><p>’mode_emittances’ are the 3 modal emittances.</p></li>
</ul>
<p>An easy way to summarize these results is provided by the <strong>envelope_parameters</strong> function:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">print(at.envelope_parameters(FODOSext))</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><blockquote>
<div><dl>
<dt>Frac. tunes (6D motion): [0.1499589  0.75000123 0.0184657 ]</dt><dd><blockquote>
<div><p>Energy: 1.000000e+09 eV</p>
</div></blockquote>
<dl class="simple">
<dt>Energy loss / turn: 1.389569e+04 eV</dt><dd><p>Mode emittances: [3.47973121e-08 2.23151526e-37 4.03132818e-06]</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>Damping partition numbers: [0.89298384 0.99999995 2.10701621]</dt><dd><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>Damping times: [0.05376455 0.04801088 0.02278619] s
Energy spread: 0.000330959</p>
<blockquote>
<div><p>Bunch length: 0.0122209 m</p>
</div></blockquote>
</div></blockquote>
<p>Cavities voltage: 500000.0 V</p>
</div></blockquote>
<p>Synchrotron phase: 3.1138 rd</p>
</div></blockquote>
<p>Synchrotron frequency; 55358.8 Hz</p>
</dd>
</dl>
</div></blockquote>
<p>We see that our FODO lattice has an emittance of 34.80 nm, an energy
spread of $$3.3times 10^{-4}$$ and a bunch length of 12.2 mm.</p>
<p>## Bibliography
[1](<a class="reference external" href="https://www.slac.stanford.edu/pubs/slacpubs/8500/slac-pub-8732.pdf">https://www.slac.stanford.edu/pubs/slacpubs/8500/slac-pub-8732.pdf</a>) A. Terebilo <em>Accelerator Toolbox for Matlab</em>, SLAC-PUB 8732 (May 2001)</p>
<p>[2](<a class="reference external" href="https://inspirehep.net/files/298dd81ab9ce89bfb2a42442b46b0379">https://inspirehep.net/files/298dd81ab9ce89bfb2a42442b46b0379</a>) A. Terebilo, <em>Accelerator Modelling with Matlab Accelerator Toolbox</em>, PAC 2001 Proceedings</p>
<p>[3](<a class="reference external" href="https://inspirehep.net/files/8507fec63dc914e41a782b13b831c64e">https://inspirehep.net/files/8507fec63dc914e41a782b13b831c64e</a>) B. Nash <em>et al.</em>, <em>New Functionality for Beam Dynamics in Accelerator Toolbox</em>, IPAC 2015</p>
<p>[4](<a class="reference external" href="https://journals.aps.org/prab/pdf/10.1103/PhysRevSTAB.2.074001">https://journals.aps.org/prab/pdf/10.1103/PhysRevSTAB.2.074001</a>) D. Sagan, D. Rubin, <em>Linear Analysis of Coupled Lattices</em>, Phys. Rev. Special Topics - Accelerators
and Beams, Vol 2,(1999)</p>
<p>[figure 1]: {{ “/assets/images/output_33_1.png” | relative_url}}  “Figure 1”</p>
<p>[figure 2]: {{ “/assets/images/output_37_1.png” | relative_url}}  “Figure 2”</p>
<p>[figure 3]: {{ “/assets/images/output_67_1.png” | relative_url}}  “Figure 3”</p>
<p>[figure 4]: {{ “/assets/images/output_69_0.png” | relative_url}}  “Figure 4”</p>
</section>
<section id="cavity-control">
<h1>Cavity Control<a class="headerlink" href="#cavity-control" title="Permalink to this headline"></a></h1>
<p>—
title: Controlling the RF cavities
—
A lattice may contain multiple RF cavities, grouped according to different RF systems:
main cavities, harmonic cavities…AT provides simple tools to tune them, with methods and properties of the
<cite>Lattice</cite> object.</p>
<p>### Lattice methods for cavity control</p>
<p>All methods have <cite>array</cite> and <cite>cavpts</cite> keyword arguments, used to select the cavities concerned by the command.</p>
<ul class="simple">
<li><p>if <cite>array is True</cite>, the output attribute value is an array as long as the number of selected cavities.
The input argument must be an array as long as the number of selected cavities
or a scalar which will be broadcasted to the number of cavities,</p></li>
<li><p>if <cite>array is False</cite> (default), the input and output are scalars. The scalar value</p></li>
</ul>
<p>applies to the set of cavities with the lowest frequency within the selection.
The other cavities are ignored in <cite>get_*</cite> methods. For <cite>set_*</cite> methods, the other
cavities are scaled as explained if the specific method description.</p>
<p>The <cite>cavpts</cite> argument is used as follows:
- <cite>cavpts</cite> is a “refpts” type (integer, integer or boolean array, callable): it is used to select the</p>
<blockquote>
<div><p>cavities.</p>
</div></blockquote>
<ul class="simple">
<li><p><cite>cavpts is None</cite> (default value), and the <cite>Lattice</cite> object has a <cite>cavpts</cite> attribute:
the lattice attribute is used to select the cavities.</p></li>
<li><p><cite>cavpts is None</cite>, and the lattice has no <cite>cavpts</cite> attribute (or it is <cite>None</cite>):
all cavities are taken into account.</p></li>
</ul>
<p>{% include tip.html content=”&lt;br/&gt;
- <strong>single RF system:</strong> you can forget the <cite>cavpts</cite> argument: by default the methods
address all cavities. However, using the <cite>Lattice.cavpts</cite> attribute makes calls significantly
faster by skipping the search for cavities.&lt;br/&gt;
- <strong>complex system:</strong> an easy way is to have the <cite>Lattice.cavpts</cite> address the accelerating
cavities so that they will be driven by default. Harmonic cavities may be driven
using the <cite>cavpts</cite> argument.
” %}</p>
<p>{% include tip.html content=”
Adding to the Lattice &quot;refpts&quot; type attributes addressing the different cavity sets make
them available everywhere the lattice is visible.
” %}</p>
<p>All <cite>set_*</cite> methods also have a <cite>copy</cite> argument to select either in-place modification
of the lattice, or creation of a shallow copy with modified cavities.</p>
<p>#### Voltage:
<code class="docutils literal notranslate"><span class="pre">`voltage</span> <span class="pre">=</span> <span class="pre">Lattice.get_rf_voltage(cavpts=None,</span> <span class="pre">array=False)`</span></code></p>
<p>The scalar voltage is the sum of the cavity voltages of the cavities with the
lowest frequency within the selection, multiplied by the periodicity.</p>
<p><code class="docutils literal notranslate"><span class="pre">`Lattice.set_rf_voltage(voltage,</span> <span class="pre">cavpts=None,</span> <span class="pre">array=False,</span> <span class="pre">copy=False)`</span></code></p>
<p>For array == False, all the existing voltages are scaled to reach the specified
value on the fundamental mode.</p>
<p>#### Frequency:
<cite>frequency = Lattice.get_rf_frequency(cavpts=None, array=False)</cite></p>
<p>The frequency of the fundamental mode is returned.</p>
<p><cite>Lattice.get_rf_frequency(frequency=None, dp=None, dct=None, cavpts=None, array=False, copy=False)</cite></p>
<p>If the frequency is None, the method will set the frequency to the nominal value,
according to the revolution frequency and harmonic number. An optional
off-momentum may be applied using the <cite>dp</cite> or <cite>dct</cite> arguments. The frequency
shift is then computed using the linear slip factor $$eta_c = 1/gamma^2 - alpha_c$$ ,
so that the resulting <cite>dp</cite> may slightly differ from the specified value.</p>
<p>For array == False, the value is applied to the fundamental mode cavities and
the frequency of all other cavities is scaled by the same ratio.</p>
<p>#### Time lag
The time lag is expressed in values of path lengthening “c&amp;tau;”, the 6&lt;sup&gt;th&lt;/sup&gt; particle coordinate [m].</p>
<p><cite>time_lag = Lattice.get_rf_timelag(cavpts=None, array=False)</cite></p>
<p>The time lag of the fundamental mode is returned.</p>
<p><cite>Lattice.set_rf_timelag(time_lag, cavpts=None, array=False, copy=False)</cite></p>
<p>For array == False, the time lag is applied to the fundamental mode cavities and
the time lag of all the other selected cavities is shifted by the same amount.</p>
<p>#### All-in-one method
<a href="#id57"><span class="problematic" id="id58">`</span></a>Lattice.set_cavity(ring, Voltage=None, Frequency=None, TimeLag=None,</p>
<blockquote>
<div><p>cavpts=None, array=False, copy=False)`</p>
</div></blockquote>
<p>This method sets only the explicitly provided values, the other ones are left unchanged.
For the frequency, a special value <cite>at.Frf.NOMINAL</cite> means nominal frequency,
according to the revolution frequency and harmonic number.</p>
<p>The behaviour of the <cite>cavpts</cite> and <cite>array</cite> keywords is the same as for individual methods.</p>
<p>### Lattice properties
The properties provide an even easier way to control the cavities, but are restricted
to the default behaviour of the equivalent Lattice method:
- cavities are selected by the <cite>Lattice.cavpts</cite> attribute (all cavities by default),
- Setting a property modifies the ring in-place (no copy).</p>
<p><cite>Lattice.rf_voltage</cite></p>
<p><cite>Lattice.rf_frequency</cite></p>
<p>The special value <cite>at.Frf.NOMINAL</cite> means nominal frequency.</p>
<p><cite>Lattice.harmonic_number</cite></p>
<p><cite>Lattice.time_lag</cite></p>
</section>
<section id="collective-effects">
<h1>Collective effects<a class="headerlink" href="#collective-effects" title="Permalink to this headline"></a></h1>
<p>—
title: Collective Effects
—</p>
<p>A collective effects element can be added to any lattice to model impedance driven collective effects and perform multi-particle tracking</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="examples_link.html" class="btn btn-neutral float-left" title="pyAT Examples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="at.acceptance.html" class="btn btn-neutral float-right" title="at.acceptance package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, ATCollab.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>