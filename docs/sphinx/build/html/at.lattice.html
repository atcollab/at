<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>at.lattice package &mdash; pyAT 0.2 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> pyAT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Modules:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="at.acceptance.html">at.acceptance package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pyAT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>at.lattice package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/at.lattice.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="at-lattice-package">
<h1>at.lattice package<a class="headerlink" href="#at-lattice-package" title="Permalink to this headline"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline"></a></h2>
</section>
<section id="module-at.lattice.cavity_access">
<span id="at-lattice-cavity-access-module"></span><h2>at.lattice.cavity_access module<a class="headerlink" href="#module-at.lattice.cavity_access" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.cavity_access.Frf">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.cavity_access.</span></span><span class="sig-name descname"><span class="pre">Frf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.cavity_access.Frf" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>Enum class for frequency setting</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.cavity_access.Frf.NOMINAL">
<span class="sig-name descname"><span class="pre">NOMINAL</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'nominal'</span></em><a class="headerlink" href="#at.lattice.cavity_access.Frf.NOMINAL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.cavity_access.get_rf_frequency">
<span class="sig-prename descclassname"><span class="pre">at.lattice.cavity_access.</span></span><span class="sig-name descname"><span class="pre">get_rf_frequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.cavity_access.get_rf_frequency" title="Permalink to this definition"></a></dt>
<dd><p>Return the RF frequency
KEYWORDS</p>
<blockquote>
<div><dl class="simple">
<dt>cavpts=None   Cavity location.</dt><dd><p>If None, look for ring.cavpts, or otherwise take all
cavities.</p>
</dd>
<dt>array=False   If False, return the frequency of the selected cavities</dt><dd><p>with the lowest frequency.
If True, return the frequency of all selected cavities</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.cavity_access.get_rf_timelag">
<span class="sig-prename descclassname"><span class="pre">at.lattice.cavity_access.</span></span><span class="sig-name descname"><span class="pre">get_rf_timelag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.cavity_access.get_rf_timelag" title="Permalink to this definition"></a></dt>
<dd><p>Return the RF time lag
KEYWORDS</p>
<blockquote>
<div><dl class="simple">
<dt>cavpts=None   Cavity location.</dt><dd><p>If None, look for ring.cavpts, or otherwise take all
cavities.</p>
</dd>
<dt>array=False   If False, return the time lag of the cavities with the</dt><dd><p>lowest frequency.
If True, return the time lag of all the selected
cavities.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.cavity_access.get_rf_voltage">
<span class="sig-prename descclassname"><span class="pre">at.lattice.cavity_access.</span></span><span class="sig-name descname"><span class="pre">get_rf_voltage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.cavity_access.get_rf_voltage" title="Permalink to this definition"></a></dt>
<dd><p>Return the total RF voltage (full ring)
KEYWORDS</p>
<blockquote>
<div><dl class="simple">
<dt>cavpts=None   Cavity location.</dt><dd><p>If None, look for ring.cavpts, or otherwise take all
cavities.</p>
</dd>
<dt>array=False   If False, return the sum of the voltage of the selected</dt><dd><p>cavities with the lowest frequency.
If True, return the voltage of all the selected cavities.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.cavity_access.set_cavity">
<span class="sig-prename descclassname"><span class="pre">at.lattice.cavity_access.</span></span><span class="sig-name descname"><span class="pre">set_cavity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Voltage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">TimeLag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cavpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.cavity_access.set_cavity" title="Permalink to this definition"></a></dt>
<dd><p>Set the parameters of the RF cavities</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring                lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><p>Frequency=None  RF frequency [Hz]
Voltage=None    RF voltage [V]
TimeLag=None    RF time shift [-ct]
cavpts=None     Cavity location. If None, look for ring.cavpts, or</p>
<blockquote>
<div><p>otherwise take all cavities</p>
</div></blockquote>
<dl class="simple">
<dt>array=False     If False, the value is applied as described for</dt><dd><p>set_rf_voltage, set_rf_timelag and set_rf_frequency
If True, directly apply the value to the selected
cavities. The value must be broadcastable to the number
of cavities.</p>
</dd>
<dt>copy=False      If True, returns a shallow copy of ring with new</dt><dd><p>cavity elements. Otherwise, modify ring in-place</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.cavity_access.set_rf_timelag">
<span class="sig-prename descclassname"><span class="pre">at.lattice.cavity_access.</span></span><span class="sig-name descname"><span class="pre">set_rf_timelag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timelag</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.cavity_access.set_rf_timelag" title="Permalink to this definition"></a></dt>
<dd><p>Set the RF time lag</p>
<dl class="simple">
<dt>PARAMETERS</dt><dd><p>ring            lattice description
timelag         RF time shift (-ct) [m]</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>cavpts=None     If None, look for ring.cavpts, or otherwise take all</dt><dd><p>cavities.</p>
</dd>
<dt>array=False     If False, timelag is applied to the selected cavities</dt><dd><p>with the lowest frequency. The timelag of all the
other selected cavities is shifted by the same amount.
If True, directly apply timelag to the selected
cavities. The value must be broadcastable to the number
of cavities.</p>
</dd>
<dt>copy=False      If True, returns a shallow copy of ring with new</dt><dd><p>cavity elements. Otherwise, modify ring in-place</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.cavity_access.set_rf_voltage">
<span class="sig-prename descclassname"><span class="pre">at.lattice.cavity_access.</span></span><span class="sig-name descname"><span class="pre">set_rf_voltage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voltage</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.cavity_access.set_rf_voltage" title="Permalink to this definition"></a></dt>
<dd><p>Set the RF voltage for the full ring</p>
<dl class="simple">
<dt>PARAMETERS</dt><dd><p>ring            lattice description
voltage         RF voltage [V]</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>cavpts=None     If None, look for ring.cavpts, or otherwise take all</dt><dd><p>cavities.</p>
</dd>
<dt>array=False     If False, the voltages of all cavities are scaled to</dt><dd><p>reach the specified value on the selected cavities with
the lowest frequency.
If True, directly apply voltage to the selected
cavities. The value must be broadcastable to the number
of cavities.</p>
</dd>
<dt>copy=False      If True, returns a shallow copy of ring with new</dt><dd><p>cavity elements. Otherwise, modify ring in-place</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-at.lattice.elements">
<span id="at-lattice-elements-module"></span><h2>at.lattice.elements module<a class="headerlink" href="#module-at.lattice.elements" title="Permalink to this headline"></a></h2>
<p>Module to define common elements used in AT.</p>
<p>Each element has a default PassMethod attribute for which it should have the
appropriate attributes.  If a different PassMethod is set, it is the caller’s
responsibility to ensure that the appropriate attributes are present.</p>
<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.Aperture">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">Aperture</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limits</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Aperture" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.Element" title="at.lattice.elements.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.Element</span></code></a></p>
<p>pyAT aperture element</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Aperture.REQUIRED_ATTRIBUTES">
<span class="sig-name descname"><span class="pre">REQUIRED_ATTRIBUTES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['FamName',</span> <span class="pre">'Limits']</span></em><a class="headerlink" href="#at.lattice.elements.Aperture.REQUIRED_ATTRIBUTES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Bend">
<span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">Bend</span></span><a class="headerlink" href="#at.lattice.elements.Bend" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#at.lattice.elements.Dipole" title="at.lattice.elements.Dipole"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.Dipole</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.Collimator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">Collimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limits</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Collimator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.Drift" title="at.lattice.elements.Drift"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.Drift</span></code></a></p>
<p>pyAT collimator element</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Collimator.REQUIRED_ATTRIBUTES">
<span class="sig-name descname"><span class="pre">REQUIRED_ATTRIBUTES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['FamName',</span> <span class="pre">'Length',</span> <span class="pre">'RApertures']</span></em><a class="headerlink" href="#at.lattice.elements.Collimator.REQUIRED_ATTRIBUTES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.Corrector">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">Corrector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kick_angle</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Corrector" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.LongElement" title="at.lattice.elements.LongElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.LongElement</span></code></a></p>
<p>pyAT corrector element</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Corrector.REQUIRED_ATTRIBUTES">
<span class="sig-name descname"><span class="pre">REQUIRED_ATTRIBUTES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['FamName',</span> <span class="pre">'Length',</span> <span class="pre">'KickAngle']</span></em><a class="headerlink" href="#at.lattice.elements.Corrector.REQUIRED_ATTRIBUTES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.Dipole">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">Dipole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bending_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Dipole" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.Multipole" title="at.lattice.elements.Multipole"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.Multipole</span></code></a></p>
<p>pyAT dipole element</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Dipole.DefaultOrder">
<span class="sig-name descname"><span class="pre">DefaultOrder</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#at.lattice.elements.Dipole.DefaultOrder" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.elements.Dipole.K">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">K</span></span><a class="headerlink" href="#at.lattice.elements.Dipole.K" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Dipole.REQUIRED_ATTRIBUTES">
<span class="sig-name descname"><span class="pre">REQUIRED_ATTRIBUTES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['FamName',</span> <span class="pre">'Length',</span> <span class="pre">'BendingAngle',</span> <span class="pre">'K']</span></em><a class="headerlink" href="#at.lattice.elements.Dipole.REQUIRED_ATTRIBUTES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.Drift">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">Drift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Drift" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.LongElement" title="at.lattice.elements.LongElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.LongElement</span></code></a></p>
<p>pyAT drift space element</p>
<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.elements.Drift.insert">
<span class="sig-name descname"><span class="pre">insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">insert_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Drift.insert" title="Permalink to this definition"></a></dt>
<dd><p>insert elements inside a drift</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>insert_list</strong> – <p>iterable, each item of insert_list is itself an
iterable with 2 objects:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>the location where the center of the element
will be inserted, given as a fraction of the
Drift length.</p></li>
<li><p>an element to be inserted at that location. If
None, the drift will be divided but no element
will be inserted.</p></li>
</ol>
</div></blockquote>
</p>
</dd>
</dl>
<p>Return a list of elements.</p>
<p>Drifts with negative lengths may be generated if necessary.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Drift</span><span class="p">(</span><span class="s1">&#39;dr&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">insert</span><span class="p">(((</span><span class="mf">0.25</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="kc">None</span><span class="p">)))</span>
<span class="go">[Drift(&#39;dr&#39;, 0.5), Drift(&#39;dr&#39;, 1.0), Drift(&#39;dr&#39;, 0.5)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Drift</span><span class="p">(</span><span class="s1">&#39;dr&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">insert</span><span class="p">(((</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">Marker</span><span class="p">(</span><span class="s1">&#39;m1&#39;</span><span class="p">)),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">Marker</span><span class="p">(</span><span class="s1">&#39;m2&#39;</span><span class="p">))))</span>
<span class="go">[Marker(&#39;m1&#39;), Drift(&#39;dr&#39;, 1.0), Marker(&#39;m2&#39;), Drift(&#39;dr&#39;, 1.0)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Drift</span><span class="p">(</span><span class="s1">&#39;dr&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">insert</span><span class="p">(((</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">Quadrupole</span><span class="p">(</span><span class="s1">&#39;qp&#39;</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)),))</span>
<span class="go">[Drift(&#39;dr&#39;, 0.8), Quadrupole(&#39;qp&#39;, 0.4), Drift(&#39;dr&#39;, 0.8)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.Element">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">Element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Element" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base of pyat elements</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Element.REQUIRED_ATTRIBUTES">
<span class="sig-name descname"><span class="pre">REQUIRED_ATTRIBUTES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['FamName']</span></em><a class="headerlink" href="#at.lattice.elements.Element.REQUIRED_ATTRIBUTES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.elements.Element.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Element.copy" title="Permalink to this definition"></a></dt>
<dd><p>Return a shallow copy of the element</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.elements.Element.deepcopy">
<span class="sig-name descname"><span class="pre">deepcopy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Element.deepcopy" title="Permalink to this definition"></a></dt>
<dd><p>Return a deep copy of the element</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.elements.Element.divide">
<span class="sig-name descname"><span class="pre">divide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frac</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Element.divide" title="Permalink to this definition"></a></dt>
<dd><p>split the element in len(frac) pieces whose length
is frac[i]*self.Length</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>the</strong> (<em>frac            length of each slice expressed as a fraction of</em>) – initial length. sum(frac) may differ from 1.</p>
</dd>
</dl>
<p>Return a list of elements equivalent to the original.</p>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Drift</span><span class="p">(</span><span class="s1">&#39;dr&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">divide</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="go">[Drift(&#39;dr&#39;, 0.1), Drift(&#39;dr&#39;, 0.3), Drift(&#39;dr&#39;, 0.1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.elements.Element.equals">
<span class="sig-name descname"><span class="pre">equals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Element.equals" title="Permalink to this definition"></a></dt>
<dd><p>Whether an element is equivalent to another.</p>
<p>This implementation was found to be too slow for the generic
__eq__ method when comparing lattices.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.elements.Element.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Element.items" title="Permalink to this definition"></a></dt>
<dd><p>Iterates through the data members including slots and properties</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.elements.Element.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Element.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the element attributes with the given arguments</p>
<p>update(<a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs)
update(mapping, <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs)
update(iterable, <a href="#id5"><span class="problematic" id="id6">**</span></a>kwargs)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.LongElement">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">LongElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.LongElement" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.Element" title="at.lattice.elements.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.Element</span></code></a></p>
<p>pyAT long element</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.LongElement.REQUIRED_ATTRIBUTES">
<span class="sig-name descname"><span class="pre">REQUIRED_ATTRIBUTES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['FamName',</span> <span class="pre">'Length']</span></em><a class="headerlink" href="#at.lattice.elements.LongElement.REQUIRED_ATTRIBUTES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.elements.LongElement.divide">
<span class="sig-name descname"><span class="pre">divide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frac</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.LongElement.divide" title="Permalink to this definition"></a></dt>
<dd><p>split the element in len(frac) pieces whose length
is frac[i]*self.Length</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>the</strong> (<em>frac            length of each slice expressed as a fraction of</em>) – initial length. sum(frac) may differ from 1.</p>
</dd>
</dl>
<p>Return a list of elements equivalent to the original.</p>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Drift</span><span class="p">(</span><span class="s1">&#39;dr&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">divide</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="go">[Drift(&#39;dr&#39;, 0.1), Drift(&#39;dr&#39;, 0.3), Drift(&#39;dr&#39;, 0.1)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.M66">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">M66</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m66</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.M66" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.Element" title="at.lattice.elements.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.Element</span></code></a></p>
<p>Linear (6, 6) transfer matrix</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.M66.REQUIRED_ATTRIBUTES">
<span class="sig-name descname"><span class="pre">REQUIRED_ATTRIBUTES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['FamName']</span></em><a class="headerlink" href="#at.lattice.elements.M66.REQUIRED_ATTRIBUTES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.Marker">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">Marker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Marker" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.Element" title="at.lattice.elements.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.Element</span></code></a></p>
<p>pyAT marker element</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.Monitor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">Monitor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Monitor" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.Element" title="at.lattice.elements.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.Element</span></code></a></p>
<p>pyAT monitor element</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.Multipole">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">Multipole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_b</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Multipole" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.LongElement" title="at.lattice.elements.LongElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.LongElement</span></code></a>, <a class="reference internal" href="#at.lattice.elements.ThinMultipole" title="at.lattice.elements.ThinMultipole"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.ThinMultipole</span></code></a></p>
<p>pyAT multipole element</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Multipole.REQUIRED_ATTRIBUTES">
<span class="sig-name descname"><span class="pre">REQUIRED_ATTRIBUTES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['FamName',</span> <span class="pre">'Length',</span> <span class="pre">'PolynomA',</span> <span class="pre">'PolynomB']</span></em><a class="headerlink" href="#at.lattice.elements.Multipole.REQUIRED_ATTRIBUTES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.Octupole">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">Octupole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_b</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Octupole" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.Multipole" title="at.lattice.elements.Multipole"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.Multipole</span></code></a></p>
<p>pyAT octupole element, with no changes from multipole at present</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Octupole.DefaultOrder">
<span class="sig-name descname"><span class="pre">DefaultOrder</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#at.lattice.elements.Octupole.DefaultOrder" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Octupole.REQUIRED_ATTRIBUTES">
<span class="sig-name descname"><span class="pre">REQUIRED_ATTRIBUTES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['FamName',</span> <span class="pre">'Length',</span> <span class="pre">'PolynomA',</span> <span class="pre">'PolynomB']</span></em><a class="headerlink" href="#at.lattice.elements.Octupole.REQUIRED_ATTRIBUTES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.Quadrupole">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">Quadrupole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Quadrupole" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.Multipole" title="at.lattice.elements.Multipole"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.Multipole</span></code></a></p>
<p>pyAT quadrupole element</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Quadrupole.DefaultOrder">
<span class="sig-name descname"><span class="pre">DefaultOrder</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#at.lattice.elements.Quadrupole.DefaultOrder" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.elements.Quadrupole.K">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">K</span></span><a class="headerlink" href="#at.lattice.elements.Quadrupole.K" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Quadrupole.REQUIRED_ATTRIBUTES">
<span class="sig-name descname"><span class="pre">REQUIRED_ATTRIBUTES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['FamName',</span> <span class="pre">'Length',</span> <span class="pre">'K']</span></em><a class="headerlink" href="#at.lattice.elements.Quadrupole.REQUIRED_ATTRIBUTES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.RFCavity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">RFCavity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voltage</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">harmonic_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">energy</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.RFCavity" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.LongElement" title="at.lattice.elements.LongElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.LongElement</span></code></a></p>
<p>pyAT RF cavity element</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.RFCavity.REQUIRED_ATTRIBUTES">
<span class="sig-name descname"><span class="pre">REQUIRED_ATTRIBUTES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['FamName',</span> <span class="pre">'Length',</span> <span class="pre">'Voltage',</span> <span class="pre">'Frequency',</span> <span class="pre">'HarmNumber',</span> <span class="pre">'Energy']</span></em><a class="headerlink" href="#at.lattice.elements.RFCavity.REQUIRED_ATTRIBUTES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.Sextupole">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">Sextupole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Sextupole" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.Multipole" title="at.lattice.elements.Multipole"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.Multipole</span></code></a></p>
<p>pyAT sextupole element</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Sextupole.DefaultOrder">
<span class="sig-name descname"><span class="pre">DefaultOrder</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#at.lattice.elements.Sextupole.DefaultOrder" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.elements.Sextupole.H">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">H</span></span><a class="headerlink" href="#at.lattice.elements.Sextupole.H" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Sextupole.REQUIRED_ATTRIBUTES">
<span class="sig-name descname"><span class="pre">REQUIRED_ATTRIBUTES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['FamName',</span> <span class="pre">'Length',</span> <span class="pre">'H']</span></em><a class="headerlink" href="#at.lattice.elements.Sextupole.REQUIRED_ATTRIBUTES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.ThinMultipole">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">ThinMultipole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_b</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.ThinMultipole" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.Element" title="at.lattice.elements.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.Element</span></code></a></p>
<p>pyAT thin multipole element</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.ThinMultipole.REQUIRED_ATTRIBUTES">
<span class="sig-name descname"><span class="pre">REQUIRED_ATTRIBUTES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['FamName',</span> <span class="pre">'PolynomA',</span> <span class="pre">'PolynomB']</span></em><a class="headerlink" href="#at.lattice.elements.ThinMultipole.REQUIRED_ATTRIBUTES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.elements.Wiggler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.elements.</span></span><span class="sig-name descname"><span class="pre">Wiggler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wiggle_period</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nstep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nmeth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">By</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Bx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.elements.Wiggler" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#at.lattice.elements.LongElement" title="at.lattice.elements.LongElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.lattice.elements.LongElement</span></code></a></p>
<p>pyAT wiggler element</p>
<p>See atwiggler.m</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.elements.Wiggler.REQUIRED_ATTRIBUTES">
<span class="sig-name descname"><span class="pre">REQUIRED_ATTRIBUTES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['FamName',</span> <span class="pre">'Length',</span> <span class="pre">'Lw',</span> <span class="pre">'Bmax',</span> <span class="pre">'Energy']</span></em><a class="headerlink" href="#at.lattice.elements.Wiggler.REQUIRED_ATTRIBUTES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-at.lattice.lattice_object">
<span id="at-lattice-lattice-object-module"></span><h2>at.lattice.lattice_object module<a class="headerlink" href="#module-at.lattice.lattice_object" title="Permalink to this headline"></a></h2>
<p>Lattice object</p>
<p>The methods implemented in this module are internal to the ‘lattice’ package.
This is necessary to ensure that the ‘lattice’ package is independent of other
AT packages.</p>
<p>Other Lattice methods are implemented in other AT packages and are available
as soon as the package is imported. The ‘tracking’ and ‘physics’ packages are
automatically imported.</p>
<p>As an example, see the at.physics.orbit module</p>
<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.lattice_object.</span></span><span class="sig-name descname"><span class="pre">Lattice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></p>
<p>Lattice object
An AT lattice is a sequence of AT elements.
A Lattice accepts extended indexing (as a numpy ndarray).</p>
<dl class="simple">
<dt>Lattice attributes;</dt><dd><p>name            Name of the lattice
energy          Particle energy
periodicity     Number of super-periods to describe the full ring
particle        Circulating particle
harmonic_number Harmonic number of the full ring (periodicity x cells)</p>
</dd>
</dl>
<p>Lattice(elems, <a href="#id7"><span class="problematic" id="id8">**</span></a>params)        Create a new lattice object</p>
<blockquote>
<div><dl>
<dt>INPUT</dt><dd><p>elems:                  any iterable of AT elements</p>
</dd>
<dt>KEYWORDS</dt><dd><p>name=’’                 Name of the lattice
energy                  Energy of the lattice
periodicity=1           Number of periods
particle=’relativistic’ Circulating particle. May be</p>
<blockquote>
<div><p>‘relativistic’, ‘electron’,
‘positron’, ‘proton’
or a Particle object</p>
</div></blockquote>
<p>iterator=None           Custom iterator (see below)
*                       All other keywords will be set as</p>
<blockquote>
<div><p>attributes of the Lattice object</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>To reduce the inter-package dependencies, some methods of the
lattice object are defined in other AT packages, in the module where
the underlying function is implemented.</p>
<p>Custom iterators:
Instead of running through ‘elems’, the Lattice constructor can use one
or several custom iterators.</p>
<p>Lattice(<a href="#id9"><span class="problematic" id="id10">*</span></a>args, iterator=it, <a href="#id11"><span class="problematic" id="id12">**</span></a>params)</p>
<blockquote>
<div><dl>
<dt>The iterator “it” is called as “it(params, <a href="#id13"><span class="problematic" id="id14">*</span></a>args)” and must return an</dt><dd><p>iterator over AT elements for building the lattice. It must also
fill the “params” dictionary used to set the Lattice attributes.</p>
<dl class="simple">
<dt>params is the dictionary of lattice parameters. It is initialised</dt><dd><p>with the keywords of the lattice constructor. The custom
iterator may add, remove or mofify parameters.
Finally, the remaining parameters will be set as Lattice
attributes.</p>
</dd>
<dt><a href="#id15"><span class="problematic" id="id16">*</span></a>args  all positional arguments of the Lattice constructor are sent</dt><dd><p>to the custom iterator.</p>
</dd>
</dl>
</dd>
<dt>An iterator can be:</dt><dd><ul class="simple">
<li><p>a “generator” which yields elements from scratch.
Examples: a list, or a file iterator,</p></li>
<li><p>a “filter” which runs through an input iterator, processes each
element, possibly adds parameters to the params dictionary
and yields the processed elements.</p></li>
</ul>
</dd>
</dl>
<p>Example of chaining iterators (taken from “load_mat”):</p>
<dl class="simple">
<dt>Lattice(ringparam_filter, matfile_generator, filename</dt><dd><p>iterator=params_filter, <a href="#id17"><span class="problematic" id="id18">**</span></a>params)</p>
</dd>
<dt>matfile_generator(params, filename)</dt><dd><p>opens filename and generates AT elements for each cell of the
Matlab cell array representing the lattice,</p>
</dd>
<dt>ringparam_filter(params, matfile_generator, <a href="#id19"><span class="problematic" id="id20">*</span></a>args)</dt><dd><p>runs through matfile_generator(params, <a href="#id21"><span class="problematic" id="id22">*</span></a>args), looks for RingParam
elements, fills params with their information and discards them,</p>
</dd>
<dt>params_filter(params, ringparam_filter, <a href="#id23"><span class="problematic" id="id24">*</span></a>args)</dt><dd><p>runs through ringparam_filter(params, <a href="#id25"><span class="problematic" id="id26">*</span></a>args), looks for energy and
periodicity if not yet defined.</p>
</dd>
</dl>
</div></blockquote>
<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.BRho">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BRho</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.BRho" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.append" title="Permalink to this definition"></a></dt>
<dd><p>Append object to the end of the list.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.attrs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">attrs</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.attrs" title="Permalink to this definition"></a></dt>
<dd><p>Dictionary of lattice attributes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.attrs_filter">
<span class="sig-name descname"><span class="pre">attrs_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elem_iterator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.attrs_filter" title="Permalink to this definition"></a></dt>
<dd><p>Filter function which duplicates the lattice attributes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.avlinopt">
<span class="sig-name descname"><span class="pre">avlinopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.avlinopt" title="Permalink to this definition"></a></dt>
<dd><p>Perform linear analysis of a lattice and returns average
beta, dispersion and phase advance</p>
<p>lindata,avebeta,avemu,avedisp,tune,chrom = avlinopt(lattice, dp, refpts)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
dp=0.0          momentum deviation.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-8   momentum deviation used for computation of</p>
<blockquote>
<div><p>chromaticities and dispersion</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>lindata         linear optics at the points refered to by refpts, if</dt><dd><p>refpts is None an empty lindata structure is returned.
See linopt4 for details</p>
</dd>
</dl>
<p>avebeta         Average beta functions [betax,betay] at refpts
avemu           Average phase advances [mux,muy] at refpts
avedisp         Average dispersion [Dx,Dx’,Dy,Dy’] at refpts
avespos         Average s position at refpts
tune            [tune_A, tune_B], linear tunes for the two normal modes</p>
<blockquote>
<div><p>of linear motion [1]</p>
</div></blockquote>
<p>chrom           [ksi_A , ksi_B], chromaticities ksi = d(nu)/(dP/P).</p>
</dd>
</dl>
<p>See also linopt4, get_optics</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.beta">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">beta</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.beta" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.bool_refpts">
<span class="sig-name descname"><span class="pre">bool_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.bool_refpts" title="Permalink to this definition"></a></dt>
<dd><p>Return a boolean numpy array of length n_elements
+ 1 where True elements are selected. refpts may be:</p>
<ol class="arabic simple">
<li><p>a integer or a sequence of integers (0 indicating the first element)</p></li>
<li><p>a sequence of booleans marking the selected elements</p></li>
<li><p>a callable f such that f(elem) is True for selected elements</p></li>
</ol>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.circumference">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">circumference</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.circumference" title="Permalink to this definition"></a></dt>
<dd><p>Ring circumference (full ring) [m]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.copy" title="Permalink to this definition"></a></dt>
<dd><p>Return a shallow copy of the lattice</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.deepcopy">
<span class="sig-name descname"><span class="pre">deepcopy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.deepcopy" title="Permalink to this definition"></a></dt>
<dd><p>Return a deep copy</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.energy">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">energy</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.energy" title="Permalink to this definition"></a></dt>
<dd><p>Lattice energy</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.energy_loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">energy_loss</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.energy_loss" title="Permalink to this definition"></a></dt>
<dd><p>Compute the energy loss per turn [eV]</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring                        lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><dl>
<dt>method=ELossMethod.INTEGRAL method for energy loss computation</dt><dd><p>The enum class ELossMethod declares 2 values
INTEGRAL: The losses are obtained from</p>
<blockquote>
<div><p>Losses = Cgamma / 2pi * EGeV^4 * i2
Takes into account bending magnets and wigglers.</p>
</div></blockquote>
<dl class="simple">
<dt>TRACKING: The losses are obtained by tracking without cavities.</dt><dd><p>Needs radiation ON, takes into account all radiating elements.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.envelope_parameters">
<span class="sig-name descname"><span class="pre">envelope_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.envelope_parameters" title="Permalink to this definition"></a></dt>
<dd><p>Compute ring parameters from ohmi_envelope</p>
<dl>
<dt>INPUT</dt><dd><p>ring            Lattice object.</p>
</dd>
<dt>KEYWORD</dt><dd><p>params=None     RingParam object to be updated.</p>
</dd>
<dt>OUTPUT</dt><dd><p>params          RingParam object. The computed attributes are,</p>
<blockquote>
<div><p>tunes6          (3,) fractional (H, V, Long.) tunes (6D motion)
emittances      (3,) Mode emittances
J               (3,) Damping partition numbers
Tau             (3,) Damping times [s]
sigma_e         Energy spread
sigma_l         Bunch length [m]
voltage         Total accelerating voltage [V]
phi_s           Synchrotron phase [rad]
f_s             Synchrotron frequency [Hz]</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elems</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.extend" title="Permalink to this definition"></a></dt>
<dd><p>Extend list by appending elements from the iterable.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.find_m44">
<span class="sig-name descname"><span class="pre">find_m44</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.find_m44" title="Permalink to this definition"></a></dt>
<dd><p>find_m44 numerically finds the 4x4 transfer matrix of an accelerator
lattice for a particle with relative momentum deviation DP</p>
<p>IMPORTANT!!! find_m44 assumes constant momentum deviation.
PassMethod used for any element in the lattice SHOULD NOT
1.  change the longitudinal momentum dP</p>
<blockquote>
<div><p>(cavities , magnets with radiation, …)</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>have any time dependence (localized impedance, fast kickers, …)</p></li>
</ol>
<dl>
<dt>m44, t = find_m44(lattice, dp=0.0, refpts)</dt><dd><p>return 4x4 transfer matrices between the entrance of the first element
and each element indexed by refpts.</p>
<blockquote>
<div><p>m44:    full one-turn matrix at the entrance of the first element
t:      4x4 transfer matrices between the entrance of the first</p>
<blockquote>
<div><p>element and each element indexed by refpts:
(Nrefs, 4, 4) array</p>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
<p>Unless an input orbit is introduced, find_m44 assumes that the lattice is
a ring and first finds the closed orbit.</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description
dp              momentum deviation. Defaults to 0
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for mstack.</p>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>dct=None        path lengthening. If specified, dp is ignored and</dt><dd><p>the off-momentum is deduced from the path lengthening.</p>
</dd>
<dt>orbit=None      avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>keep_lattice=False  When True, assume no lattice change since the</dt><dd><p>previous tracking.</p>
</dd>
<dt>full=False      When True, matrices are full 1-turn matrices at</dt><dd><p>the entrance of each
element indexed by refpts.</p>
</dd>
<dt>orbit=None      Avoids looking for the closed orbit if is already</dt><dd><p>known (6,) array</p>
</dd>
</dl>
<p>XYStep=1.e-8    transverse step for numerical computation</p>
</dd>
</dl>
<p>See also find_m66, find_orbit4</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.find_m66">
<span class="sig-name descname"><span class="pre">find_m66</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.find_m66" title="Permalink to this definition"></a></dt>
<dd><p>find_m66 numerically finds the 6x6 transfer matrix of an accelerator
lattice by differentiation of lattice_pass near the closed orbit.
find_m66 uses find_orbit6 to search for the closed orbit in 6-D
In order for this to work the ring MUST have a CAVITY element</p>
<dl>
<dt>m66, t = find_m66(lattice, refpts)</dt><dd><dl class="simple">
<dt>m66:    full one-turn 6-by-6 matrix at the entrance of the</dt><dd><p>first element.</p>
</dd>
<dt>t:      6x6 transfer matrices between the entrance of the first</dt><dd><p>element and each element indexed by refpts (nrefs, 6, 6) array.</p>
</dd>
</dl>
</dd>
<dt>PARAMETERS</dt><dd><p>ring            lattice description
dp              momentum deviation. Defaults to 0
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for mstack.</p>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>keep_lattice=False  When True, assume no lattice change since the</dt><dd><p>previous tracking.</p>
</dd>
<dt>orbit=None          Avoids looking for the closed orbit if is already</dt><dd><p>known (6,) array</p>
</dd>
</dl>
<p>XYStep=1.e-8        transverse step for numerical computation</p>
</dd>
</dl>
<p>See also find_m44, find_orbit6</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.find_orbit">
<span class="sig-name descname"><span class="pre">find_orbit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.find_orbit" title="Permalink to this definition"></a></dt>
<dd><p>find_orbit finds the closed orbit by numerically getting the fixed point
of the one turn map M calculated with lattice_pass.</p>
<p>Depending on the the lattice, find_orbit will:
- use find_orbit6 if ring.radiation is ON,
- use find_sync_orbit if ring.radiation is OFF and dct is specified,
- use find_orbit4 otherwise</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            Sequence of AT elements
refpts          elements at which data is returned.</p>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>orbit0          ((6,) closed orbit vector at the entrance of the</dt><dd><p>1-st element</p>
</dd>
<dt>orbit           (6, Nrefs) closed orbit vector at each location</dt><dd><p>specified in refpts</p>
</dd>
</dl>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0            Momentum deviation, when radiation is OFF
dct=0            Path lengthening, when radiation ids OFF
keep_lattice    Assume no lattice change since the previous tracking.</p>
<blockquote>
<div><p>Default: False</p>
</div></blockquote>
<dl class="simple">
<dt>guess=None      Initial guess for the closed orbit. It may help</dt><dd><p>convergence.</p>
</dd>
<dt>orbit=None      Orbit at entrance of the lattice, if known. find_orbit</dt><dd><p>will then propagate it to the selected reference points</p>
</dd>
</dl>
<p>For other keywords, refer to the underlying methods</p>
</dd>
</dl>
<p>See also find_orbit4, find_sync_orbit, find_orbit6</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.find_orbit4">
<span class="sig-name descname"><span class="pre">find_orbit4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.find_orbit4" title="Permalink to this definition"></a></dt>
<dd><p>findorbit4 finds the closed orbit in the 4-d transverse phase
space by numerically solving for a fixed point of the one turn
map M calculated with lattice_pass.</p>
<blockquote>
<div><p>(X, PX, Y, PY, dP, CT2 ) = M (X, PX, Y, PY, dP, CT1)</p>
</div></blockquote>
<p>under the CONSTANT MOMENTUM constraint dP and with NO constraint
on the 6-th coordinate CT</p>
<p>IMPORTANT!!! findorbit4 imposes a constraint on dP and relaxes
the constraint on the revolution frequency. A physical storage
ring does exactly the opposite: the momentum deviation of a
particle on the closed orbit settles at the value
such that the revolution is synchronous with the RF cavity</p>
<blockquote>
<div><p>HarmNumber*Frev = Frf</p>
</div></blockquote>
<p>To impose this artificial constraint in find_orbit4, PassMethod
used for any element SHOULD NOT
1.  change the longitudinal momentum dP (cavities , magnets with radiation)
2.  have any time dependence (localized impedance, fast kickers etc)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be OFF)
dp              momentum deviation. Defaults to 0
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for orbit.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>orbit0          ((6,) closed orbit vector at the entrance of the</dt><dd><p>1-st element (x,px,y,py)</p>
</dd>
<dt>orbit           (6, Nrefs) closed orbit vector at each location</dt><dd><p>specified in refpts</p>
</dd>
</dl>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>dct=None        path lengthening. If specified, dp is ignored and</dt><dd><p>the off-momentum is deduced from the path lengthening.</p>
</dd>
<dt>orbit=None      avoids looking for initial the closed orbit if is</dt><dd><p>already known ((6,) array). find_orbit4 propagates it
to the specified refpts.</p>
</dd>
<dt>guess           (6,) initial value for the closed orbit. It may help</dt><dd><p>convergence. Default: (0, 0, 0, 0, 0, 0)</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Default: False</p>
</dd>
</dl>
<p>convergence     Convergence criterion. Default: 1.e-12
max_iterations  Maximum number of iterations. Default: 20
XYStep          Step size. Default: DConstant.XYStep</p>
</dd>
</dl>
<p>See also find_sync_orbit, find_orbit6.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.find_orbit6">
<span class="sig-name descname"><span class="pre">find_orbit6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.find_orbit6" title="Permalink to this definition"></a></dt>
<dd><p>find_orbit6 finds the closed orbit in the full 6-D phase space
by numerically solving  for a fixed point of the one turn
map M calculated with lattice_pass</p>
<p>(X, PX, Y, PY, DP, CT2 ) = M (X, PX, Y, PY, DP, CT1)</p>
<p>with constraint  CT2 - CT1 = C*HarmNumber(1/Frf - 1/Frf0)</p>
<p>IMPORTANT!!! find_orbit6 is a realistic simulation
1.  The Frf frequency in the RF cavities (may be different from Frf0)</p>
<blockquote>
<div><p>imposes the synchronous condition
CT2 - CT1 = C*HarmNumber(1/Frf - 1/Frf0)</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>The algorithm numerically calculates
6-by-6 Jacobian matrix J6. In order for (J-E) matrix
to be non-singular it is NECESSARY to use a realistic
PassMethod for cavities with non-zero momentum kick
(such as RFCavityPass).</p></li>
<li><p>find_orbit6 can find orbits with radiation.
In order for the solution to exist the cavity must supply
adequate energy compensation.
In the simplest case of a single cavity, it must have
‘Voltage’ field set so that Voltage &gt; Erad - energy loss per turn</p></li>
<li><p>There is a family of solutions that correspond to different RF buckets
They differ in the 6-th coordinate by C*Nb/Frf. Nb = 1 .. HarmNum-1</p></li>
<li><p>The value of the 6-th coordinate found at the cavity gives
the equilibrium RF phase. If there is no radiation the phase is 0;</p></li>
</ol>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be ON)
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for orbit.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>orbit0          ((6,) closed orbit vector at the entrance of the</dt><dd><p>1-st element (x,px,y,py)</p>
</dd>
<dt>orbit           (6, Nrefs) closed orbit vector at each location</dt><dd><p>specified in refpts</p>
</dd>
</dl>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit=None      avoids looking for initial the closed orbit if is</dt><dd><p>already known ((6,) array). find_orbit6 propagates it
to the specified refpts.</p>
</dd>
<dt>guess           Initial value for the closed orbit. It may help</dt><dd><p>convergence. The default is computed from the energy
loss of the ring</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Default: False</p>
</dd>
<dt>method          Method for energy loss computation</dt><dd><p>(see get_energy_loss)
default: ELossMethod.TRACKING</p>
</dd>
<dt>cavpts=None     Cavity location. If None, use all cavities.</dt><dd><p>This is used to compute the initial synchronous phase.</p>
</dd>
</dl>
<p>convergence     Convergence criterion. Default: 1.e-12
max_iterations  Maximum number of iterations. Default: 20
XYStep          Step size. Default: DConstant.XYStep
DPStep          Step size. Default: DConstant.DPStep</p>
</dd>
</dl>
<p>See also find_orbit4, find_sync_orbit.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.find_sync_orbit">
<span class="sig-name descname"><span class="pre">find_sync_orbit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.find_sync_orbit" title="Permalink to this definition"></a></dt>
<dd><p>find_sync_orbit finds the closed orbit, synchronous with the RF cavity
and momentum deviation dP (first 5 components of the phase space vector)
% by numerically solving  for a fixed point
% of the one turn map M calculated with lattice_pass</p>
<blockquote>
<div><p>(X, PX, Y, PY, dP, CT2 ) = M (X, PX, Y, PY, dP, CT1)</p>
</div></blockquote>
<p>under the constraint dCT = CT2 - CT1 = C/Frev - C/Frev0, where
Frev0 = Frf0/HarmNumber is the design revolution frequency
Frev  = (Frf0 + dFrf)/HarmNumber is the imposed revolution frequency</p>
<p>IMPORTANT!!!  find_sync_orbit imposes a constraint (CT2 - CT1) and
dP2 = dP1 but no constraint on the value of dP1, dP2
The algorithm assumes time-independent fixed-momentum ring
to reduce the dimensionality of the problem.</p>
<p>To impose this artificial constraint in find_sync_orbit
PassMethod used for any element SHOULD NOT
1.  change the longitudinal momentum dP (cavities , magnets with radiation)
2.  have any time dependence (localized impedance, fast kickers etc).</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be OFF)
dct             Path length deviation. Default: 0
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for orbit.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>orbit0          ((6,) closed orbit vector at the entrance of the</dt><dd><p>1-st element (x,px,y,py)</p>
</dd>
<dt>orbit           (6, Nrefs) closed orbit vector at each location</dt><dd><p>specified in refpts</p>
</dd>
</dl>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit=None      avoids looking for initial the closed orbit if is</dt><dd><p>already known ((6,) array). find_sync_orbit propagates
it to the specified refpts.</p>
</dd>
<dt>guess           (6,) initial value for the closed orbit. It may help</dt><dd><p>convergence. Default: (0, 0, 0, 0, 0, 0)</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Default: False</p>
</dd>
</dl>
<p>convergence     Convergence criterion. Default: 1.e-12
max_iterations  Maximum number of iterations. Default: 20
XYStep          Step size. Default: DConstant.XYStep</p>
</dd>
</dl>
<p>See also find_orbit4, find_orbit6.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.gamma">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gamma</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.gamma" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_acceptance">
<span class="sig-name descname"><span class="pre">get_acceptance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">planes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitudes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nturns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1024</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">GridMode.RADIAL</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_mp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">divider</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_zero</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_acceptance" title="Permalink to this definition"></a></dt>
<dd><p>Computes the acceptance at repfts observation points
Grid Coordiantes ordering is as follows: CARTESIAN: (x,y), RADIAL/RECURSIVE
(r, theta). Scalar inputs can be used for 1D grid.
The grid can be changed using grid_mode input:
at.GridMode.CARTESIAN: (x,y) grid
at.GridMode.RADIAL: (r,theta) grid
at.GridMode.RECURSIVE: (r,theta) recursive boundary search</p>
<p>Example usage:
bf,sf,gf = ring.get_acceptance(planes, npoints, amplitudes)
plt.plot(<a href="#id27"><span class="problematic" id="id28">*</span></a>gf,’.’)
plt.plot(<a href="#id29"><span class="problematic" id="id30">*</span></a>sf,’.’)
plt.plot(<a href="#id31"><span class="problematic" id="id32">*</span></a>bf)
plt.show()</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            ring use for tracking
planes          max. dimension 2, defines the plane where to search</p>
<blockquote>
<div><p>for the acceptance, allowed values are: x,xp,y,yp,dp,ct</p>
</div></blockquote>
<p>npoints         number of points in each dimension shape (len(planes),)
amplitudes      max. amplitude for RADIAL and CARTESIAN or initial step</p>
<blockquote>
<div><p>in RECURSIVE in each dimension. Shape is (len(planes),)
for RADIAL/RECURSIVE grid: amplitude = sqrt(x**2+y**2)</p>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><p>nturns=1024     Number of turns for the tracking
refpts=None     Observation refpts, default start of the machine
dp=None         static momentum offset
offset=None     initial orbit, default closed orbit
bounds=None     defines the tracked range: range=bounds*amplitude, it</p>
<blockquote>
<div><p>can be use to select quadrants for example
default values are:
GridMode.CARTESIAN: ((-1,1),(0,1))
GridMode.RADIAL/RECURSIVE: ((0,1),(pi,0))</p>
</div></blockquote>
<dl class="simple">
<dt>grid_mode       at.GridMode.CARTESIAN/RADIAL: track full vector</dt><dd><p>(default) at.GridMode.RECURSIVE: recursive search</p>
</dd>
<dt>use_mp=False    Use python multiprocessing (patpass, default use</dt><dd><p>lattice_pass). In case multi-processing is not
enabled GridMode is forced to
RECURSIVE (most efficient in single core)</p>
</dd>
</dl>
<p>divider=2       Value of the divider used in RECURSIVE boundary search
verbose=True    Print out some inform
start_method    This parameter allows to change the python</p>
<blockquote>
<div><p>multiprocessing start method, default=None uses the
python defaults that is considered safe.
Available parameters: ‘fork’, ‘spawn’, ‘forkserver’.
Default for linux is fork, default for MacOS and
Windows is spawn. fork may used for MacOS to speed-up
the calculation or to solve Runtime Errors, however
it is considered unsafe.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>Returns 3 numpy arrays with shape (2,n) (or lists of numpy arrays for
multiple refpts): the 2D acceptance , the full grid that was
tracked and the particles of the grid that survived. The length
of the lists=refpts. In case len(refpts)=1 the acceptance, grid,
survived arrays are returned directly.
The units depend on the selected planes and are the same as for the 6D
particle coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_bunch_length_espread">
<span class="sig-name descname"><span class="pre">get_bunch_length_espread</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bunch_curr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">espread</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_bunch_length_espread" title="Permalink to this definition"></a></dt>
<dd><p>Solves the Haissinski formula and returns the bunch length and energy
spread for given bunch current and Z/n. If both zn and bunch_curr are None,
zero current case, otherwise both are needed for the calculation</p>
<dl class="simple">
<dt>PARAMETERS</dt><dd><p>ring              ring use for tracking</p>
</dd>
<dt>KEYWORDS</dt><dd><p>zn=None           Z/n for the full ring
bunch_curr=None   Bunch current
espread=None      Energy spread, if None use lattice parameter</p>
</dd>
<dt>OUTPUT</dt><dd><p>Bunch length, energy spread</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_cells">
<span class="sig-name descname"><span class="pre">get_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_cells" title="Permalink to this definition"></a></dt>
<dd><p>Return a numpy array of booleans, with the same length as ring,
marking all elements satisfying a given condition.</p>
<dl class="simple">
<dt>refpts = getcells(ring, filtfunc)</dt><dd><p>selects all elements for which the function filtfunc(element)
returns True</p>
</dd>
<dt>refpts = getcells(ring, attrname)</dt><dd><p>selects all elements having a ‘attrname’ attribute</p>
</dd>
<dt>refpts = getcells(ring, attrname, attrvalue)</dt><dd><p>selects all elements having a ‘attrname’ attribute with value attrvalue</p>
</dd>
</dl>
<p>Example:</p>
<dl class="simple">
<dt>refpts = getcells(ring, ‘Frequency’)</dt><dd><p>returns a numpy array of booleans where all elements having a
‘Frequency’ attribute are True</p>
</dd>
<dt>refpts = getcells(ring, ‘K’, 0.0)</dt><dd><p>returns a numpy array of booleans where all elements having a ‘K’
attribute equal to 0.0 are True</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_chrom">
<span class="sig-name descname"><span class="pre">get_chrom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linopt'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cavpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_chrom" title="Permalink to this definition"></a></dt>
<dd><p>gets the chromaticity using several available methods</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description.</p>
</dd>
<dt>KEYWORDS</dt><dd><blockquote>
<div><p>dp=None         Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>method=’linopt’ ‘linopt’ returns the tunes from the linopt function</dt><dd><p>‘laskar’ tracks a single particle and computes the
tunes with NAFF</p>
</dd>
<dt>DPStep=1.0E-6   momentum step used for the computation of</dt><dd><p>chromaticities</p>
</dd>
</dl>
</div></blockquote>
<p>for the ‘laskar’ method only:</p>
<blockquote>
<div><p>nturns=512      number of turns
amplitude=1.0E-6 amplitude of oscillation
remove_dc=False Remove the mean of oscillation data
num_harmonics   number of harmonic components to compute</p>
<blockquote>
<div><p>(before mask applied, default=20)</p>
</div></blockquote>
<dl class="simple">
<dt>fmin/fmax       determine the boundaries within which the tune is</dt><dd><p>located [default 0-&gt;1]</p>
</dd>
</dl>
<p>hann=False      flag to turn on Hanning window</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>chromaticities = np.array([Q’x,Q’y])</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_elements">
<span class="sig-name descname"><span class="pre">get_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quiet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_elements" title="Permalink to this definition"></a></dt>
<dd><p>Get the elements of a family or class (type) from the lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> – lattice from which to retrieve the elements.</p></li>
<li><p><strong>key</strong> – <p>can be:
1) an element instance, will return all elements of the same type</p>
<blockquote>
<div><p>in the lattice, e.g. key=Drift(‘d1’, 1.0)</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>an element type, will return all elements of that type in the
lattice, e.g. key=at.elements.Sextupole</p></li>
<li><p>a string to match against elements’ FamName, supports Unix
shell-style wildcards, e.g. key=’BPM_*1’</p></li>
</ol>
</p></li>
<li><p><strong>quiet</strong> – if false print information about matched elements for FamName
matches, defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of elems matching key</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_energy_loss">
<span class="sig-name descname"><span class="pre">get_energy_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">ELossMethod.INTEGRAL</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_energy_loss" title="Permalink to this definition"></a></dt>
<dd><p>Compute the energy loss per turn [eV]</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring                        lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><dl>
<dt>method=ELossMethod.INTEGRAL method for energy loss computation</dt><dd><p>The enum class ELossMethod declares 2 values
INTEGRAL: The losses are obtained from</p>
<blockquote>
<div><p>Losses = Cgamma / 2pi * EGeV^4 * i2
Takes into account bending magnets and wigglers.</p>
</div></blockquote>
<dl class="simple">
<dt>TRACKING: The losses are obtained by tracking without cavities.</dt><dd><p>Needs radiation ON, takes into account all radiating elements.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_horizontal_acceptance">
<span class="sig-name descname"><span class="pre">get_horizontal_acceptance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_horizontal_acceptance" title="Permalink to this definition"></a></dt>
<dd><p>Computes the 1D horizontal acceptance at refpts observation points
Scalar parameters required</p>
<p>See get_acceptance</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            ring use for tracking
resolution      minimum distance between 2 grid points
amplitude       max. amplitude of the grid or initial step in RECURSIVE</p>
</dd>
<dt>KEYWORDS</dt><dd><p>nturns=1024     Number of turns for the tracking
dp=0            static momentum offset
refpts=None     Observation refpts, default start of the machine
grid_mode       at.GridMode.CARTESIAN/RADIAL: track full vector</p>
<blockquote>
<div><p>(default) at.GridMode.RECURSIVE: recursive search</p>
</div></blockquote>
<dl class="simple">
<dt>use_mp=False    Use python multiprocessing (patpass, default use</dt><dd><p>lattice_pass).</p>
</dd>
<dt>divider=2       Value of the divider used in RECURSIVE boundary search</dt><dd><p>In case multi-processing is not enabled GridMode is
forced to RECURSIVE (most efficient in single core)</p>
</dd>
</dl>
<p>verbose=False   Print out some information
start_method    This parameter allows to change the python</p>
<blockquote>
<div><p>multiprocessing start method, default=None uses the
python defaults that is considered safe.
Available parameters: ‘fork’, ‘spawn’, ‘forkserver’.
Default for linux is fork, default for MacOS and
Windows is spawn. fork may used for MacOS to speed-up
the calculation or to solve Runtime Errors, however
it is considered unsafe.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>Returns 3 lists containing the 1D acceptance, the grid that was tracked
and the particles of the grid that survived.
The length of the lists=refpts. In case len(refpts)=1 the acceptance,
grid, suvived arrays are returned.
The boundary output is squeezed to an array with shape (len(refpts),2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_lifetime">
<span class="sig-name descname"><span class="pre">get_lifetime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">emity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bunch_curr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">emitx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">momap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_lifetime" title="Permalink to this definition"></a></dt>
<dd><p>Computes the touschek lifetime using the piwinski formula</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            ring use for tracking
emity           verticla emittance
bunch_curr      bunch current</p>
</dd>
<dt>KEYWORDS</dt><dd><p>emitx=None      horizontal emittance
sigs=None       rms bunch length
sigp=None       energy spread
zn=None         full ring Z/n
momap=None      momentum aperture, has to be consistent with refpts</p>
<blockquote>
<div><p>if provided the momentum aperture is not calculated</p>
</div></blockquote>
<dl class="simple">
<dt>refpts=None     refpts where the momentum aperture is calculated, the</dt><dd><p>default is to compute it for all elements in the ring
len(refpts)&gt;2 is required</p>
</dd>
</dl>
<p>resolution      minimum distance between 2 grid points, default=1.0e-3
amplitude       max. amplitude of the grid or initial step in RECURSIVE</p>
<blockquote>
<div><p>default = 0.1</p>
</div></blockquote>
<p>nturns=1024     Number of turns for the tracking
dp=None         static momentum offset
offset=None     initial orbit, default closed orbit
bounds=None     Allows to define boundaries for the grid default</p>
<blockquote>
<div><p>values are:
GridMode.GRID: ((-1,1),(0,1))
GridMode.RADIAL/RECURSIVE: ((0,1),(pi,0))</p>
</div></blockquote>
<p>grid_mode       mode for the gird default GridMode.RADIAL
use_mp=False    Use python multiprocessing (patpass, default use</p>
<blockquote>
<div><p>lattice_pass). In case multi-processing is not
enabled GridMode is forced to
RECURSIVE (most efficient in single core)</p>
</div></blockquote>
<p>verbose=True    Print out some inform
epsabs, epsrel  integral absolute and relative tolerances</p>
</dd>
<dt>OUTPUT</dt><dd><p>Returns the touschek lifetime in seconds, the momentum aperture
and the refpts at which the aperture was computed</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_mcf">
<span class="sig-name descname"><span class="pre">get_mcf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_mcf" title="Permalink to this definition"></a></dt>
<dd><p>Compute the momentum compaction factor</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be OFF)</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
keep_lattice    Assume no lattice change since the previous tracking.</p>
<blockquote>
<div><p>Defaults to False</p>
</div></blockquote>
<p>dp_step=1.0E-6  momentum deviation used for differentiation</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_momentum_acceptance">
<span class="sig-name descname"><span class="pre">get_momentum_acceptance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_momentum_acceptance" title="Permalink to this definition"></a></dt>
<dd><p>Computes the 1D momentum acceptance at refpts observation points
Scalar parameters required</p>
<p>See get_acceptance</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            ring use for tracking
resolution      minimum distance between 2 grid points
amplitude       max. amplitude of the grid or initial step in RECURSIVE</p>
</dd>
<dt>KEYWORDS</dt><dd><p>nturns=1024     Number of turns for the tracking
dp=0            static momentum offset
refpts=None     Observation refpts, default start of the machine
grid_mode       at.GridMode.CARTESIAN/RADIAL: track full vector</p>
<blockquote>
<div><p>(default) at.GridMode.RECURSIVE: recursive search</p>
</div></blockquote>
<dl class="simple">
<dt>use_mp=False    Use python multiprocessing (patpass, default use</dt><dd><p>lattice_pass).</p>
</dd>
<dt>divider=2       Value of the divider used in RECURSIVE boundary search</dt><dd><p>In case multi-processing is not enabled GridMode is
forced to RECURSIVE (most efficient in single core)</p>
</dd>
</dl>
<p>verbose=False   Print out some information
start_method    This parameter allows to change the python</p>
<blockquote>
<div><p>multiprocessing start method, default=None uses the
python defaults that is considered safe.
Available parameters: ‘fork’, ‘spawn’, ‘forkserver’.
Default for linux is fork, default for MacOS and
Windows is spawn. fork may used for MacOS to speed-up
the calculation or to solve Runtime Errors, however
it is considered unsafe.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>Returns 3 lists containing the 1D acceptance, the grid that was tracked
and the particles of the grid that survived.
The length of the lists=refpts. In case len(refpts)=1 the acceptance,
grid, suvived arrays are returned.
The boundary output is squeezed to an array with shape (len(refpts),2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_optics">
<span class="sig-name descname"><span class="pre">get_optics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method=&lt;function</span> <span class="pre">linopt6&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_optics" title="Permalink to this definition"></a></dt>
<dd><p>Perform linear analysis of a fully coupled lattice</p>
<p>elemdata0, beamdata, elemdata = get_optics(lattice, refpts, <a href="#id33"><span class="problematic" id="id34">**</span></a>kwargs)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl>
<dt>method=linopt6  Method used for the analysis of the transfer matrix.</dt><dd><p>Can be None at.linopt2, at.linopt4, at.linopt6
linopt2:    no longitudinal motion, no H/V coupling,
linopt4:    no longitudinal motion, Sagan/Rubin</p>
<blockquote>
<div><p>4D-analysis of coupled motion,</p>
</div></blockquote>
<dl class="simple">
<dt>linopt6:    with or without longitudinal motion, normal</dt><dd><p>mode analysis</p>
</dd>
</dl>
</dd>
</dl>
<p>dp=None         Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     computes chromatic amplitude functions (W) [4].</dt><dd><p>Needs to compute the optics at 2 different momentum
deviations around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘R’ or ‘alpha’ and ‘beta’   (mandatory)
‘closed_orbit’,             (default 0)
‘dispersion’                (default 0)
If present, the attribute ‘R’ will be used, otherwise
the attributes ‘alpha’ and ‘beta’ will be used. All
other attributes are ignored.</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>elemdata0       linear optics data at the entrance/end of the ring
beamdata        lattice properties
elemdata        linear optics at the points refered to by refpts, if</p>
<blockquote>
<div><p>refpts is None an empty elemdata structure is returned.</p>
</div></blockquote>
<p>elemdata is a record array with fields depending on the
selected method.
See the help for linopt6, linopt4, linopt2, linopt_auto.</p>
<p>beamdata is a record with fields:
tune            Fractional tunes
chromaticity    Chromaticities
damping_time    Damping times [s] (only if radiation is ON)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_radiation_integrals">
<span class="sig-name descname"><span class="pre">get_radiation_integrals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">twiss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_radiation_integrals" title="Permalink to this definition"></a></dt>
<dd><p>Compute the 5 radiation integrals for uncoupled lattices.</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description.</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>twiss=None      linear optics at all points (from linopt). If None,</dt><dd><p>it will be computed.</p>
</dd>
</dl>
<p>dp=0.0          Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl>
<dt>method=linopt6  Method used for the analysis of the transfer matrix.</dt><dd><p>See get_optics.
linopt6: default
linopt2: faster if no longitudinal motion and</p>
<blockquote>
<div><p>no H/V coupling,</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>i1, i2, i3, i4, i5</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_refpts">
<span class="sig-name descname"><span class="pre">get_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quiet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_refpts" title="Permalink to this definition"></a></dt>
<dd><p>Get the elements refpts of a family or class (type) from the lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> – lattice from which to retrieve the elements.</p></li>
<li><p><strong>key</strong> – <p>can be:
1) an element instance, will return all elements of the same type</p>
<blockquote>
<div><p>in the lattice, e.g. key=Drift(‘d1’, 1.0)</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>an element type, will return all elements of that type in the
lattice, e.g. key=at.elements.Sextupole</p></li>
<li><p>a string to match against elements’ FamName, supports Unix
shell-style wildcards, e.g. key=’BPM_*1’</p></li>
</ol>
</p></li>
<li><p><strong>quiet</strong> – if false print information about matched elements for FamName
matches, defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of elems refpts matching key</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>elems</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_revolution_frequency">
<span class="sig-name descname"><span class="pre">get_revolution_frequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_revolution_frequency" title="Permalink to this definition"></a></dt>
<dd><p>Compute the revolution frequency of the full ring [Hz]</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
dct=0.0         Path length deviation
keep_lattice    Assume no lattice change since the previous tracking.</p>
<blockquote>
<div><p>Defaults to False</p>
</div></blockquote>
<p>dp_step=1.0E-6  momentum deviation used for differentiation</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_rf_frequency">
<span class="sig-name descname"><span class="pre">get_rf_frequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_rf_frequency" title="Permalink to this definition"></a></dt>
<dd><p>Return the RF frequency
KEYWORDS</p>
<blockquote>
<div><dl class="simple">
<dt>cavpts=None   Cavity location.</dt><dd><p>If None, look for ring.cavpts, or otherwise take all
cavities.</p>
</dd>
<dt>array=False   If False, return the frequency of the selected cavities</dt><dd><p>with the lowest frequency.
If True, return the frequency of all selected cavities</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_rf_timelag">
<span class="sig-name descname"><span class="pre">get_rf_timelag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_rf_timelag" title="Permalink to this definition"></a></dt>
<dd><p>Return the RF time lag
KEYWORDS</p>
<blockquote>
<div><dl class="simple">
<dt>cavpts=None   Cavity location.</dt><dd><p>If None, look for ring.cavpts, or otherwise take all
cavities.</p>
</dd>
<dt>array=False   If False, return the time lag of the cavities with the</dt><dd><p>lowest frequency.
If True, return the time lag of all the selected
cavities.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_rf_voltage">
<span class="sig-name descname"><span class="pre">get_rf_voltage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_rf_voltage" title="Permalink to this definition"></a></dt>
<dd><p>Return the total RF voltage (full ring)
KEYWORDS</p>
<blockquote>
<div><dl class="simple">
<dt>cavpts=None   Cavity location.</dt><dd><p>If None, look for ring.cavpts, or otherwise take all
cavities.</p>
</dd>
<dt>array=False   If False, return the sum of the voltage of the selected</dt><dd><p>cavities with the lowest frequency.
If True, return the voltage of all the selected cavities.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_s_pos">
<span class="sig-name descname"><span class="pre">get_s_pos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_s_pos" title="Permalink to this definition"></a></dt>
<dd><p>Return a numpy array corresponding to the s position of the specified
elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> – lattice from which to retrieve s position</p></li>
<li><p><strong>refpts</strong> – elements at which to return s position. If None, return
s position at all elements in the ring.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_slip_factor">
<span class="sig-name descname"><span class="pre">get_slip_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_slip_factor" title="Permalink to this definition"></a></dt>
<dd><p>Compute the slip factor</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be OFF)</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
keep_lattice    Assume no lattice change since the previous tracking.</p>
<blockquote>
<div><p>Defaults to False</p>
</div></blockquote>
<p>dp_step=1.0E-6  momentum deviation used for differentiation</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_tune">
<span class="sig-name descname"><span class="pre">get_tune</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linopt'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_tune" title="Permalink to this definition"></a></dt>
<dd><p>gets the tune using several available methods</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description.</p>
</dd>
<dt>KEYWORDS</dt><dd><blockquote>
<div><p>dp=None         Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>method=’linopt’ ‘linopt’ returns the tunes from the linopt function</dt><dd><p>‘fft’ tracks a single particle and computes the
tunes with fft ‘laskar’ tracks a single particle
and computes the tunes with NAFF</p>
</dd>
</dl>
</div></blockquote>
<p>for the ‘fft’ and ‘laskar’ methods only:</p>
<blockquote>
<div><p>nturns=512      number of turns
amplitude=1.0E-6 amplitude of oscillation
remove_dc=False Remove the mean of oscillation data
num_harmonics   number of harmonic components to compute</p>
<blockquote>
<div><p>(before mask applied, default=20)</p>
</div></blockquote>
<dl class="simple">
<dt>fmin/fmax       determine the boundaries within which the tune is</dt><dd><p>located [default 0-&gt;1]</p>
</dd>
</dl>
<p>hann=False      flag to turn on Hanning window</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>tunes = np.array([Qx,Qy])</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_value_refpts">
<span class="sig-name descname"><span class="pre">get_value_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_value_refpts" title="Permalink to this definition"></a></dt>
<dd><p>Get the values of an attribute of an array of elements based on
their refpts</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>description</strong> (<em>ring            Lattice</em>) – </p></li>
<li><p><strong>Integer</strong> (<em>refpts</em>) – </p></li>
<li><p><strong>booleans</strong> (<em>array of integer or</em>) – </p></li>
<li><p><strong>filter</strong> – </p></li>
<li><p><strong>name</strong> (<em>var             attribute</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>KEYWORDS:</dt><dd><dl class="simple">
<dt>index=None      index of the value to retrieve if var is an array.</dt><dd><p>If None the full array is retrieved (Default)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_vertical_acceptance">
<span class="sig-name descname"><span class="pre">get_vertical_acceptance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_vertical_acceptance" title="Permalink to this definition"></a></dt>
<dd><p>Computes the 1D vertical acceptance at refpts observation points
Scalar parameters required</p>
<p>See get_acceptance</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            ring use for tracking
resolution      minimum distance between 2 grid points
amplitude       max. amplitude of the grid or initial step in RECURSIVE</p>
</dd>
<dt>KEYWORDS</dt><dd><p>nturns=1024     Number of turns for the tracking
dp=0            static momentum offset
refpts=None     Observation refpts, default start of the machine
grid_mode       at.GridMode.CARTESIAN/RADIAL: track full vector</p>
<blockquote>
<div><p>(default) at.GridMode.RECURSIVE: recursive search</p>
</div></blockquote>
<dl class="simple">
<dt>use_mp=False    Use python multiprocessing (patpass, default use</dt><dd><p>lattice_pass).</p>
</dd>
<dt>divider=2       Value of the divider used in RECURSIVE boundary search</dt><dd><p>In case multi-processing is not enabled GridMode is
forced to RECURSIVE (most efficient in single core)</p>
</dd>
</dl>
<p>verbose=False   Print out some information
start_method    This parameter allows to change the python</p>
<blockquote>
<div><p>multiprocessing start method, default=None uses the
python defaults that is considered safe.
Available parameters: ‘fork’, ‘spawn’, ‘forkserver’.
Default for linux is fork, default for MacOS and
Windows is spawn. fork may used for MacOS to speed-up
the calculation or to solve Runtime Errors, however
it is considered unsafe.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>Returns 3 lists containing the 1D acceptance, the grid that was tracked
and the particles of the grid that survived.
The length of the lists=refpts. In case len(refpts)=1 the acceptance,
grid, suvived arrays are returned.
The boundary output is squeezed to an array with shape (len(refpts),2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.harmonic_number">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">harmonic_number</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.harmonic_number" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.i_range">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">i_range</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.i_range" title="Permalink to this definition"></a></dt>
<dd><p>Range of elements inside the range of interest</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.insert">
<span class="sig-name descname"><span class="pre">insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elem</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.insert" title="Permalink to this definition"></a></dt>
<dd><p>Insert object before index.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.linopt">
<span class="sig-name descname"><span class="pre">linopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_chrom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.linopt" title="Permalink to this definition"></a></dt>
<dd><p>Perform linear analysis of a H/V coupled lattice following Sagan/Rubin
4D-analysis of coupled motion</p>
<p>lindata0, tune, chrom, lindata = linopt(lattice, dp, refpts, <a href="#id35"><span class="problematic" id="id36">**</span></a>kwargs)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
dp=0.0          momentum deviation.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     computes chromatic amplitude functions (W) [4].</dt><dd><p>Needs to compute the optics at 2 different momentum
deviations around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of</p>
<blockquote>
<div><p>chromaticities and dispersion</p>
</div></blockquote>
<dl class="simple">
<dt>coupled=True    if False, simplify the calculations by assuming</dt><dd><p>no H/V coupling</p>
</dd>
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘alpha’ and ‘beta’  (mandatory)
‘closed_orbit’,     (default 0)
‘dispersion’        (default 0)
All other attributes are ignored.</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>lindata0        linear optics data at the entrance of the ring
tune            [tune_A, tune_B], linear tunes for the two normal modes</p>
<blockquote>
<div><p>of linear motion [1]</p>
</div></blockquote>
<dl class="simple">
<dt>chrom           [ksi_A , ksi_B], chromaticities ksi = d(nu)/(dP/P).</dt><dd><p>Only computed if ‘get_chrom’ is True</p>
</dd>
<dt>lindata         linear optics at the points refered to by refpts, if</dt><dd><p>refpts is None an empty lindata structure is returned.</p>
</dd>
</dl>
<p>lindata is a record array with fields:
idx             element index in the ring
s_pos           longitudinal position [m]
m44             (4, 4) transfer matrix M from the beginning of ring</p>
<blockquote>
<div><p>to the entrance of the element [2]</p>
</div></blockquote>
<p>closed_orbit    (6,) closed orbit vector
dispersion      (4,) dispersion vector
beta            [betax, betay] vector
alpha           [alphax, alphay] vector
mu              [mux, muy], betatron phase (modulo 2*pi)
W               (2,) chromatic amplitude function (only if get_w==True)
All values given at the entrance of each element specified in refpts.
In case coupled == True additional outputs are available:
gamma           gamma parameter of the transformation to eigenmodes
A               (2, 2) matrix A in [3]
B               (2, 2) matrix B in [3]
C               (2, 2) matrix C in [3]
Field values can be obtained with either
lindata[‘idx’]    or
lindata.idx</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] D.Edwards,L.Teng IEEE Trans.Nucl.Sci. NS-20, No.3, p.885-888, 1973
[2] E.Courant, H.Snyder
[3] D.Sagan, D.Rubin Phys.Rev.Spec.Top.-Accelerators and beams,</p>
<blockquote>
<div><p>vol.2 (1999)</p>
</div></blockquote>
<p>[4] Brian W. Montague Report LEP Note 165, CERN, 1979</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.linopt2">
<span class="sig-name descname"><span class="pre">linopt2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.linopt2" title="Permalink to this definition"></a></dt>
<dd><p>Perform linear analysis of an uncoupled lattice</p>
<p>elemdata0, beamdata, elemdata = linopt2(ring, refpts, <a href="#id37"><span class="problematic" id="id38">**</span></a>kwargs)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
dct=None        path lengthening. If specified, dp is ignored and the</p>
<blockquote>
<div><p>off-momentum is deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     computes chromatic amplitude functions (W) [4].</dt><dd><p>Needs to compute the optics at 2 different momentum
deviations around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of</p>
<blockquote>
<div><p>chromaticities and dispersion</p>
</div></blockquote>
<dl class="simple">
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘alpha’ and ‘beta’  (mandatory)
‘closed_orbit’,     (default 0)
‘dispersion’        (default 0)
All other attributes are ignored.</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>lindata0        linear optics data at the entrance of the ring
beamdata        lattice properties
lindata         linear optics at the points refered to by refpts, if</p>
<blockquote>
<div><p>refpts is None an empty lindata structure is returned.</p>
</div></blockquote>
<p>lindata is a record array with fields:
s_pos           longitudinal position [m]
M               (4, 4) transfer matrix M from the beginning of ring</p>
<blockquote>
<div><p>to the entrance of the element [2]</p>
</div></blockquote>
<p>closed_orbit    (6,) closed orbit vector
dispersion      (4,) dispersion vector
beta            [betax, betay] vector
alpha           [alphax, alphay] vector
mu              [mux, muy], betatron phase (modulo 2*pi)
W               (2,) chromatic amplitude function (only if get_w==True)
All values given at the entrance of each element specified in refpts.
Field values can be obtained with either
lindata[‘idx’]    or
lindata.idx</p>
<p>beamdata is a record with fields:
tune            Fractional tunes
chromaticity    Chromaticities, only computed if get_chrom=True</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] D.Edwards,L.Teng IEEE Trans.Nucl.Sci. NS-20, No.3, p.885-888, 1973
[2] E.Courant, H.Snyder
[3] D.Sagan, D.Rubin Phys.Rev.Spec.Top.-Accelerators and beams,</p>
<blockquote>
<div><p>vol.2 (1999)</p>
</div></blockquote>
<p>[4] Brian W. Montague Report LEP Note 165, CERN, 1979</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.linopt4">
<span class="sig-name descname"><span class="pre">linopt4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.linopt4" title="Permalink to this definition"></a></dt>
<dd><p>Perform linear analysis of a H/V coupled lattice following Sagan/Rubin
4D-analysis of coupled motion</p>
<p>elemdata0, beamdata, elemdata = linopt4(lattice, refpts, <a href="#id39"><span class="problematic" id="id40">**</span></a>kwargs)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
dct=None        path lengthening. If specified, dp is ignored and the</p>
<blockquote>
<div><p>off-momentum is deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     computes chromatic amplitude functions (W) [4].</dt><dd><p>Needs to compute the optics at 2 different momentum
deviations around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of</p>
<blockquote>
<div><p>chromaticities and dispersion</p>
</div></blockquote>
<dl class="simple">
<dt>twiss_in=None   Initial twiss to compute transfer line optics of the</dt><dd><p>type lindata, the initial orbit in twiss_in is ignored,
only the beta and alpha are required other quatities
set to 0 if absent</p>
</dd>
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘alpha’ and ‘beta’  (mandatory)
‘closed_orbit’,     (default 0)
‘dispersion’        (default 0)
All other attributes are ignored.</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>lindata0        linear optics data at the entrance of the ring
beamdata        lattice properties
lindata         linear optics at the points refered to by refpts, if</p>
<blockquote>
<div><p>refpts is None an empty lindata structure is returned.</p>
</div></blockquote>
<p>lindata is a record array with fields:
s_pos           longitudinal position [m]
M               (4, 4) transfer matrix M from the beginning of ring</p>
<blockquote>
<div><p>to the entrance of the element [2]</p>
</div></blockquote>
<p>closed_orbit    (6,) closed orbit vector
dispersion      (4,) dispersion vector
beta            [betax, betay] vector
alpha           [alphax, alphay] vector
mu              [mux, muy], betatron phase (modulo 2*pi)
gamma           gamma parameter of the transformation to eigenmodes [3]
W               (2,) chromatic amplitude function (only if get_w==True)
All values given at the entrance of each element specified in refpts.
Field values can be obtained with either
lindata[‘idx’]    or
lindata.idx</p>
<p>beamdata is a record with fields:
tune            Fractional tunes
chromaticity    Chromaticities, only computed if get_chrom==True</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] D.Edwards,L.Teng IEEE Trans.Nucl.Sci. NS-20, No.3, p.885-888, 1973
[2] E.Courant, H.Snyder
[3] D.Sagan, D.Rubin Phys.Rev.Spec.Top.-Accelerators and beams,</p>
<blockquote>
<div><p>vol.2 (1999)</p>
</div></blockquote>
<p>[4] Brian W. Montague Report LEP Note 165, CERN, 1979</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.linopt6">
<span class="sig-name descname"><span class="pre">linopt6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.linopt6" title="Permalink to this definition"></a></dt>
<dd><p>Perform linear analysis of a fully coupled lattice using normal modes</p>
<p>elemdata0, beamdata, elemdata = linopt6(lattice, refpts, <a href="#id41"><span class="problematic" id="id42">**</span></a>kwargs)</p>
<p>For circular machines, linopt6 analyses
the 4x4 1-turn transfer matrix if radiation is OFF, or
the 6x6 1-turn transfer matrix if radiation is ON.</p>
<dl>
<dt>For a transfer line, The “twiss_in” intput must contain either:</dt><dd><ul class="simple">
<li><p>a field ‘R’, as provided by ATLINOPT6, or</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>the fields ‘beta’ and ‘alpha’, as provided by linopt and linopt6</p></li>
</ul>
</div></blockquote>
</dd>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
refpts=None     elements at which data is returned.</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=None         Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     compute chromatic amplitude functions (W) [3]. Needs to</dt><dd><p>compute the optics at 2 different momentum deviations
around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of</p>
<blockquote>
<div><p>the closed orbit</p>
</div></blockquote>
<dl class="simple">
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘R’ or ‘alpha’ and ‘beta’   (mandatory)
‘closed_orbit’,             (default 0)
‘dispersion’                (default 0)
If present, the attribute ‘R’ will be used, otherwise
the attributes ‘alpha’ and ‘beta’ will be used. All
other attributes are ignored.</p>
</dd>
</dl>
<p>cavpts=None     Cavity location for off-momentum tuning</p>
</dd>
<dt>OUTPUT</dt><dd><p>elemdata0       linear optics data at the entrance of the ring
beamdata        lattice properties
elemdata        linear optics at the points refered to by refpts, if</p>
<blockquote>
<div><p>refpts is None an empty elemdata structure is returned.</p>
</div></blockquote>
<p>elemdata is a record array with fields:
s_pos           longitudinal position [m]
M               Transfer matrix from the entrance of the line (6, 6)
closed_orbit    (6,) closed orbit vector
dispersion      (4,) dispersion vector
A               A-matrix (6, 6)
R               R-matrices (3, 6, 6)
beta            [betax, betay] vector
alpha           [alphax, alphay] vector
mu              [mux, muy], betatron phases
W               (2,) chromatic amplitude function (only if get_w==True)</p>
<p>All values given at the entrance of each element specified in refpts.
Field values can be obtained with either
elemdata[‘beta’]    or
elemdata.beta</p>
<p>beamdata is a record with fields:
tune            Fractional tunes
chromaticity    Chromaticities, only computed if get_chrom==True
damping_time    Damping times [s] (only if radiation is ON)</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] Etienne Forest, Phys. Rev. E 58, 2481 – Published 1 August 1998
[2] Andrzej Wolski, Phys. Rev. ST Accel. Beams 9, 024001 –</p>
<blockquote>
<div><p>Published 3 February 2006</p>
</div></blockquote>
<p>[3] Brian W. Montague Report LEP Note 165, CERN, 1979</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.load">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.load" title="Permalink to this definition"></a></dt>
<dd><p>Load a Lattice object from a file</p>
<p>The file format is indicated by the filepath extension.</p>
<dl>
<dt>PARAMETERS</dt><dd><p>filepath        name of the file</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>name            Name of the lattice</dt><dd><p>(default: taken from the file, or ‘’)</p>
</dd>
<dt>energy          Energy of the lattice</dt><dd><p>(default: taken from the file)</p>
</dd>
<dt>periodicity     Number of periods</dt><dd><p>(default: taken from the file, or 1)</p>
</dd>
</dl>
<ul class="simple">
<li><p>all other keywords will be set as Lattice attributes</p></li>
</ul>
</dd>
<dt>MAT-FILE SPECIFIC KEYWORDS</dt><dd><dl class="simple">
<dt>mat_key         name of the Matlab variable containing the lattice.</dt><dd><p>Default: Matlab variable name if there is only one,
otherwise ‘RING’</p>
</dd>
</dl>
<p>check=True      if False, skip the coherence tests
quiet=False     If True, suppress the warning for non-standard classes
keep_all=False  if True, keep RingParam elements as Markers</p>
</dd>
</dl>
<p>Known extensions are:</p>
<p>.mat        Matlab binary mat-file
.m          Matlab text m-file
.repr       Text representation of a python AT Lattice
.lat        Tracy format
.lte        Elegant format</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.mcf">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mcf</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.mcf" title="Permalink to this definition"></a></dt>
<dd><p>Momentum compaction factor</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.modify_elements">
<span class="sig-name descname"><span class="pre">modify_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem_modify</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.modify_elements" title="Permalink to this definition"></a></dt>
<dd><p>Modify selected elements, in-place or in a lattice copy</p>
<dl>
<dt>PARAMETERS</dt><dd><p>elem_modify         element selection function.</p>
<p>If elem_modify(elem) returns None, the element is unchanged.
Otherwise, elem_modify(elem) must return a dictionary of
attribute name and values, to be set to elem.</p>
</dd>
<dt>RETURNS</dt><dd><p>New lattice if copy == True
None if copy == False</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>copy=True   If True, return a shallow copy of the lattice. Only the</dt><dd><p>modified elements are copied.
If False, the modification is done in-place</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.ohmi_envelope">
<span class="sig-name descname"><span class="pre">ohmi_envelope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.ohmi_envelope" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the equilibrium beam envelope in a
circular accelerator using Ohmi’s beam envelope formalism [1]</p>
<p>emit0, beamdata, emit = ohmi_envelope(ring[, refpts])</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            Lattice object.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit=None          Avoids looking for the closed orbit if it is</dt><dd><p>already known ((6,) array)</p>
</dd>
<dt>keep_lattice=False  Assume no lattice change since the previous</dt><dd><p>tracking</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>emit0               emittance data at the start/end of the ring
beamdata            beam parameters at the start of the ring
emit                emittance data at the points refered to by refpts,</p>
<blockquote>
<div><p>if refpts is None an empty structure is returned.</p>
</div></blockquote>
<p>emit is a record array with fields:
r66                 (6, 6) equilibrium envelope matrix R
r44                 (4, 4) betatron emittance matrix (dpp = 0)
m66                 (6, 6) transfer matrix from the start of the ring
orbit6              (6,) closed orbit
emitXY              (2,) betatron emittance projected on xxp and yyp
emitXYZ             (3,) 6x6 emittance projected on xxp, yyp, ldp</p>
<p>beamdata is a record array with fields:
tunes               tunes of the 3 normal modes
damping_rates       damping rates of the 3 normal modes
mode_matrices       R-matrices of the 3 normal modes
mode_emittances     equilibrium emittances of the 3 normal modes</p>
<p>Field values can be obtained with either
emit[‘r66’]    or
emit.r66</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] K.Ohmi et al. Phys.Rev.E. Vol.49. (1994)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.particle">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">particle</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.particle" title="Permalink to this definition"></a></dt>
<dd><p>Circulating particle</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.radiation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">radiation</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.radiation" title="Permalink to this definition"></a></dt>
<dd><p>If True, at least one element modifies the beam energy</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.radiation_off">
<span class="sig-name descname"><span class="pre">radiation_off</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cavity_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quadrupole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wiggler_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sextupole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">octupole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multipole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.radiation_off" title="Permalink to this definition"></a></dt>
<dd><p>Turn acceleration and radiation off and return the lattice</p>
<dl>
<dt>KEYWORDS</dt><dd><p>cavity_pass=’IdentityPass’  PassMethod set on cavities
dipole_pass=’auto’          PassMethod set on dipoles
quadrupole_pass=None        PassMethod set on quadrupoles
wiggler_pass=’auto’         PassMethod set on wigglers
copy=False  If False, the modification is done in-place,</p>
<blockquote>
<div><p>If True, return a shallow copy of the lattice. Only the
radiating elements are copied with PassMethod modified.
CAUTION: a shallow copy means that all non-radiating
elements are shared with the original lattice.
Any further modification will affect in both lattices.</p>
</div></blockquote>
<dl class="simple">
<dt>For PassMethod names, the convention is:</dt><dd><p>None            no change
‘auto’          replace <a href="#id43"><span class="problematic" id="id44">*</span></a>RadPass by <a href="#id45"><span class="problematic" id="id46">*</span></a>Pass
anything else   set as it is</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.radiation_on">
<span class="sig-name descname"><span class="pre">radiation_on</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cavity_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'RFCavityPass'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quadrupole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wiggler_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sextupole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">octupole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multipole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.radiation_on" title="Permalink to this definition"></a></dt>
<dd><p>Turn acceleration and radiation on and return the lattice</p>
<dl>
<dt>KEYWORDS</dt><dd><p>cavity_pass=’RFCavityPass’  PassMethod set on cavities
dipole_pass=’auto’          PassMethod set on dipoles
quadrupole_pass=’auto’      PassMethod set on quadrupoles
wiggler_pass=’auto’         PassMethod set on wigglers
copy=False  If False, the modification is done in-place,</p>
<blockquote>
<div><p>If True, return a shallow copy of the lattice. Only the
radiating elements are copied with PassMethod modified.
CAUTION: a shallow copy means that all non-radiating
elements are shared with the original lattice.
Any further modification will affect in both lattices.</p>
</div></blockquote>
<dl class="simple">
<dt>For PassMethod names, the convention is:</dt><dd><p>None            no change
‘auto’          replace <a href="#id47"><span class="problematic" id="id48">*</span></a>Pass by <a href="#id49"><span class="problematic" id="id50">*</span></a>RadPass
anything else   set as the new PassMethod</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.radiation_parameters">
<span class="sig-name descname"><span class="pre">radiation_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.radiation_parameters" title="Permalink to this definition"></a></dt>
<dd><p>Compute ring parameters from the radiation integrals. Valid for
uncoupled lattices with no RF cavity or radiating element.</p>
<dl>
<dt>INPUT</dt><dd><p>ring            Lattice object.</p>
</dd>
<dt>KEYWORD</dt><dd><p>params=None     RingParam object to be updated.
dp=0.0          Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl>
<dt>method=linopt6  Method used for the analysis of the transfer matrix.</dt><dd><p>See get_optics.
linopt6: default
linopt2: faster if no longitudinal motion and</p>
<blockquote>
<div><p>no H/V coupling,</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>params          RingParam object. The computed attributes are,</p>
<blockquote>
<div><p>tunes           (3,) fractional (H, V, Long.) tunes
fulltunes       (3,) full tunes
chromaticities  (2,) H, V Chromaticities
alphac          Momentum compaction factor
etac            Frequency slip factor
E0              Energy [eV]
U0              nergy loss / turn [eV]
i1              Radiation integrals - I1 [m]
i2                                    I2 [m^-1]
i3                                    I3 [m^-2]
i4                                    I4 [m^-1]
i5                                    I5 [m^-1]
emittances      (3,) Mode emittances
J               (3,) Damping partition numbers
Tau             (3,) Damping times [s]
sigma_e         Energy spread
sigma_l         Bunch length [m]
voltage         Total accelerating voltage [V]
phi_s           Synchrotron phase [rad]
f_s             Synchrotron frequency [Hz]</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.refcount">
<span class="sig-name descname"><span class="pre">refcount</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.refcount" title="Permalink to this definition"></a></dt>
<dd><p>Number of reference points</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.replace">
<span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.replace" title="Permalink to this definition"></a></dt>
<dd><p>Return a shallow copy of the lattice replacing the selected
elements by a deep copy</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.revolution_frequency">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">revolution_frequency</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.revolution_frequency" title="Permalink to this definition"></a></dt>
<dd><p>Revolution frequency (fullring) [Hz]</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.rf_frequency">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rf_frequency</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.rf_frequency" title="Permalink to this definition"></a></dt>
<dd><p>Fundamental RF frequency [Hz]</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.rf_timelag">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rf_timelag</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.rf_timelag" title="Permalink to this definition"></a></dt>
<dd><p>Time lag of the fundamental mode [m]</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.rf_voltage">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rf_voltage</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.rf_voltage" title="Permalink to this definition"></a></dt>
<dd><p>RF voltage of the full ring [V]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.rotate" title="Permalink to this definition"></a></dt>
<dd><p>Return a new lattice rotated left by n elements</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.s_range">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">s_range</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.s_range" title="Permalink to this definition"></a></dt>
<dd><p>[s_min, s_max]. ‘None’ means the full cell.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>Range of interest</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.save" title="Permalink to this definition"></a></dt>
<dd><p>Save a Lattice object</p>
<p>The file format is indicated by the filepath extension.</p>
<dl class="simple">
<dt>PARAMETERS</dt><dd><p>ring            Lattice object
filepath        name of the file</p>
</dd>
<dt>MAT-FILE SPECIFIC KEYWORDS</dt><dd><p>mat_key=’RING’  Name of the Matlab variable</p>
</dd>
</dl>
<p>Known extensions are:</p>
<p>.mat        Matlab binary mat-file
.m          Matlab text m-file
.repr       Text representation of a python AT Lattice</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.sbreak">
<span class="sig-name descname"><span class="pre">sbreak</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">break_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">break_elems</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.sbreak" title="Permalink to this definition"></a></dt>
<dd><p>Insert elements at selected locations in the lattice</p>
<dl>
<dt>PARAMETERS</dt><dd><p>break_s:        location or array of locations of breakpoints
break_elems:    elements to be inserted at breakpoints (array of</p>
<blockquote>
<div><p>elements as long as break_s or single element
duplicated as necessary). Default: Marker(‘sbreak’)</p>
</div></blockquote>
</dd>
<dt>RETURNS</dt><dd><p>A new lattice with new elements inserted at breakpoints</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.select">
<span class="sig-name descname"><span class="pre">select</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.select" title="Permalink to this definition"></a></dt>
<dd><p>Return an iterator over all elements in ring identified by refpts.</p>
<p>refpts may be:</p>
<ol class="arabic simple">
<li><p>a integer or a sequence of integers (0 indicating the first element)</p></li>
<li><p>a sequence of booleans marking the selected elements</p></li>
<li><p>a callable f such that f(elem) is True for selected elements</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_cavity">
<span class="sig-name descname"><span class="pre">set_cavity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Voltage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">TimeLag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cavpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_cavity" title="Permalink to this definition"></a></dt>
<dd><p>Set the parameters of the RF cavities</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring                lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><p>Frequency=None  RF frequency [Hz]
Voltage=None    RF voltage [V]
TimeLag=None    RF time shift [-ct]
cavpts=None     Cavity location. If None, look for ring.cavpts, or</p>
<blockquote>
<div><p>otherwise take all cavities</p>
</div></blockquote>
<dl class="simple">
<dt>array=False     If False, the value is applied as described for</dt><dd><p>set_rf_voltage, set_rf_timelag and set_rf_frequency
If True, directly apply the value to the selected
cavities. The value must be broadcastable to the number
of cavities.</p>
</dd>
<dt>copy=False      If True, returns a shallow copy of ring with new</dt><dd><p>cavity elements. Otherwise, modify ring in-place</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_cavity_phase">
<span class="sig-name descname"><span class="pre">set_cavity_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">ELossMethod.TRACKING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cavpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_cavity_phase" title="Permalink to this definition"></a></dt>
<dd><p>Adjust the TimeLag attribute of RF cavities based on frequency,
voltage and energy loss per turn, so that the synchronous phase is zero.
An error occurs if all cavities do not have the same frequency.</p>
<p>!!!!WARNING!!!: This function changes the time reference,
this should be avoided</p>
<blockquote>
<div><dl class="simple">
<dt>PARAMETERS</dt><dd><p>ring        lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>method=ELossMethod.INTEGRAL</dt><dd><p>method for energy loss computation.
See “get_energy_loss”.</p>
</dd>
<dt>cavpts=None         Cavity location. If None, use all cavities.</dt><dd><p>This allows to ignore harmonic cavities.</p>
</dd>
<dt>copy=False          If True, returns a shallow copy of ring with new</dt><dd><p>cavity elements. Otherwise, modify ring in-place.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_rf_frequency">
<span class="sig-name descname"><span class="pre">set_rf_frequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_rf_frequency" title="Permalink to this definition"></a></dt>
<dd><p>Set the RF frequency</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description
frequency       RF frequency [Hz]. Default: nominal frequency.</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          Momentum deviation.
dct=0.0         Path length deviation
cavpts=None     If None, look for ring.cavpts, or otherwise take all</p>
<blockquote>
<div><p>cavities.</p>
</div></blockquote>
<dl class="simple">
<dt>array=False     If False, frequency is applied to the selected cavities</dt><dd><p>with the lowest frequency. The frequency of all the
other selected cavities is scaled by the same ratio.
If True, directly apply frequency to the selected
cavities. The value must be broadcastable to the number
of cavities.</p>
</dd>
<dt>copy=False      If True, returns a shallow copy of ring with new</dt><dd><p>cavity elements. Otherwise, modify ring in-place</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_rf_timelag">
<span class="sig-name descname"><span class="pre">set_rf_timelag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timelag</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_rf_timelag" title="Permalink to this definition"></a></dt>
<dd><p>Set the RF time lag</p>
<dl class="simple">
<dt>PARAMETERS</dt><dd><p>ring            lattice description
timelag         RF time shift (-ct) [m]</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>cavpts=None     If None, look for ring.cavpts, or otherwise take all</dt><dd><p>cavities.</p>
</dd>
<dt>array=False     If False, timelag is applied to the selected cavities</dt><dd><p>with the lowest frequency. The timelag of all the
other selected cavities is shifted by the same amount.
If True, directly apply timelag to the selected
cavities. The value must be broadcastable to the number
of cavities.</p>
</dd>
<dt>copy=False      If True, returns a shallow copy of ring with new</dt><dd><p>cavity elements. Otherwise, modify ring in-place</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_rf_voltage">
<span class="sig-name descname"><span class="pre">set_rf_voltage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voltage</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_rf_voltage" title="Permalink to this definition"></a></dt>
<dd><p>Set the RF voltage for the full ring</p>
<dl class="simple">
<dt>PARAMETERS</dt><dd><p>ring            lattice description
voltage         RF voltage [V]</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>cavpts=None     If None, look for ring.cavpts, or otherwise take all</dt><dd><p>cavities.</p>
</dd>
<dt>array=False     If False, the voltages of all cavities are scaled to</dt><dd><p>reach the specified value on the selected cavities with
the lowest frequency.
If True, directly apply voltage to the selected
cavities. The value must be broadcastable to the number
of cavities.</p>
</dd>
<dt>copy=False      If True, returns a shallow copy of ring with new</dt><dd><p>cavity elements. Otherwise, modify ring in-place</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_shift">
<span class="sig-name descname"><span class="pre">set_shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dxs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dzs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_shift" title="Permalink to this definition"></a></dt>
<dd><p>Set translations to a list of elements.</p>
<p>ring            sequence of elements to be shifted
dxs             sequence of horizontal displacement as long as ring or</p>
<blockquote>
<div><p>scalar horizontal displacement applied to all elements</p>
</div></blockquote>
<dl class="simple">
<dt>dzs             sequence of vertical displacement as long as ring or</dt><dd><p>scalar vertical displacement applied to all elements</p>
</dd>
</dl>
<p>relative=False  Displacement relative to the previous alignment</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_tilt">
<span class="sig-name descname"><span class="pre">set_tilt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tilts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_tilt" title="Permalink to this definition"></a></dt>
<dd><p>Set tilts to a list of elements.</p>
<p>ring            sequence of elements to be tilted
tilts           sequence of tilt values as long as ring or</p>
<blockquote>
<div><p>scalar tilt value applied to all elements</p>
</div></blockquote>
<p>relative=False  Rotation relative to the previous tilt angle</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_value_refpts">
<span class="sig-name descname"><span class="pre">set_value_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">increment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_value_refpts" title="Permalink to this definition"></a></dt>
<dd><p>Set the values of an attribute of an array of elements based on
their refpts</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>description</strong> (<em>ring            Lattice</em>) – </p></li>
<li><p><strong>Integer</strong> (<em>refpts</em>) – </p></li>
<li><p><strong>booleans</strong> (<em>array of integer or</em>) – </p></li>
<li><p><strong>filter</strong> – </p></li>
<li><p><strong>name</strong> (<em>var             attribute</em>) – </p></li>
<li><p><strong>attribute</strong> (<em>values          desired value for the</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>KEYWORDS:</dt><dd><dl class="simple">
<dt>index=None      index of the value to change if var is an array.</dt><dd><p>If None the full array is replaced by value (Default)</p>
</dd>
<dt>increment=False Add values to the initial values.</dt><dd><p>If False the initial value is replaced (Default)</p>
</dd>
<dt>copy=False      If False, do the modification in-place.</dt><dd><p>If True, returns a shallow copy of ring with new
modified elements.
CAUTION: a shallow copy means that all non-affected
elements are shared with the original lattice.
Any further modification will affect in both lattices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.slice">
<span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.slice" title="Permalink to this definition"></a></dt>
<dd><p>Create a new lattice by slicing the range of interest into small
elements</p>
<dl class="simple">
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>size=None       Length of a slice. Default: computed from the</dt><dd><dl class="simple">
<dt>range and number of points:</dt><dd><p>sx = (s_max-s_min)/slices.</p>
</dd>
</dl>
</dd>
<dt>slices=1        Number of slices in the specified range. Ignored if</dt><dd><p>size is specified. Default: no slicing</p>
</dd>
</dl>
</dd>
<dt>RETURN</dt><dd><p>New Lattice object</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.slip_factor">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">slip_factor</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.slip_factor" title="Permalink to this definition"></a></dt>
<dd><p>Slip factor</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.tapering">
<span class="sig-name descname"><span class="pre">tapering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">multipoles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.tapering" title="Permalink to this definition"></a></dt>
<dd><p>Scales magnet strength with local energy to cancel the closed orbit
and optics errors due to synchrotron radiations. PolynomB is used for
dipoles such that the machine geometry is maintained. This is the ideal
tapering scheme where magnets and multipoles components (PolynomB and
PolynomA) are scaled individually.
!!! WARNING: This method works only for lattices without errors and
corrections: if not all corrections and field errors will also be
scaled !!!
tapering(ring) or ring.tapering()
PARAMETERS</p>
<blockquote>
<div><p>ring            lattice description.</p>
</div></blockquote>
<dl>
<dt>KEYWORDS</dt><dd><p>multipoles=True scale all multipoles
method          Method for energy loss computation</p>
<blockquote>
<div><p>(see get_energy_loss)</p>
</div></blockquote>
<p>niter=1         number of iteration
XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of orbit6</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.uint32_refpts">
<span class="sig-name descname"><span class="pre">uint32_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.uint32_refpts" title="Permalink to this definition"></a></dt>
<dd><p>“Return a uint32 numpy array containing the indices of the selected
elements. refpts may be:</p>
<ol class="arabic simple">
<li><p>a integer or a sequence of integers (0 indicating the first element)</p></li>
<li><p>a sequence of booleans marking the selected elements</p></li>
<li><p>a callable f such that f(elem) is True for selected elements</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the element attributes with the given arguments</p>
<p>update(<a href="#id51"><span class="problematic" id="id52">**</span></a>kwargs)
update(mapping, <a href="#id53"><span class="problematic" id="id54">**</span></a>kwargs)
update(iterable, <a href="#id55"><span class="problematic" id="id56">**</span></a>kwargs)</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.lattice_object.lattice_filter">
<span class="sig-prename descclassname"><span class="pre">at.lattice.lattice_object.</span></span><span class="sig-name descname"><span class="pre">lattice_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lattice</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.lattice_filter" title="Permalink to this definition"></a></dt>
<dd><p>Copy lattice parameters and run through all lattice elements</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.lattice_object.no_filter">
<span class="sig-prename descclassname"><span class="pre">at.lattice.lattice_object.</span></span><span class="sig-name descname"><span class="pre">no_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elems</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.no_filter" title="Permalink to this definition"></a></dt>
<dd><p>Run through all elements without any check</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.lattice_object.params_filter">
<span class="sig-prename descclassname"><span class="pre">at.lattice.lattice_object.</span></span><span class="sig-name descname"><span class="pre">params_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elem_iterator</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.params_filter" title="Permalink to this definition"></a></dt>
<dd><p>Run through all elements, looking for energy and periodicity.
Remove the Energy attribute of non-radiating elements</p>
<dl class="simple">
<dt>energy is taken from:</dt><dd><ol class="arabic simple">
<li><p>The params dictionary</p></li>
<li><p>Cavity elements</p></li>
<li><p>Any other element</p></li>
</ol>
</dd>
<dt>periodicity is taken from:</dt><dd><ol class="arabic simple">
<li><p>The params dictionary</p></li>
<li><p>Sum of the bending angles of magnets</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.lattice_object.type_filter">
<span class="sig-prename descclassname"><span class="pre">at.lattice.lattice_object.</span></span><span class="sig-name descname"><span class="pre">type_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elem_iterator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.type_filter" title="Permalink to this definition"></a></dt>
<dd><p>Run through all elements and check element validity.
Analyse elements for radiation state</p>
</dd></dl>

</section>
<section id="module-at.lattice.options">
<span id="at-lattice-options-module"></span><h2>at.lattice.options module<a class="headerlink" href="#module-at.lattice.options" title="Permalink to this headline"></a></h2>
<p>Global set of constants</p>
</section>
<section id="module-at.lattice.particle_object">
<span id="at-lattice-particle-object-module"></span><h2>at.lattice.particle_object module<a class="headerlink" href="#module-at.lattice.particle_object" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.particle_object.Particle">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.particle_object.</span></span><span class="sig-name descname"><span class="pre">Particle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'relativistic'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.particle_object.Particle" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Particle object</p>
<p>This object defines the properties of the particles circulating in a ring</p>
<p>Particle(name, <a href="#id57"><span class="problematic" id="id58">**</span></a>params)</p>
<dl class="simple">
<dt>PARAMETERS</dt><dd><dl class="simple">
<dt>name        Particle name. ‘electron’, ‘positron and ‘proton’ are</dt><dd><p>predefined. For other particles, the rest energy and charge
must be provided as keywords.</p>
</dd>
</dl>
</dd>
<dt>KEYWORDS</dt><dd><p>rest_energy Particle rest energy [ev]
charge      Particle charge [elementary charge]
*           Other keywords will be set as attributes of the particle</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.particle_object.Particle.charge">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">charge</span></span><a class="headerlink" href="#at.lattice.particle_object.Particle.charge" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.particle_object.Particle.rest_energy">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rest_energy</span></span><a class="headerlink" href="#at.lattice.particle_object.Particle.rest_energy" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.particle_object.Particle.to_dict">
<span class="sig-name descname"><span class="pre">to_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.particle_object.Particle.to_dict" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-at.lattice.utils">
<span id="at-lattice-utils-module"></span><h2>at.lattice.utils module<a class="headerlink" href="#module-at.lattice.utils" title="Permalink to this headline"></a></h2>
<p>Helper functions for working with AT lattices.</p>
<p>A lattice as understood by pyAT is any sequence of elements.  These functions
are useful for working with these sequences.</p>
<p>The refpts allow functions to select points in the lattice, returned values are
given at the entrance of each element specified in refpts;
refpts can be:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>an integer in the range [-len(ring), len(ring)-1] selecting the element</dt><dd><p>according to python indexing rules. As a special case, len(ring) is
allowed and refers to the end of the last element,</p>
</dd>
</dl>
</li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><dl class="simple">
<dt>a numpy array of booleans of maximum length len(ring)+1, where selected</dt><dd><p>elements are True.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="py exception">
<dt class="sig sig-object py" id="at.lattice.utils.AtError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">AtError</span></span><a class="headerlink" href="#at.lattice.utils.AtError" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="at.lattice.utils.AtWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">AtWarning</span></span><a class="headerlink" href="#at.lattice.utils.AtWarning" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">UserWarning</span></code></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.bool_refpts">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">bool_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_elements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.bool_refpts" title="Permalink to this definition"></a></dt>
<dd><p>Return a boolean numpy array of length n_elements + 1 where True elements
are selected. This is used for indexing a lattice using True or False
values.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.check_radiation">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">check_radiation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rad</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.check_radiation" title="Permalink to this definition"></a></dt>
<dd><p>Function to be used as a decorator for optics functions</p>
<dl class="simple">
<dt>If ring is a Lattice object, raises an exception</dt><dd><p>if ring.radiation is not rad</p>
</dd>
</dl>
<p>If ring is any other sequence, no test is performed</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.checkattr">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">checkattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.checkattr" title="Permalink to this definition"></a></dt>
<dd><p>Return a function to be used as a filter. Check the presence or the
value of an attribute. This function can be used to extract from a ring
all elements have a given attribute.</p>
<dl class="simple">
<dt>filtfunc = checkattr(attrname)</dt><dd><p>returns the function filtfunc such that ok=filtfunc(element) is True if
the element has a ‘attrname’ attribute</p>
</dd>
<dt>filtfunc = checkattr(attrname, attrvalue)</dt><dd><p>returns the function filtfunc such that ok=filtfunc(element) is True if
the element has a ‘attrname’ attribute with the value attrvalue</p>
</dd>
</dl>
<p>Examples:</p>
<dl class="simple">
<dt>cavs = filter(checkattr(‘Frequency’), ring)</dt><dd><p>returns an iterator over all elements in ring that have a
‘Frequency’ attribute</p>
</dd>
<dt>elts = filter(checkattr(‘K’, 0.0), ring)</dt><dd><p>returns an iterator over all elements in ring that have a ‘K’
attribute equal to 0.0</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.checkname">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">checkname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.checkname" title="Permalink to this definition"></a></dt>
<dd><p>Return a function to be used as a filter. Check the name of an element.
This function can be used to extract from a ring all elements have a
given FamName attribute.</p>
<dl class="simple">
<dt>filtfunc = checkname(pattern)</dt><dd><p>returns the function filtfunc such that ok=filtfunc(element) is True
if the element’s FamName matches pattern.</p>
</dd>
</dl>
<p>Example:</p>
<dl class="simple">
<dt>qps = filter(checkname(‘QF.*’), ring)</dt><dd><p>returns an iterator over all elements</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.checktype">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">checktype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eltype</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.checktype" title="Permalink to this definition"></a></dt>
<dd><p>Return a function to be used as a filter. Check the type of an element.
This function can be used to extract from a ring all elements have a
given type.</p>
<dl class="simple">
<dt>filtfunc = checktype(class)</dt><dd><p>returns the function filtfunc such that ok=filtfunc(element) is True
if the element is an instance of class</p>
</dd>
</dl>
<p>Example:</p>
<dl class="simple">
<dt>qps = filter(checktype(at.Quadrupole), ring)</dt><dd><p>returns an iterator over all quadrupoles in ring</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.get_cells">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">get_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.get_cells" title="Permalink to this definition"></a></dt>
<dd><p>Return a numpy array of booleans, with the same length as ring,
marking all elements satisfying a given condition.</p>
<dl class="simple">
<dt>refpts = getcells(ring, filtfunc)</dt><dd><p>selects all elements for which the function filtfunc(element)
returns True</p>
</dd>
<dt>refpts = getcells(ring, attrname)</dt><dd><p>selects all elements having a ‘attrname’ attribute</p>
</dd>
<dt>refpts = getcells(ring, attrname, attrvalue)</dt><dd><p>selects all elements having a ‘attrname’ attribute with value attrvalue</p>
</dd>
</dl>
<p>Example:</p>
<dl class="simple">
<dt>refpts = getcells(ring, ‘Frequency’)</dt><dd><p>returns a numpy array of booleans where all elements having a
‘Frequency’ attribute are True</p>
</dd>
<dt>refpts = getcells(ring, ‘K’, 0.0)</dt><dd><p>returns a numpy array of booleans where all elements having a ‘K’
attribute equal to 0.0 are True</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.get_elements">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">get_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quiet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.get_elements" title="Permalink to this definition"></a></dt>
<dd><p>Get the elements of a family or class (type) from the lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> – lattice from which to retrieve the elements.</p></li>
<li><p><strong>key</strong> – <p>can be:
1) an element instance, will return all elements of the same type</p>
<blockquote>
<div><p>in the lattice, e.g. key=Drift(‘d1’, 1.0)</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>an element type, will return all elements of that type in the
lattice, e.g. key=at.elements.Sextupole</p></li>
<li><p>a string to match against elements’ FamName, supports Unix
shell-style wildcards, e.g. key=’BPM_*1’</p></li>
</ol>
</p></li>
<li><p><strong>quiet</strong> – if false print information about matched elements for FamName
matches, defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of elems matching key</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.get_refpts">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">get_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quiet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.get_refpts" title="Permalink to this definition"></a></dt>
<dd><p>Get the elements refpts of a family or class (type) from the lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> – lattice from which to retrieve the elements.</p></li>
<li><p><strong>key</strong> – <p>can be:
1) an element instance, will return all elements of the same type</p>
<blockquote>
<div><p>in the lattice, e.g. key=Drift(‘d1’, 1.0)</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>an element type, will return all elements of that type in the
lattice, e.g. key=at.elements.Sextupole</p></li>
<li><p>a string to match against elements’ FamName, supports Unix
shell-style wildcards, e.g. key=’BPM_*1’</p></li>
</ol>
</p></li>
<li><p><strong>quiet</strong> – if false print information about matched elements for FamName
matches, defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of elems refpts matching key</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>elems</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.get_s_pos">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">get_s_pos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.get_s_pos" title="Permalink to this definition"></a></dt>
<dd><p>Return a numpy array corresponding to the s position of the specified
elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> – lattice from which to retrieve s position</p></li>
<li><p><strong>refpts</strong> – elements at which to return s position. If None, return
s position at all elements in the ring.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.get_value_refpts">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">get_value_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.get_value_refpts" title="Permalink to this definition"></a></dt>
<dd><p>Get the values of an attribute of an array of elements based on
their refpts</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>description</strong> (<em>ring            Lattice</em>) – </p></li>
<li><p><strong>Integer</strong> (<em>refpts</em>) – </p></li>
<li><p><strong>booleans</strong> (<em>array of integer or</em>) – </p></li>
<li><p><strong>filter</strong> – </p></li>
<li><p><strong>name</strong> (<em>var             attribute</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>KEYWORDS:</dt><dd><dl class="simple">
<dt>index=None      index of the value to retrieve if var is an array.</dt><dd><p>If None the full array is retrieved (Default)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.make_copy">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">make_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">copy</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.make_copy" title="Permalink to this definition"></a></dt>
<dd><p>Function to be used as a decorator for optics functions
The decorated function must be defined as:</p>
<dl class="simple">
<dt>def func(ring, refpts, <a href="#id59"><span class="problematic" id="id60">*</span></a>args, <a href="#id61"><span class="problematic" id="id62">**</span></a>kwargs):</dt><dd><p>…
return</p>
</dd>
</dl>
<p>If copy is False, the function is not modified,
If copy is True, a shallow copy of ring is done, then the elements selected
by refpts are deep-copied, then func is applied to the copy, and the new
ring is returned.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.refpts_count">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">refpts_count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_elements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.refpts_count" title="Permalink to this definition"></a></dt>
<dd><p>Number of reference points</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.refpts_iterator">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">refpts_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.refpts_iterator" title="Permalink to this definition"></a></dt>
<dd><p>Return an iterator over all elements in ring identified by refpts.</p>
<p>refpts may be:</p>
<ol class="arabic simple">
<li><p>a integer or a sequence of integers (0 indicating the first element)</p></li>
<li><p>a sequence of booleans marking the selected elements</p></li>
<li><p>a callable f such that f(elem) is True for selected elements</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.refpts_len">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">refpts_len</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.refpts_len" title="Permalink to this definition"></a></dt>
<dd><p>Number of reference points</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.set_radiation">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">set_radiation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rad</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.set_radiation" title="Permalink to this definition"></a></dt>
<dd><p>Function to be used as a decorator for optics functions
The decorated function must be defined as:</p>
<dl class="simple">
<dt>def func(ring, <a href="#id63"><span class="problematic" id="id64">*</span></a>args, <a href="#id65"><span class="problematic" id="id66">**</span></a>kwargs):</dt><dd><p>…
return</p>
</dd>
</dl>
<p>func will be called with a copy of the ring such that its radiation state
is set to rad (no copy is done if it’s already the case).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.set_shift">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">set_shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dxs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dzs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.set_shift" title="Permalink to this definition"></a></dt>
<dd><p>Set translations to a list of elements.</p>
<p>ring            sequence of elements to be shifted
dxs             sequence of horizontal displacement as long as ring or</p>
<blockquote>
<div><p>scalar horizontal displacement applied to all elements</p>
</div></blockquote>
<dl class="simple">
<dt>dzs             sequence of vertical displacement as long as ring or</dt><dd><p>scalar vertical displacement applied to all elements</p>
</dd>
</dl>
<p>relative=False  Displacement relative to the previous alignment</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.set_tilt">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">set_tilt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tilts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.set_tilt" title="Permalink to this definition"></a></dt>
<dd><p>Set tilts to a list of elements.</p>
<p>ring            sequence of elements to be tilted
tilts           sequence of tilt values as long as ring or</p>
<blockquote>
<div><p>scalar tilt value applied to all elements</p>
</div></blockquote>
<p>relative=False  Rotation relative to the previous tilt angle</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.set_value_refpts">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">set_value_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">increment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.set_value_refpts" title="Permalink to this definition"></a></dt>
<dd><p>Set the values of an attribute of an array of elements based on
their refpts</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>description</strong> (<em>ring            Lattice</em>) – </p></li>
<li><p><strong>Integer</strong> (<em>refpts</em>) – </p></li>
<li><p><strong>booleans</strong> (<em>array of integer or</em>) – </p></li>
<li><p><strong>filter</strong> – </p></li>
<li><p><strong>name</strong> (<em>var             attribute</em>) – </p></li>
<li><p><strong>attribute</strong> (<em>values          desired value for the</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>KEYWORDS:</dt><dd><dl class="simple">
<dt>index=None      index of the value to change if var is an array.</dt><dd><p>If None the full array is replaced by value (Default)</p>
</dd>
<dt>increment=False Add values to the initial values.</dt><dd><p>If False the initial value is replaced (Default)</p>
</dd>
<dt>copy=False      If False, do the modification in-place.</dt><dd><p>If True, returns a shallow copy of ring with new
modified elements.
CAUTION: a shallow copy means that all non-affected
elements are shared with the original lattice.
Any further modification will affect in both lattices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.shift_elem">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">shift_elem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltaz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.shift_elem" title="Permalink to this definition"></a></dt>
<dd><p>set a new displacement vector to an element.
The ranslation vectors are stored in the T1 and T2 attributes</p>
<p>elem            element to be displaced
deltax          horizontal displacement of the element
deltaz          vertical displacement of the element
relative=False  Displacement relative to the previous alignment</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.tilt_elem">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">tilt_elem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rots</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.tilt_elem" title="Permalink to this definition"></a></dt>
<dd><p>set a new tilt angle to an element.
The rotation matrices are stored in the R1 and R2 attributes</p>
<dl class="simple">
<dt>R1 = [[ cos(rots) sin(rots)]    R2 = [[cos(rots) -sin(rots)]</dt><dd><p>[-sin(rots) cos(rots)]]         [sin(rots)  cos(rots)]]</p>
</dd>
</dl>
<p>elem            element to be tilted
rots            tilt angle (in radians).</p>
<blockquote>
<div><p>rots &gt; 0 corresponds to a corkskew rotation of the element
looking in the direction of the beam</p>
</div></blockquote>
<p>relative=False  Rotation relative to the previous element rotation</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.utils.uint32_refpts">
<span class="sig-prename descclassname"><span class="pre">at.lattice.utils.</span></span><span class="sig-name descname"><span class="pre">uint32_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_elements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.utils.uint32_refpts" title="Permalink to this definition"></a></dt>
<dd><p>Return a uint32 numpy array with contents as the indices of the selected
elements.  This is used for indexing a lattice using explicit indices.</p>
</dd></dl>

</section>
<section id="module-at.lattice">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-at.lattice" title="Permalink to this headline"></a></h2>
<p>Helper functions for working with AT lattices.</p>
<p>A lattice as understood by pyAT is any sequence of elements.  These functions
are useful for working with these sequences.</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, ATCollab.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>