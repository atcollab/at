
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>at.lattice.lattice_object &#8212; pyAT 0.2.3 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom_at.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="at.lattice.options" href="at.lattice.options.html" />
    <link rel="prev" title="at.lattice.elements" href="at.lattice.elements.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../index.html">
  <img src="../../_static/AT.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="../index.html">
  Python
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../mlink.html">
  Matlab
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../pabout.html">
  About
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/atcollab/at" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting started:
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../getting_started.html">
   pyAT
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  How to:
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../howto/Installation.html">
   Installation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../howto/Primer.html">
   PyAT Primer
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../howto/CavityControl.html">
   Cavity Control
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../howto/Collective.html">
   Collective
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Packages:
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="at.acceptance.html">
   at.acceptance
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="at.acceptance.acceptance.html">
     at.acceptance.acceptance
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.acceptance.boundary.html">
     at.acceptance.boundary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.acceptance.touschek.html">
     at.acceptance.touschek
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="at.collective.html">
   at.collective
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="at.collective.haissinski.html">
     at.collective.haissinski
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.collective.wake_elements.html">
     at.collective.wake_elements
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.collective.wake_functions.html">
     at.collective.wake_functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.collective.wake_object.html">
     at.collective.wake_object
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="at.lattice.html">
   at.lattice
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="at.lattice.cavity_access.html">
     at.lattice.cavity_access
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.lattice.elements.html">
     at.lattice.elements
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     at.lattice.lattice_object
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.lattice.options.html">
     at.lattice.options
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.lattice.particle_object.html">
     at.lattice.particle_object
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.lattice.utils.html">
     at.lattice.utils
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="at.load.html">
   at.load
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="at.load.allfiles.html">
     at.load.allfiles
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.load.elegant.html">
     at.load.elegant
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.load.matfile.html">
     at.load.matfile
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.load.reprfile.html">
     at.load.reprfile
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.load.tracy.html">
     at.load.tracy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.load.utils.html">
     at.load.utils
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="at.matching.html">
   at.matching
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="at.matching.globalfit.html">
     at.matching.globalfit
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.matching.matching.html">
     at.matching.matching
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="at.physics.html">
   at.physics
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="at.physics.amat.html">
     at.physics.amat
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.physics.diffmatrix.html">
     at.physics.diffmatrix
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.physics.energy_loss.html">
     at.physics.energy_loss
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.physics.fastring.html">
     at.physics.fastring
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.physics.harmonic_analysis.html">
     at.physics.harmonic_analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.physics.linear.html">
     at.physics.linear
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.physics.matrix.html">
     at.physics.matrix
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.physics.nonlinear.html">
     at.physics.nonlinear
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.physics.orbit.html">
     at.physics.orbit
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.physics.radiation.html">
     at.physics.radiation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.physics.revolution.html">
     at.physics.revolution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.physics.ring_parameters.html">
     at.physics.ring_parameters
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="at.plot.html">
   at.plot
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="at.plot.generic.html">
     at.plot.generic
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.plot.specific.html">
     at.plot.specific
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.plot.standalone.html">
     at.plot.standalone
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.plot.synopt.html">
     at.plot.synopt
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="at.tracking.html">
   at.tracking
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="at.tracking.atpass.html">
     at.tracking.atpass
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.tracking.particles.html">
     at.tracking.particles
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.tracking.patpass.html">
     at.tracking.patpass
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="at.tracking.track.html">
     at.tracking.track
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="at.constants.html">
   at.constants
  </a>
 </li>
</ul>

  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                

<nav id="bd-toc-nav">
    
</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="module-at.lattice.lattice_object">
<span id="at-lattice-lattice-object"></span><h1>at.lattice.lattice_object<a class="headerlink" href="#module-at.lattice.lattice_object" title="Permalink to this headline">#</a></h1>
<p>Lattice object</p>
<p>The methods implemented in this module are internal to the ‘lattice’ package.
This is necessary to ensure that the ‘lattice’ package is independent of other
AT packages.</p>
<p>Other Lattice methods are implemented in other AT packages and are available
as soon as the package is imported. The ‘tracking’ and ‘physics’ packages are
automatically imported.</p>
<p>As an example, see the at.physics.orbit module</p>
<p class="rubric">Functions</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#at.lattice.lattice_object.type_filter" title="at.lattice.lattice_object.type_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">type_filter</span></code></a>(params, elems)</p></td>
<td><p>Run through all elements and check element validity.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#at.lattice.lattice_object.params_filter" title="at.lattice.lattice_object.params_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">params_filter</span></code></a>(params, elem_filter, *args)</p></td>
<td><p>Run through all elements, looking for energy and periodicity.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#at.lattice.lattice_object.lattice_filter" title="at.lattice.lattice_object.lattice_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lattice_filter</span></code></a>(params, lattice)</p></td>
<td><p>Copy lattice parameters and run through all lattice elements</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#at.lattice.lattice_object.no_filter" title="at.lattice.lattice_object.no_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">no_filter</span></code></a>(params, elems)</p></td>
<td><p>Run through all elements without any check</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Classes</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#at.lattice.lattice_object.Lattice" title="at.lattice.lattice_object.Lattice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lattice</span></code></a>()</p></td>
<td><p>Lattice object</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Lattice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elements</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice" title="Permalink to this definition">#</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Lattice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter</span></span></em>, <span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">iterator=iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**params</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.10)"><span class="pre">None</span></a></span></span></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a></p>
<p>Lattice object</p>
<p>An AT lattice is a sequence of AT elements which accepts extended indexing
(as a numpy ndarray). It has the following attributes:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.name" title="Permalink to this definition">#</a></dt>
<dd><p>Name of the lattice</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.energy">
<span class="sig-name descname"><span class="pre">energy</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.energy" title="Permalink to this definition">#</a></dt>
<dd><p>Particle energy</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.periodicity">
<span class="sig-name descname"><span class="pre">periodicity</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.periodicity" title="Permalink to this definition">#</a></dt>
<dd><p>Number of super-periods to describe the full ring</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.particle">
<span class="sig-name descname"><span class="pre">particle</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.particle" title="Permalink to this definition">#</a></dt>
<dd><p>Circulating particle</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.harmonic_number">
<span class="sig-name descname"><span class="pre">harmonic_number</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.harmonic_number" title="Permalink to this definition">#</a></dt>
<dd><p>Harmonic number of the full ring (periodicity x cells)</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>elements</strong> – iterable of Element objects</p></li>
<li><p><strong>iter</strong> – function called as <code class="docutils literal notranslate"><span class="pre">iter(params,</span> <span class="pre">*args)</span></code>. It must return an
iterable of Element objects for building the lattice. It must
also fill the``params`` dictionary providing the Lattice
attributes.</p></li>
<li><p><strong>params</strong> – dictionary of lattice parameters. A custom iterator may add,
remove or modify parameters. Finally, the remaining
parameters will be set as Lattice attributes.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>name=''</strong> – Name of the lattice</p></li>
<li><p><strong>energy</strong> – Energy of the lattice</p></li>
<li><p><strong>periodicity=1</strong> – Number of periods</p></li>
<li><p><strong>particle='relativistic'</strong> – circulating particle. May be
‘relativistic’, ‘electron’, ‘positron’, ‘proton’
or a Particle object</p></li>
<li><p><strong>iterator=None</strong> – custom iterator (see below)</p></li>
<li><p><strong>*</strong> – all other keywords will be set as attributes of
the Lattice object</p></li>
</ul>
</dd>
</dl>
<p>An iterator <code class="docutils literal notranslate"><span class="pre">it</span></code> is called as <code class="docutils literal notranslate"><span class="pre">it(params,</span> <span class="pre">*args)</span></code> where <code class="docutils literal notranslate"><span class="pre">args</span></code>
and <code class="docutils literal notranslate"><span class="pre">params</span></code> are the arguments of the <code class="docutils literal notranslate"><span class="pre">Lattice</span></code> constructor. It must
yield the AT <code class="docutils literal notranslate"><span class="pre">Elements</span></code> for building the lattice. It must also fill
its <code class="docutils literal notranslate"><span class="pre">params</span></code> dictionary argument, which will be used to set the
<code class="docutils literal notranslate"><span class="pre">Lattice</span></code> attributes.
An iterator can be:</p>
<ul class="simple">
<li><p>a “generator” which yields elements from scratch.
Examples: a list, or a file iterator,</p></li>
<li><p>a “filter” which runs through an input iterator, processes each
element, possibly adds parameters to the params dictionary
and yields the processed elements.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To reduce the inter-package dependencies, some methods of the
lattice object are defined in other AT packages, in the module where
the underlying function is implemented.</p>
</div>
<p class="rubric">Examples</p>
<p>Chaining iterators (taken from <code class="docutils literal notranslate"><span class="pre">load_mat</span></code>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Lattice</span><span class="p">(</span><span class="n">ringparam_filter</span><span class="p">,</span> <span class="n">matfile_generator</span><span class="p">,</span> <span class="n">filename</span>
        <span class="n">iterator</span><span class="o">=</span><span class="n">params_filter</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">matfile_generator(params,</span> <span class="pre">filename)</span></code></dt><dd><p>opens filename and generates AT elements for each cell of the
Matlab cell array representing the lattice,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ringparam_filter(params,</span> <span class="pre">matfile_generator,</span> <span class="pre">*args)</span></code></dt><dd><p>runs through <code class="docutils literal notranslate"><span class="pre">matfile_generator(params,</span> <span class="pre">*args)</span></code>, looks for
RingParam elements, fills params with their information and
discards them,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">params_filter(params,</span> <span class="pre">ringparam_filter,</span> <span class="pre">*args)</span></code></dt><dd><p>runs through <code class="docutils literal notranslate"><span class="pre">ringparam_filter(params,</span> <span class="pre">*args)</span></code>, looks for
energy and periodicity if not yet defined.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.append" title="Permalink to this definition">#</a></dt>
<dd><p>Append object to the end of the list.</p>
<dl class="field-list simple">
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.attrs_filter">
<span class="sig-name descname"><span class="pre">attrs_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elems</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.attrs_filter" title="Permalink to this definition">#</a></dt>
<dd><p>Filter function which duplicates the lattice attributes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary of Lattice attributes</p></li>
<li><p><strong>elems</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Iterable" title="(in Python v3.10)"><em>Iterable</em></a><em>[</em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>]</em>) – iterable of lattice <code class="docutils literal notranslate"><span class="pre">Elements</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>elems</strong> – <strong>elems</strong> unchanged</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.avlinopt">
<span class="sig-name descname"><span class="pre">avlinopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.avlinopt" title="Permalink to this definition">#</a></dt>
<dd><p>Perform linear analysis of a lattice and returns average
beta, dispersion and phase advance</p>
<p>lindata,avebeta,avemu,avedisp,tune,chrom = avlinopt(lattice, dp, refpts)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
dp=0.0          momentum deviation.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-8   momentum deviation used for computation of</p>
<blockquote>
<div><p>chromaticities and dispersion</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>lindata         linear optics at the points refered to by refpts, if</dt><dd><p>refpts is None an empty lindata structure is returned.
See linopt4 for details</p>
</dd>
</dl>
<p>avebeta         Average beta functions [betax,betay] at refpts
avemu           Average phase advances [mux,muy] at refpts
avedisp         Average dispersion [Dx,Dx’,Dy,Dy’] at refpts
avespos         Average s position at refpts
tune            [tune_A, tune_B], linear tunes for the two normal modes</p>
<blockquote>
<div><p>of linear motion [1]</p>
</div></blockquote>
<p>chrom           [ksi_A , ksi_B], chromaticities ksi = d(nu)/(dP/P).</p>
</dd>
</dl>
<p>See also linopt4, get_optics</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.bool_refpts">
<span class="sig-name descname"><span class="pre">bool_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.bool_refpts" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a bool array of element indices, selecting ring elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>refpts</strong> (<em>Refpts</em>) – <p>refpts may be:</p>
<ol class="arabic simple">
<li><p>an integer or a sequence of integers
(0 indicating the first element)</p></li>
<li><p>a sequence of booleans marking the selected elements</p></li>
<li><p>a callable <code class="docutils literal notranslate"><span class="pre">filtfunc</span></code> such that <code class="docutils literal notranslate"><span class="pre">filtfunc(elem)</span></code> is True for
selected elements</p></li>
</ol>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>bool_refs</strong> (<em>BoolRefpts</em>) – A bool numpy array used for indexing
<code class="docutils literal notranslate"><span class="pre">Elements</span></code> in a lattice.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a shallow copy of the lattice</p>
<dl class="field-list simple">
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.deepcopy">
<span class="sig-name descname"><span class="pre">deepcopy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.deepcopy" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a deep copy of the lattice</p>
<dl class="field-list simple">
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.envelope_parameters">
<span class="sig-name descname"><span class="pre">envelope_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.envelope_parameters" title="Permalink to this definition">#</a></dt>
<dd><p>Compute ring parameters from ohmi_envelope</p>
<dl>
<dt>INPUT</dt><dd><p>ring            Lattice object.</p>
</dd>
<dt>KEYWORD</dt><dd><p>params=None     RingParam object to be updated.</p>
</dd>
<dt>OUTPUT</dt><dd><p>params          RingParam object. The computed attributes are,</p>
<blockquote>
<div><p>tunes6          (3,) fractional (H, V, Long.) tunes (6D motion)
emittances      (3,) Mode emittances
J               (3,) Damping partition numbers
Tau             (3,) Damping times [s]
sigma_e         Energy spread
sigma_l         Bunch length [m]
voltage         Total accelerating voltage [V]
phi_s           Synchrotron phase [rad]
f_s             Synchrotron frequency [Hz]</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elems</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.extend" title="Permalink to this definition">#</a></dt>
<dd><p>Extend list by appending elements from the iterable.</p>
<dl class="field-list simple">
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.find_m44">
<span class="sig-name descname"><span class="pre">find_m44</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.find_m44" title="Permalink to this definition">#</a></dt>
<dd><p>find_m44 numerically finds the 4x4 transfer matrix of an accelerator
lattice for a particle with relative momentum deviation DP</p>
<p>IMPORTANT!!! find_m44 assumes constant momentum deviation.
PassMethod used for any element in the lattice SHOULD NOT
1.  change the longitudinal momentum dP</p>
<blockquote>
<div><p>(cavities , magnets with radiation, …)</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>have any time dependence (localized impedance, fast kickers, …)</p></li>
</ol>
<dl>
<dt>m44, t = find_m44(lattice, dp=0.0, refpts)</dt><dd><p>return 4x4 transfer matrices between the entrance of the first element
and each element indexed by refpts.</p>
<blockquote>
<div><p>m44:    full one-turn matrix at the entrance of the first element
t:      4x4 transfer matrices between the entrance of the first</p>
<blockquote>
<div><p>element and each element indexed by refpts:
(Nrefs, 4, 4) array</p>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
<p>Unless an input orbit is introduced, find_m44 assumes that the lattice is
a ring and first finds the closed orbit.</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description
dp              momentum deviation. Defaults to 0
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for mstack.</p>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>dct=None        path lengthening. If specified, dp is ignored and</dt><dd><p>the off-momentum is deduced from the path lengthening.</p>
</dd>
<dt>orbit=None      avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>keep_lattice=False  When True, assume no lattice change since the</dt><dd><p>previous tracking.</p>
</dd>
<dt>full=False      When True, matrices are full 1-turn matrices at</dt><dd><p>the entrance of each
element indexed by refpts.</p>
</dd>
<dt>orbit=None      Avoids looking for the closed orbit if is already</dt><dd><p>known (6,) array</p>
</dd>
</dl>
<p>XYStep=1.e-8    transverse step for numerical computation</p>
</dd>
</dl>
<p>See also find_m66, find_orbit4</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.find_m66">
<span class="sig-name descname"><span class="pre">find_m66</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.find_m66" title="Permalink to this definition">#</a></dt>
<dd><p>find_m66 numerically finds the 6x6 transfer matrix of an accelerator
lattice by differentiation of lattice_pass near the closed orbit.
find_m66 uses find_orbit6 to search for the closed orbit in 6-D
In order for this to work the ring MUST have a CAVITY element</p>
<dl>
<dt>m66, t = find_m66(lattice, refpts)</dt><dd><dl class="simple">
<dt>m66:    full one-turn 6-by-6 matrix at the entrance of the</dt><dd><p>first element.</p>
</dd>
<dt>t:      6x6 transfer matrices between the entrance of the first</dt><dd><p>element and each element indexed by refpts (nrefs, 6, 6) array.</p>
</dd>
</dl>
</dd>
<dt>PARAMETERS</dt><dd><p>ring            lattice description
dp              momentum deviation. Defaults to 0
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for mstack.</p>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>keep_lattice=False  When True, assume no lattice change since the</dt><dd><p>previous tracking.</p>
</dd>
<dt>orbit=None          Avoids looking for the closed orbit if is already</dt><dd><p>known (6,) array</p>
</dd>
</dl>
<p>XYStep=1.e-8        transverse step for numerical computation</p>
</dd>
</dl>
<p>See also find_m44, find_orbit6</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.find_orbit">
<span class="sig-name descname"><span class="pre">find_orbit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.find_orbit" title="Permalink to this definition">#</a></dt>
<dd><p>find_orbit finds the closed orbit by numerically getting the fixed point
of the one turn map M calculated with lattice_pass.</p>
<p>Depending on the the lattice, find_orbit will:
- use find_orbit6 if ring.radiation is ON,
- use find_sync_orbit if ring.radiation is OFF and dct is specified,
- use find_orbit4 otherwise</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            Sequence of AT elements
refpts          elements at which data is returned.</p>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>orbit0          ((6,) closed orbit vector at the entrance of the</dt><dd><p>1-st element</p>
</dd>
<dt>orbit           (6, Nrefs) closed orbit vector at each location</dt><dd><p>specified in refpts</p>
</dd>
</dl>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0            Momentum deviation, when radiation is OFF
dct=0            Path lengthening, when radiation ids OFF
keep_lattice    Assume no lattice change since the previous tracking.</p>
<blockquote>
<div><p>Default: False</p>
</div></blockquote>
<dl class="simple">
<dt>guess=None      Initial guess for the closed orbit. It may help</dt><dd><p>convergence.</p>
</dd>
<dt>orbit=None      Orbit at entrance of the lattice, if known. find_orbit</dt><dd><p>will then propagate it to the selected reference points</p>
</dd>
</dl>
<p>For other keywords, refer to the underlying methods</p>
</dd>
</dl>
<p>See also find_orbit4, find_sync_orbit, find_orbit6</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.find_orbit4">
<span class="sig-name descname"><span class="pre">find_orbit4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.find_orbit4" title="Permalink to this definition">#</a></dt>
<dd><p>findorbit4 finds the closed orbit in the 4-d transverse phase
space by numerically solving for a fixed point of the one turn
map M calculated with lattice_pass.</p>
<blockquote>
<div><p>(X, PX, Y, PY, dP, CT2 ) = M (X, PX, Y, PY, dP, CT1)</p>
</div></blockquote>
<p>under the CONSTANT MOMENTUM constraint dP and with NO constraint
on the 6-th coordinate CT</p>
<p>IMPORTANT!!! findorbit4 imposes a constraint on dP and relaxes
the constraint on the revolution frequency. A physical storage
ring does exactly the opposite: the momentum deviation of a
particle on the closed orbit settles at the value
such that the revolution is synchronous with the RF cavity</p>
<blockquote>
<div><p>HarmNumber*Frev = Frf</p>
</div></blockquote>
<p>To impose this artificial constraint in find_orbit4, PassMethod
used for any element SHOULD NOT
1.  change the longitudinal momentum dP (cavities , magnets with radiation)
2.  have any time dependence (localized impedance, fast kickers etc)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be OFF)
dp              momentum deviation. Defaults to 0
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for orbit.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>orbit0          ((6,) closed orbit vector at the entrance of the</dt><dd><p>1-st element (x,px,y,py)</p>
</dd>
<dt>orbit           (6, Nrefs) closed orbit vector at each location</dt><dd><p>specified in refpts</p>
</dd>
</dl>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>dct=None        path lengthening. If specified, dp is ignored and</dt><dd><p>the off-momentum is deduced from the path lengthening.</p>
</dd>
<dt>orbit=None      avoids looking for initial the closed orbit if is</dt><dd><p>already known ((6,) array). find_orbit4 propagates it
to the specified refpts.</p>
</dd>
<dt>guess           (6,) initial value for the closed orbit. It may help</dt><dd><p>convergence. Default: (0, 0, 0, 0, 0, 0)</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Default: False</p>
</dd>
</dl>
<p>convergence     Convergence criterion. Default: 1.e-12
max_iterations  Maximum number of iterations. Default: 20
XYStep          Step size. Default: DConstant.XYStep</p>
</dd>
</dl>
<p>See also find_sync_orbit, find_orbit6.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.find_orbit6">
<span class="sig-name descname"><span class="pre">find_orbit6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.find_orbit6" title="Permalink to this definition">#</a></dt>
<dd><p>find_orbit6 finds the closed orbit in the full 6-D phase space
by numerically solving  for a fixed point of the one turn
map M calculated with lattice_pass</p>
<p>(X, PX, Y, PY, DP, CT2 ) = M (X, PX, Y, PY, DP, CT1)</p>
<p>with constraint  CT2 - CT1 = C*HarmNumber(1/Frf - 1/Frf0)</p>
<p>IMPORTANT!!! find_orbit6 is a realistic simulation
1.  The Frf frequency in the RF cavities (may be different from Frf0)</p>
<blockquote>
<div><p>imposes the synchronous condition
CT2 - CT1 = C*HarmNumber(1/Frf - 1/Frf0)</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>The algorithm numerically calculates
6-by-6 Jacobian matrix J6. In order for (J-E) matrix
to be non-singular it is NECESSARY to use a realistic
PassMethod for cavities with non-zero momentum kick
(such as RFCavityPass).</p></li>
<li><p>find_orbit6 can find orbits with radiation.
In order for the solution to exist the cavity must supply
adequate energy compensation.
In the simplest case of a single cavity, it must have
‘Voltage’ field set so that Voltage &gt; Erad - energy loss per turn</p></li>
<li><p>There is a family of solutions that correspond to different RF buckets
They differ in the 6-th coordinate by C*Nb/Frf. Nb = 1 .. HarmNum-1</p></li>
<li><p>The value of the 6-th coordinate found at the cavity gives
the equilibrium RF phase. If there is no radiation the phase is 0;</p></li>
</ol>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be ON)
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for orbit.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>orbit0          ((6,) closed orbit vector at the entrance of the</dt><dd><p>1-st element (x,px,y,py)</p>
</dd>
<dt>orbit           (6, Nrefs) closed orbit vector at each location</dt><dd><p>specified in refpts</p>
</dd>
</dl>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit=None      avoids looking for initial the closed orbit if is</dt><dd><p>already known ((6,) array). find_orbit6 propagates it
to the specified refpts.</p>
</dd>
<dt>guess           Initial value for the closed orbit. It may help</dt><dd><p>convergence. The default is computed from the energy
loss of the ring</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Default: False</p>
</dd>
<dt>method          Method for energy loss computation</dt><dd><p>(see get_energy_loss)
default: ELossMethod.TRACKING</p>
</dd>
<dt>cavpts=None     Cavity location. If None, use all cavities.</dt><dd><p>This is used to compute the initial synchronous phase.</p>
</dd>
</dl>
<p>convergence     Convergence criterion. Default: 1.e-12
max_iterations  Maximum number of iterations. Default: 20
XYStep          Step size. Default: DConstant.XYStep
DPStep          Step size. Default: DConstant.DPStep</p>
</dd>
</dl>
<p>See also find_orbit4, find_sync_orbit.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.find_sync_orbit">
<span class="sig-name descname"><span class="pre">find_sync_orbit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.find_sync_orbit" title="Permalink to this definition">#</a></dt>
<dd><p>find_sync_orbit finds the closed orbit, synchronous with the RF cavity
and momentum deviation dP (first 5 components of the phase space vector)
% by numerically solving  for a fixed point
% of the one turn map M calculated with lattice_pass</p>
<blockquote>
<div><p>(X, PX, Y, PY, dP, CT2 ) = M (X, PX, Y, PY, dP, CT1)</p>
</div></blockquote>
<p>under the constraint dCT = CT2 - CT1 = C/Frev - C/Frev0, where
Frev0 = Frf0/HarmNumber is the design revolution frequency
Frev  = (Frf0 + dFrf)/HarmNumber is the imposed revolution frequency</p>
<p>IMPORTANT!!!  find_sync_orbit imposes a constraint (CT2 - CT1) and
dP2 = dP1 but no constraint on the value of dP1, dP2
The algorithm assumes time-independent fixed-momentum ring
to reduce the dimensionality of the problem.</p>
<p>To impose this artificial constraint in find_sync_orbit
PassMethod used for any element SHOULD NOT
1.  change the longitudinal momentum dP (cavities , magnets with radiation)
2.  have any time dependence (localized impedance, fast kickers etc).</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be OFF)
dct             Path length deviation. Default: 0
refpts          elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
<p>Defaults to None, if refpts is None an empty array is
returned for orbit.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>orbit0          ((6,) closed orbit vector at the entrance of the</dt><dd><p>1-st element (x,px,y,py)</p>
</dd>
<dt>orbit           (6, Nrefs) closed orbit vector at each location</dt><dd><p>specified in refpts</p>
</dd>
</dl>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit=None      avoids looking for initial the closed orbit if is</dt><dd><p>already known ((6,) array). find_sync_orbit propagates
it to the specified refpts.</p>
</dd>
<dt>guess           (6,) initial value for the closed orbit. It may help</dt><dd><p>convergence. Default: (0, 0, 0, 0, 0, 0)</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Default: False</p>
</dd>
</dl>
<p>convergence     Convergence criterion. Default: 1.e-12
max_iterations  Maximum number of iterations. Default: 20
XYStep          Step size. Default: DConstant.XYStep</p>
</dd>
</dl>
<p>See also find_orbit4, find_orbit6.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_acceptance">
<span class="sig-name descname"><span class="pre">get_acceptance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">planes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitudes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nturns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1024</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">GridMode.RADIAL</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_mp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">divider</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_zero</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_acceptance" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the acceptance at repfts observation points
Grid Coordiantes ordering is as follows: CARTESIAN: (x,y), RADIAL/RECURSIVE
(r, theta). Scalar inputs can be used for 1D grid.
The grid can be changed using grid_mode input:
at.GridMode.CARTESIAN: (x,y) grid
at.GridMode.RADIAL: (r,theta) grid
at.GridMode.RECURSIVE: (r,theta) recursive boundary search</p>
<p>Example usage:
bf,sf,gf = ring.get_acceptance(planes, npoints, amplitudes)
plt.plot(<a href="#id1"><span class="problematic" id="id2">*</span></a>gf,’.’)
plt.plot(<a href="#id3"><span class="problematic" id="id4">*</span></a>sf,’.’)
plt.plot(<a href="#id5"><span class="problematic" id="id6">*</span></a>bf)
plt.show()</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            ring use for tracking
planes          max. dimension 2, defines the plane where to search</p>
<blockquote>
<div><p>for the acceptance, allowed values are: x,xp,y,yp,dp,ct</p>
</div></blockquote>
<p>npoints         number of points in each dimension shape (len(planes),)
amplitudes      max. amplitude for RADIAL and CARTESIAN or initial step</p>
<blockquote>
<div><p>in RECURSIVE in each dimension. Shape is (len(planes),)
for RADIAL/RECURSIVE grid: amplitude = sqrt(x**2+y**2)</p>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><p>nturns=1024     Number of turns for the tracking
refpts=None     Observation refpts, default start of the machine
dp=None         static momentum offset
offset=None     initial orbit, default closed orbit
bounds=None     defines the tracked range: range=bounds*amplitude, it</p>
<blockquote>
<div><p>can be use to select quadrants for example
default values are:
GridMode.CARTESIAN: ((-1,1),(0,1))
GridMode.RADIAL/RECURSIVE: ((0,1),(pi,0))</p>
</div></blockquote>
<dl class="simple">
<dt>grid_mode       at.GridMode.CARTESIAN/RADIAL: track full vector</dt><dd><p>(default) at.GridMode.RECURSIVE: recursive search</p>
</dd>
<dt>use_mp=False    Use python multiprocessing (patpass, default use</dt><dd><p>lattice_pass). In case multi-processing is not
enabled GridMode is forced to
RECURSIVE (most efficient in single core)</p>
</dd>
</dl>
<p>divider=2       Value of the divider used in RECURSIVE boundary search
verbose=True    Print out some inform
start_method    This parameter allows to change the python</p>
<blockquote>
<div><p>multiprocessing start method, default=None uses the
python defaults that is considered safe.
Available parameters: ‘fork’, ‘spawn’, ‘forkserver’.
Default for linux is fork, default for MacOS and
Windows is spawn. fork may used for MacOS to speed-up
the calculation or to solve Runtime Errors, however
it is considered unsafe.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>Returns 3 numpy arrays with shape (2,n) (or lists of numpy arrays for
multiple refpts): the 2D acceptance , the full grid that was
tracked and the particles of the grid that survived. The length
of the lists=refpts. In case len(refpts)=1 the acceptance, grid,
survived arrays are returned directly.
The units depend on the selected planes and are the same as for the 6D
particle coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_bunch_length_espread">
<span class="sig-name descname"><span class="pre">get_bunch_length_espread</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bunch_curr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">espread</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_bunch_length_espread" title="Permalink to this definition">#</a></dt>
<dd><p>Haissinski equation solver</p>
<p>Solves the Haissinski formula and returns the bunch length and energy
spread for given bunch current and <span class="math notranslate nohighlight">\(Z/n\)</span>. If both <code class="docutils literal notranslate"><span class="pre">zn</span></code> and
<code class="docutils literal notranslate"><span class="pre">bunch_curr</span></code> are <code class="docutils literal notranslate"><span class="pre">None</span></code>, zero current case, otherwise both are needed
for the calculation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ring</strong> – ring use for tracking</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>zn=None</strong> – <span class="math notranslate nohighlight">\(Z/n\)</span> for the full ring</p></li>
<li><p><strong>bunch_curr=None</strong> – Bunch current</p></li>
<li><p><strong>espread=None</strong> – Energy spread, if <code class="docutils literal notranslate"><span class="pre">None</span></code> use lattice parameter</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>Bunch length, energy spread</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_cells">
<span class="sig-name descname"><span class="pre">get_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filtfunc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_cells" title="Permalink to this definition">#</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrname</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.10)"><span class="pre">None</span></a></span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrvalue</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.10)"><span class="pre">None</span></a></span></span></dt>
<dd><p>Returns a bool array of element indices, selecting ring elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> (<em>Sequence</em><em>[</em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>]</em>) – Lattice description</p></li>
<li><p><strong>filtfunc</strong> (<em>ElementFilter</em>) – Filter function. Selects <code class="docutils literal notranslate"><span class="pre">Elements</span></code>
satisfying the filter function</p></li>
<li><p><strong>attrname</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Attribute name</p></li>
<li><p><strong>attrvalue</strong> (<em>Any</em>) – Attribute value. If absent, select the
presence of an <code class="docutils literal notranslate"><span class="pre">attrname</span></code> attribute. If present, select
<code class="docutils literal notranslate"><span class="pre">Elements</span></code> with <code class="docutils literal notranslate"><span class="pre">attrname</span></code> == <code class="docutils literal notranslate"><span class="pre">attrvalue</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>bool_refs</strong> (<em>BoolRefpts</em>) – numpy Array of <code class="docutils literal notranslate"><span class="pre">bool</span></code> with the same
length as <code class="docutils literal notranslate"><span class="pre">ring</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">refpts</span> <span class="o">=</span> <span class="n">getcells</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns a numpy array of booleans where all elements having a
<code class="docutils literal notranslate"><span class="pre">Frequency</span></code> attribute are True</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">refpts</span> <span class="o">=</span> <span class="n">getcells</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns a numpy array of booleans where all elements having a <code class="docutils literal notranslate"><span class="pre">K</span></code>
attribute equal to 0.0 are True</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_chrom">
<span class="sig-name descname"><span class="pre">get_chrom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linopt'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cavpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_chrom" title="Permalink to this definition">#</a></dt>
<dd><p>gets the chromaticity using several available methods</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description.</p>
</dd>
<dt>KEYWORDS</dt><dd><blockquote>
<div><p>dp=None         Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>method=’linopt’ ‘linopt’ returns the tunes from the linopt function</dt><dd><p>‘laskar’ tracks a single particle and computes the
tunes with NAFF</p>
</dd>
<dt>DPStep=1.0E-6   momentum step used for the computation of</dt><dd><p>chromaticities</p>
</dd>
</dl>
</div></blockquote>
<p>for the ‘laskar’ method only:</p>
<blockquote>
<div><p>nturns=512      number of turns
amplitude=1.0E-6 amplitude of oscillation
remove_dc=False Remove the mean of oscillation data
num_harmonics   number of harmonic components to compute</p>
<blockquote>
<div><p>(before mask applied, default=20)</p>
</div></blockquote>
<dl class="simple">
<dt>fmin/fmax       determine the boundaries within which the tune is</dt><dd><p>located [default 0-&gt;1]</p>
</dd>
</dl>
<p>hann=False      flag to turn on Hanning window</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>chromaticities = np.array([Q’x,Q’y])</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_elements">
<span class="sig-name descname"><span class="pre">get_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quiet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_elements" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a list of elements selected by <code class="docutils literal notranslate"><span class="pre">key</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(in Python v3.10)"><em>Sequence</em></a><em>[</em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>]</em>) – Lattice description</p></li>
<li><p><strong>key</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Union" title="(in Python v3.10)"><em>Union</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.10)"><em>type</em></a><em>, </em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em>]</em>) – <p>Element selection key. May be:</p>
<ol class="arabic simple">
<li><p>an element instance, will return all elements of the same
type in the lattice, e.g. key=Drift(‘d1’, 1.0)</p></li>
<li><p>an element type, will return all elements of that type in
the lattice, e.g. <code class="docutils literal notranslate"><span class="pre">at.elements.Sextupole</span></code></p></li>
<li><p>a string to match against elements’ <code class="docutils literal notranslate"><span class="pre">FamName</span></code>, supports
Unix shell-style wildcards, e.g. <code class="docutils literal notranslate"><span class="pre">'BPM_*1'</span></code></p></li>
</ol>
</p></li>
<li><p><strong>quiet</strong> – if false print information about matched elements for FamName
matches.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>elem_list</strong> (<em>list</em>) – list of <code class="docutils literal notranslate"><span class="pre">Elements</span></code> matching key</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_energy_loss">
<span class="sig-name descname"><span class="pre">get_energy_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">ELossMethod.INTEGRAL</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_energy_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the energy loss per turn [eV]</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring                        lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><dl>
<dt>method=ELossMethod.INTEGRAL method for energy loss computation</dt><dd><p>The enum class ELossMethod declares 2 values
INTEGRAL: The losses are obtained from</p>
<blockquote>
<div><p>Losses = Cgamma / 2pi * EGeV^4 * i2
Takes into account bending magnets and wigglers.</p>
</div></blockquote>
<dl class="simple">
<dt>TRACKING: The losses are obtained by tracking without cavities.</dt><dd><p>Needs radiation ON, takes into account all radiating elements.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_horizontal_acceptance">
<span class="sig-name descname"><span class="pre">get_horizontal_acceptance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_horizontal_acceptance" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the 1D horizontal acceptance at refpts observation points
Scalar parameters required</p>
<p>See get_acceptance</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            ring use for tracking
resolution      minimum distance between 2 grid points
amplitude       max. amplitude of the grid or initial step in RECURSIVE</p>
</dd>
<dt>KEYWORDS</dt><dd><p>nturns=1024     Number of turns for the tracking
dp=0            static momentum offset
refpts=None     Observation refpts, default start of the machine
grid_mode       at.GridMode.CARTESIAN/RADIAL: track full vector</p>
<blockquote>
<div><p>(default) at.GridMode.RECURSIVE: recursive search</p>
</div></blockquote>
<dl class="simple">
<dt>use_mp=False    Use python multiprocessing (patpass, default use</dt><dd><p>lattice_pass).</p>
</dd>
<dt>divider=2       Value of the divider used in RECURSIVE boundary search</dt><dd><p>In case multi-processing is not enabled GridMode is
forced to RECURSIVE (most efficient in single core)</p>
</dd>
</dl>
<p>verbose=False   Print out some information
start_method    This parameter allows to change the python</p>
<blockquote>
<div><p>multiprocessing start method, default=None uses the
python defaults that is considered safe.
Available parameters: ‘fork’, ‘spawn’, ‘forkserver’.
Default for linux is fork, default for MacOS and
Windows is spawn. fork may used for MacOS to speed-up
the calculation or to solve Runtime Errors, however
it is considered unsafe.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>Returns 3 lists containing the 1D acceptance, the grid that was tracked
and the particles of the grid that survived.
The length of the lists=refpts. In case len(refpts)=1 the acceptance,
grid, suvived arrays are returned.
The boundary output is squeezed to an array with shape (len(refpts),2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_lifetime">
<span class="sig-name descname"><span class="pre">get_lifetime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">emity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bunch_curr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">emitx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">momap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_lifetime" title="Permalink to this definition">#</a></dt>
<dd><p>Touschek lifetime calculation</p>
<p>Computes the touschek lifetime using the piwinski formula</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> – ring use for tracking</p></li>
<li><p><strong>emity</strong> – verticla emittance</p></li>
<li><p><strong>bunch_curr</strong> – bunch current</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>emitx=None</strong> – horizontal emittance</p></li>
<li><p><strong>sigs=None</strong> – rms bunch length</p></li>
<li><p><strong>sigp=None</strong> – energy spread</p></li>
<li><p><strong>zn=None</strong> – full ring <span class="math notranslate nohighlight">\(Z/n\)</span></p></li>
<li><p><strong>momap=None</strong> – momentum aperture, has to be consistent with <code class="docutils literal notranslate"><span class="pre">refpts</span></code>
if provided the momentum aperture is not calculated</p></li>
<li><p><strong>refpts=None</strong> – <code class="docutils literal notranslate"><span class="pre">refpts</span></code> where the momentum aperture is calculated,
the default is to compute it for all elements in the
ring, <code class="docutils literal notranslate"><span class="pre">len(refpts)&gt;2</span></code> is required</p></li>
<li><p><strong>resolution</strong> – minimum distance between 2 grid points, default=1.0e-3</p></li>
<li><p><strong>amplitude</strong> – max. amplitude for <code class="docutils literal notranslate"><span class="pre">RADIAL</span></code> and <code class="docutils literal notranslate"><span class="pre">CARTESIAN</span></code> or
initial step in <a href="#id7"><span class="problematic" id="id8">``</span></a>RECURSIVE`
default = 0.1</p></li>
<li><p><strong>nturns=1024</strong> – Number of turns for the tracking</p></li>
<li><p><strong>dp=None</strong> – static momentum offset</p></li>
<li><p><strong>grid_mode</strong> – <code class="docutils literal notranslate"><span class="pre">at.GridMode.CARTESIAN/RADIAL</span></code> track full vector
(default). <code class="docutils literal notranslate"><span class="pre">at.GridMode.RECURSIVE</span></code>: recursive search</p></li>
<li><p><strong>use_mp=False</strong> – Use python multiprocessing (<code class="docutils literal notranslate"><span class="pre">patpass</span></code>, default use
<code class="docutils literal notranslate"><span class="pre">lattice_pass</span></code>). In case multi-processing is not
enabled <code class="docutils literal notranslate"><span class="pre">GridMode</span></code> is forced to
<code class="docutils literal notranslate"><span class="pre">RECURSIVE</span></code> (most efficient in single core)</p></li>
<li><p><strong>verbose=True</strong> – Print out some inform</p></li>
<li><p><strong>epsrel</strong> (<em>epsabs</em><em>,</em>) – integral absolute and relative tolerances</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Returns the touschek lifetime in seconds, the momentum aperture</strong></p></li>
<li><p><strong>and the refpts at which the aperture was computed</strong></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_mcf">
<span class="sig-name descname"><span class="pre">get_mcf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_mcf" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the momentum compaction factor</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be OFF)</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
keep_lattice    Assume no lattice change since the previous tracking.</p>
<blockquote>
<div><p>Defaults to False</p>
</div></blockquote>
<p>dp_step=1.0E-6  momentum deviation used for differentiation</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_momentum_acceptance">
<span class="sig-name descname"><span class="pre">get_momentum_acceptance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_momentum_acceptance" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the 1D momentum acceptance at refpts observation points
Scalar parameters required</p>
<p>See get_acceptance</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            ring use for tracking
resolution      minimum distance between 2 grid points
amplitude       max. amplitude of the grid or initial step in RECURSIVE</p>
</dd>
<dt>KEYWORDS</dt><dd><p>nturns=1024     Number of turns for the tracking
dp=0            static momentum offset
refpts=None     Observation refpts, default start of the machine
grid_mode       at.GridMode.CARTESIAN/RADIAL: track full vector</p>
<blockquote>
<div><p>(default) at.GridMode.RECURSIVE: recursive search</p>
</div></blockquote>
<dl class="simple">
<dt>use_mp=False    Use python multiprocessing (patpass, default use</dt><dd><p>lattice_pass).</p>
</dd>
<dt>divider=2       Value of the divider used in RECURSIVE boundary search</dt><dd><p>In case multi-processing is not enabled GridMode is
forced to RECURSIVE (most efficient in single core)</p>
</dd>
</dl>
<p>verbose=False   Print out some information
start_method    This parameter allows to change the python</p>
<blockquote>
<div><p>multiprocessing start method, default=None uses the
python defaults that is considered safe.
Available parameters: ‘fork’, ‘spawn’, ‘forkserver’.
Default for linux is fork, default for MacOS and
Windows is spawn. fork may used for MacOS to speed-up
the calculation or to solve Runtime Errors, however
it is considered unsafe.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>Returns 3 lists containing the 1D acceptance, the grid that was tracked
and the particles of the grid that survived.
The length of the lists=refpts. In case len(refpts)=1 the acceptance,
grid, suvived arrays are returned.
The boundary output is squeezed to an array with shape (len(refpts),2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_optics">
<span class="sig-name descname"><span class="pre">get_optics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method=&lt;function</span> <span class="pre">linopt6&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_optics" title="Permalink to this definition">#</a></dt>
<dd><p>Perform linear analysis of a fully coupled lattice</p>
<p>elemdata0, beamdata, elemdata = get_optics(lattice, refpts, <a href="#id9"><span class="problematic" id="id10">**</span></a>kwargs)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl>
<dt>method=linopt6  Method used for the analysis of the transfer matrix.</dt><dd><p>Can be None at.linopt2, at.linopt4, at.linopt6
linopt2:    no longitudinal motion, no H/V coupling,
linopt4:    no longitudinal motion, Sagan/Rubin</p>
<blockquote>
<div><p>4D-analysis of coupled motion,</p>
</div></blockquote>
<dl class="simple">
<dt>linopt6:    with or without longitudinal motion, normal</dt><dd><p>mode analysis</p>
</dd>
</dl>
</dd>
</dl>
<p>dp=None         Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     computes chromatic amplitude functions (W) [4].</dt><dd><p>Needs to compute the optics at 2 different momentum
deviations around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘R’ or ‘alpha’ and ‘beta’   (mandatory)
‘closed_orbit’,             (default 0)
‘dispersion’                (default 0)
If present, the attribute ‘R’ will be used, otherwise
the attributes ‘alpha’ and ‘beta’ will be used. All
other attributes are ignored.</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>elemdata0       linear optics data at the entrance/end of the ring
beamdata        lattice properties
elemdata        linear optics at the points refered to by refpts, if</p>
<blockquote>
<div><p>refpts is None an empty elemdata structure is returned.</p>
</div></blockquote>
<p>elemdata is a record array with fields depending on the
selected method.
See the help for linopt6, linopt4, linopt2, linopt_auto.</p>
<p>beamdata is a record with fields:
tune            Fractional tunes
chromaticity    Chromaticities
damping_time    Damping times [s] (only if radiation is ON)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_radiation_integrals">
<span class="sig-name descname"><span class="pre">get_radiation_integrals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">twiss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_radiation_integrals" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the 5 radiation integrals for uncoupled lattices.</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description.</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>twiss=None      linear optics at all points (from linopt). If None,</dt><dd><p>it will be computed.</p>
</dd>
</dl>
<p>dp=0.0          Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl>
<dt>method=linopt6  Method used for the analysis of the transfer matrix.</dt><dd><p>See get_optics.
linopt6: default
linopt2: faster if no longitudinal motion and</p>
<blockquote>
<div><p>no H/V coupling,</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>i1, i2, i3, i4, i5</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_refpts">
<span class="sig-name descname"><span class="pre">get_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quiet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_refpts" title="Permalink to this definition">#</a></dt>
<dd><p>Returns an <code class="docutils literal notranslate"><span class="pre">int</span></code> array of element indices, selecting ring elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(in Python v3.10)"><em>Sequence</em></a><em>[</em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>]</em>) – Lattice description</p></li>
<li><p><strong>key</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Union" title="(in Python v3.10)"><em>Union</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.10)"><em>type</em></a><em>, </em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em>]</em>) – <p>Element selection key. May be:</p>
<ol class="arabic simple">
<li><p>an element instance, will return all elements of the same
type in the lattice, e.g. key=Drift(‘d1’, 1.0)</p></li>
<li><p>an element type, will return all elements of that type in
the lattice, e.g. <code class="docutils literal notranslate"><span class="pre">at.elements.Sextupole</span></code></p></li>
<li><p>a string to match against elements’ <code class="docutils literal notranslate"><span class="pre">FamName</span></code>, supports
Unix shell-style wildcards, e.g. <code class="docutils literal notranslate"><span class="pre">'BPM_*1'</span></code></p></li>
</ol>
</p></li>
<li><p><strong>quiet</strong> – if false print information about matched elements for FamName
matches.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>uint32_refs</strong> (<em>Uint32Refs</em>) – numpy Array of <code class="docutils literal notranslate"><span class="pre">int</span></code> as long as the
number of refpts</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="docutils literal notranslate"><span class="pre">get_cells</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_revolution_frequency">
<span class="sig-name descname"><span class="pre">get_revolution_frequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_revolution_frequency" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the revolution frequency of the full ring [Hz]</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
dct=0.0         Path length deviation
keep_lattice    Assume no lattice change since the previous tracking.</p>
<blockquote>
<div><p>Defaults to False</p>
</div></blockquote>
<p>dp_step=1.0E-6  momentum deviation used for differentiation</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_rf_frequency">
<span class="sig-name descname"><span class="pre">get_rf_frequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_rf_frequency" title="Permalink to this definition">#</a></dt>
<dd><p>Return the RF frequency</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ring</strong> (<a class="reference internal" href="#at.lattice.lattice_object.Lattice" title="at.lattice.lattice_object.Lattice"><em>Lattice</em></a>) – Lattice description</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>cavpts=None</strong> – Cavity location. If None, look for ring.cavpts,
otherwise take all cavities.</p></li>
<li><p><strong>array=False</strong> – <p>If False, return the frequency of the selected cavities
with the lowest frequency.</p>
<p>If True, return the frequency of all selected cavities</p>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>rf_freq</strong> – RF frequency</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_rf_timelag">
<span class="sig-name descname"><span class="pre">get_rf_timelag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_rf_timelag" title="Permalink to this definition">#</a></dt>
<dd><p>Return the RF time lag</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ring</strong> (<a class="reference internal" href="#at.lattice.lattice_object.Lattice" title="at.lattice.lattice_object.Lattice"><em>Lattice</em></a>) – Lattice description</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>cavpts=None</strong> – Cavity location. If None, look for ring.cavpts,
otherwise take all cavities.</p></li>
<li><p><strong>array=False</strong> – <p>If False, return the frequency of the selected cavities
with the lowest frequency.</p>
<p>If True, return the frequency of all selected cavities</p>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>rf_timelag</strong> – RF time lag</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_rf_voltage">
<span class="sig-name descname"><span class="pre">get_rf_voltage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_rf_voltage" title="Permalink to this definition">#</a></dt>
<dd><p>Return the total RF voltage (full ring)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ring</strong> (<a class="reference internal" href="#at.lattice.lattice_object.Lattice" title="at.lattice.lattice_object.Lattice"><em>Lattice</em></a>) – Lattice description</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>cavpts=None</strong> – Cavity location. If None, look for ring.cavpts,
otherwise take all cavities.</p></li>
<li><p><strong>array=False</strong> – <p>If False, return the frequency of the selected cavities
with the lowest frequency.</p>
<p>If True, return the frequency of all selected cavities</p>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>rf_v</strong> – Total RF voltage (full ring)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_s_pos">
<span class="sig-name descname"><span class="pre">get_s_pos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_s_pos" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the locations of selected elements</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(in Python v3.10)"><em>Sequence</em></a><em>[</em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>]</em>) – Lattice description</p></li>
<li><p><strong>refpts</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.10)"><em>Optional</em></a><em>[</em><em>Refpts</em><em>]</em>) – <p>refpts may be:</p>
<ol class="arabic simple">
<li><p>an integer or a sequence of integers
(0 indicating the first element)</p></li>
<li><p>a sequence of booleans marking the selected elements</p></li>
<li><p>a callable <code class="docutils literal notranslate"><span class="pre">filtfunc</span></code> such that <code class="docutils literal notranslate"><span class="pre">filtfunc(elem)</span></code> is True for
selected elements</p></li>
</ol>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s_pos</strong> – Array of locations of the elements selected by <code class="docutils literal notranslate"><span class="pre">refpts</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_slip_factor">
<span class="sig-name descname"><span class="pre">get_slip_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_slip_factor" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the slip factor</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description (radiation must be OFF)</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
keep_lattice    Assume no lattice change since the previous tracking.</p>
<blockquote>
<div><p>Defaults to False</p>
</div></blockquote>
<p>dp_step=1.0E-6  momentum deviation used for differentiation</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_tune">
<span class="sig-name descname"><span class="pre">get_tune</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linopt'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_tune" title="Permalink to this definition">#</a></dt>
<dd><p>gets the tune using several available methods</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description.</p>
</dd>
<dt>KEYWORDS</dt><dd><blockquote>
<div><p>dp=None         Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>method=’linopt’ ‘linopt’ returns the tunes from the linopt function</dt><dd><p>‘fft’ tracks a single particle and computes the
tunes with fft ‘laskar’ tracks a single particle
and computes the tunes with NAFF</p>
</dd>
</dl>
</div></blockquote>
<p>for the ‘fft’ and ‘laskar’ methods only:</p>
<blockquote>
<div><p>nturns=512      number of turns
amplitude=1.0E-6 amplitude of oscillation
remove_dc=False Remove the mean of oscillation data
num_harmonics   number of harmonic components to compute</p>
<blockquote>
<div><p>(before mask applied, default=20)</p>
</div></blockquote>
<dl class="simple">
<dt>fmin/fmax       determine the boundaries within which the tune is</dt><dd><p>located [default 0-&gt;1]</p>
</dd>
</dl>
<p>hann=False      flag to turn on Hanning window</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>tunes = np.array([Qx,Qy])</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_value_refpts">
<span class="sig-name descname"><span class="pre">get_value_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_value_refpts" title="Permalink to this definition">#</a></dt>
<dd><p>Extracts attribute values from selected lattice <code class="docutils literal notranslate"><span class="pre">Elements</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(in Python v3.10)"><em>Sequence</em></a><em>[</em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>]</em>) – Lattice description</p></li>
<li><p><strong>refpts</strong> (<em>Refpts</em>) – <p>refpts may be:</p>
<ol class="arabic simple">
<li><p>an integer or a sequence of integers
(0 indicating the first element)</p></li>
<li><p>a sequence of booleans marking the selected elements</p></li>
<li><p>a callable <code class="docutils literal notranslate"><span class="pre">filtfunc</span></code> such that <code class="docutils literal notranslate"><span class="pre">filtfunc(elem)</span></code> is True for
selected elements</p></li>
</ol>
</p></li>
<li><p><strong>attrname</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Attribute name</p></li>
<li><p><strong>index</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.10)"><em>Optional</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>]</em>) – <p>index of the value to retrieve if <code class="docutils literal notranslate"><span class="pre">attrname</span></code> is
an array.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">None</span></code> the full array is retrieved</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>attrvalues</strong> – numpy Array of attribute values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.get_vertical_acceptance">
<span class="sig-name descname"><span class="pre">get_vertical_acceptance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.get_vertical_acceptance" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the 1D vertical acceptance at refpts observation points
Scalar parameters required</p>
<p>See get_acceptance</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            ring use for tracking
resolution      minimum distance between 2 grid points
amplitude       max. amplitude of the grid or initial step in RECURSIVE</p>
</dd>
<dt>KEYWORDS</dt><dd><p>nturns=1024     Number of turns for the tracking
dp=0            static momentum offset
refpts=None     Observation refpts, default start of the machine
grid_mode       at.GridMode.CARTESIAN/RADIAL: track full vector</p>
<blockquote>
<div><p>(default) at.GridMode.RECURSIVE: recursive search</p>
</div></blockquote>
<dl class="simple">
<dt>use_mp=False    Use python multiprocessing (patpass, default use</dt><dd><p>lattice_pass).</p>
</dd>
<dt>divider=2       Value of the divider used in RECURSIVE boundary search</dt><dd><p>In case multi-processing is not enabled GridMode is
forced to RECURSIVE (most efficient in single core)</p>
</dd>
</dl>
<p>verbose=False   Print out some information
start_method    This parameter allows to change the python</p>
<blockquote>
<div><p>multiprocessing start method, default=None uses the
python defaults that is considered safe.
Available parameters: ‘fork’, ‘spawn’, ‘forkserver’.
Default for linux is fork, default for MacOS and
Windows is spawn. fork may used for MacOS to speed-up
the calculation or to solve Runtime Errors, however
it is considered unsafe.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>Returns 3 lists containing the 1D acceptance, the grid that was tracked
and the particles of the grid that survived.
The length of the lists=refpts. In case len(refpts)=1 the acceptance,
grid, suvived arrays are returned.
The boundary output is squeezed to an array with shape (len(refpts),2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.insert">
<span class="sig-name descname"><span class="pre">insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elem</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.insert" title="Permalink to this definition">#</a></dt>
<dd><p>Insert object before index.</p>
<dl class="field-list simple">
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.linopt">
<span class="sig-name descname"><span class="pre">linopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_chrom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.linopt" title="Permalink to this definition">#</a></dt>
<dd><p>Perform linear analysis of a H/V coupled lattice following Sagan/Rubin
4D-analysis of coupled motion</p>
<p>lindata0, tune, chrom, lindata = linopt(lattice, dp, refpts, <a href="#id11"><span class="problematic" id="id12">**</span></a>kwargs)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
dp=0.0          momentum deviation.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     computes chromatic amplitude functions (W) [4].</dt><dd><p>Needs to compute the optics at 2 different momentum
deviations around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of</p>
<blockquote>
<div><p>chromaticities and dispersion</p>
</div></blockquote>
<dl class="simple">
<dt>coupled=True    if False, simplify the calculations by assuming</dt><dd><p>no H/V coupling</p>
</dd>
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘alpha’ and ‘beta’  (mandatory)
‘closed_orbit’,     (default 0)
‘dispersion’        (default 0)
All other attributes are ignored.</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>lindata0        linear optics data at the entrance of the ring
tune            [tune_A, tune_B], linear tunes for the two normal modes</p>
<blockquote>
<div><p>of linear motion [1]</p>
</div></blockquote>
<dl class="simple">
<dt>chrom           [ksi_A , ksi_B], chromaticities ksi = d(nu)/(dP/P).</dt><dd><p>Only computed if ‘get_chrom’ is True</p>
</dd>
<dt>lindata         linear optics at the points refered to by refpts, if</dt><dd><p>refpts is None an empty lindata structure is returned.</p>
</dd>
</dl>
<p>lindata is a record array with fields:
idx             element index in the ring
s_pos           longitudinal position [m]
m44             (4, 4) transfer matrix M from the beginning of ring</p>
<blockquote>
<div><p>to the entrance of the element [2]</p>
</div></blockquote>
<p>closed_orbit    (6,) closed orbit vector
dispersion      (4,) dispersion vector
beta            [betax, betay] vector
alpha           [alphax, alphay] vector
mu              [mux, muy], betatron phase (modulo 2*pi)
W               (2,) chromatic amplitude function (only if get_w==True)
All values given at the entrance of each element specified in refpts.
In case coupled == True additional outputs are available:
gamma           gamma parameter of the transformation to eigenmodes
A               (2, 2) matrix A in [3]
B               (2, 2) matrix B in [3]
C               (2, 2) matrix C in [3]
Field values can be obtained with either
lindata[‘idx’]    or
lindata.idx</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] D.Edwards,L.Teng IEEE Trans.Nucl.Sci. NS-20, No.3, p.885-888, 1973
[2] E.Courant, H.Snyder
[3] D.Sagan, D.Rubin Phys.Rev.Spec.Top.-Accelerators and beams,</p>
<blockquote>
<div><p>vol.2 (1999)</p>
</div></blockquote>
<p>[4] Brian W. Montague Report LEP Note 165, CERN, 1979</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.linopt2">
<span class="sig-name descname"><span class="pre">linopt2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.linopt2" title="Permalink to this definition">#</a></dt>
<dd><p>Perform linear analysis of an uncoupled lattice</p>
<p>elemdata0, beamdata, elemdata = linopt2(ring, refpts, <a href="#id13"><span class="problematic" id="id14">**</span></a>kwargs)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
dct=None        path lengthening. If specified, dp is ignored and the</p>
<blockquote>
<div><p>off-momentum is deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     computes chromatic amplitude functions (W) [4].</dt><dd><p>Needs to compute the optics at 2 different momentum
deviations around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of</p>
<blockquote>
<div><p>chromaticities and dispersion</p>
</div></blockquote>
<dl class="simple">
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘alpha’ and ‘beta’  (mandatory)
‘closed_orbit’,     (default 0)
‘dispersion’        (default 0)
All other attributes are ignored.</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>lindata0        linear optics data at the entrance of the ring
beamdata        lattice properties
lindata         linear optics at the points refered to by refpts, if</p>
<blockquote>
<div><p>refpts is None an empty lindata structure is returned.</p>
</div></blockquote>
<p>lindata is a record array with fields:
s_pos           longitudinal position [m]
M               (4, 4) transfer matrix M from the beginning of ring</p>
<blockquote>
<div><p>to the entrance of the element [2]</p>
</div></blockquote>
<p>closed_orbit    (6,) closed orbit vector
dispersion      (4,) dispersion vector
beta            [betax, betay] vector
alpha           [alphax, alphay] vector
mu              [mux, muy], betatron phase (modulo 2*pi)
W               (2,) chromatic amplitude function (only if get_w==True)
All values given at the entrance of each element specified in refpts.
Field values can be obtained with either
lindata[‘idx’]    or
lindata.idx</p>
<p>beamdata is a record with fields:
tune            Fractional tunes
chromaticity    Chromaticities, only computed if get_chrom=True</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] D.Edwards,L.Teng IEEE Trans.Nucl.Sci. NS-20, No.3, p.885-888, 1973
[2] E.Courant, H.Snyder
[3] D.Sagan, D.Rubin Phys.Rev.Spec.Top.-Accelerators and beams,</p>
<blockquote>
<div><p>vol.2 (1999)</p>
</div></blockquote>
<p>[4] Brian W. Montague Report LEP Note 165, CERN, 1979</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.linopt4">
<span class="sig-name descname"><span class="pre">linopt4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.linopt4" title="Permalink to this definition">#</a></dt>
<dd><p>Perform linear analysis of a H/V coupled lattice following Sagan/Rubin
4D-analysis of coupled motion</p>
<p>elemdata0, beamdata, elemdata = linopt4(lattice, refpts, <a href="#id15"><span class="problematic" id="id16">**</span></a>kwargs)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          momentum deviation.
dct=None        path lengthening. If specified, dp is ignored and the</p>
<blockquote>
<div><p>off-momentum is deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     computes chromatic amplitude functions (W) [4].</dt><dd><p>Needs to compute the optics at 2 different momentum
deviations around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of</p>
<blockquote>
<div><p>chromaticities and dispersion</p>
</div></blockquote>
<dl class="simple">
<dt>twiss_in=None   Initial twiss to compute transfer line optics of the</dt><dd><p>type lindata, the initial orbit in twiss_in is ignored,
only the beta and alpha are required other quatities
set to 0 if absent</p>
</dd>
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘alpha’ and ‘beta’  (mandatory)
‘closed_orbit’,     (default 0)
‘dispersion’        (default 0)
All other attributes are ignored.</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>lindata0        linear optics data at the entrance of the ring
beamdata        lattice properties
lindata         linear optics at the points refered to by refpts, if</p>
<blockquote>
<div><p>refpts is None an empty lindata structure is returned.</p>
</div></blockquote>
<p>lindata is a record array with fields:
s_pos           longitudinal position [m]
M               (4, 4) transfer matrix M from the beginning of ring</p>
<blockquote>
<div><p>to the entrance of the element [2]</p>
</div></blockquote>
<p>closed_orbit    (6,) closed orbit vector
dispersion      (4,) dispersion vector
beta            [betax, betay] vector
alpha           [alphax, alphay] vector
mu              [mux, muy], betatron phase (modulo 2*pi)
gamma           gamma parameter of the transformation to eigenmodes [3]
W               (2,) chromatic amplitude function (only if get_w==True)
All values given at the entrance of each element specified in refpts.
Field values can be obtained with either
lindata[‘idx’]    or
lindata.idx</p>
<p>beamdata is a record with fields:
tune            Fractional tunes
chromaticity    Chromaticities, only computed if get_chrom==True</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] D.Edwards,L.Teng IEEE Trans.Nucl.Sci. NS-20, No.3, p.885-888, 1973
[2] E.Courant, H.Snyder
[3] D.Sagan, D.Rubin Phys.Rev.Spec.Top.-Accelerators and beams,</p>
<blockquote>
<div><p>vol.2 (1999)</p>
</div></blockquote>
<p>[4] Brian W. Montague Report LEP Note 165, CERN, 1979</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.linopt6">
<span class="sig-name descname"><span class="pre">linopt6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.linopt6" title="Permalink to this definition">#</a></dt>
<dd><p>Perform linear analysis of a fully coupled lattice using normal modes</p>
<p>elemdata0, beamdata, elemdata = linopt6(lattice, refpts, <a href="#id17"><span class="problematic" id="id18">**</span></a>kwargs)</p>
<p>For circular machines, linopt6 analyses
the 4x4 1-turn transfer matrix if radiation is OFF, or
the 6x6 1-turn transfer matrix if radiation is ON.</p>
<dl>
<dt>For a transfer line, The “twiss_in” intput must contain either:</dt><dd><ul class="simple">
<li><p>a field ‘R’, as provided by ATLINOPT6, or</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>the fields ‘beta’ and ‘alpha’, as provided by linopt and linopt6</p></li>
</ul>
</div></blockquote>
</dd>
<dt>PARAMETERS</dt><dd><p>lattice         lattice description.
refpts=None     elements at which data is returned.</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=None         Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl class="simple">
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>get_chrom=False compute chromaticities. Needs computing the tune at</dt><dd><p>2 different momentum deviations around the central one.</p>
</dd>
<dt>get_w=False     compute chromatic amplitude functions (W) [3]. Needs to</dt><dd><p>compute the optics at 2 different momentum deviations
around the central one.</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
<p>XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of</p>
<blockquote>
<div><p>the closed orbit</p>
</div></blockquote>
<dl class="simple">
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘R’ or ‘alpha’ and ‘beta’   (mandatory)
‘closed_orbit’,             (default 0)
‘dispersion’                (default 0)
If present, the attribute ‘R’ will be used, otherwise
the attributes ‘alpha’ and ‘beta’ will be used. All
other attributes are ignored.</p>
</dd>
</dl>
<p>cavpts=None     Cavity location for off-momentum tuning</p>
</dd>
<dt>OUTPUT</dt><dd><p>elemdata0       linear optics data at the entrance of the ring
beamdata        lattice properties
elemdata        linear optics at the points refered to by refpts, if</p>
<blockquote>
<div><p>refpts is None an empty elemdata structure is returned.</p>
</div></blockquote>
<p>elemdata is a record array with fields:
s_pos           longitudinal position [m]
M               Transfer matrix from the entrance of the line (6, 6)
closed_orbit    (6,) closed orbit vector
dispersion      (4,) dispersion vector
A               A-matrix (6, 6)
R               R-matrices (3, 6, 6)
beta            [betax, betay] vector
alpha           [alphax, alphay] vector
mu              [mux, muy], betatron phases
W               (2,) chromatic amplitude function (only if get_w==True)</p>
<p>All values given at the entrance of each element specified in refpts.
Field values can be obtained with either
elemdata[‘beta’]    or
elemdata.beta</p>
<p>beamdata is a record with fields:
tune            Fractional tunes
chromaticity    Chromaticities, only computed if get_chrom==True
damping_time    Damping times [s] (only if radiation is ON)</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] Etienne Forest, Phys. Rev. E 58, 2481 – Published 1 August 1998
[2] Andrzej Wolski, Phys. Rev. ST Accel. Beams 9, 024001 –</p>
<blockquote>
<div><p>Published 3 February 2006</p>
</div></blockquote>
<p>[3] Brian W. Montague Report LEP Note 165, CERN, 1979</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.load">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.load" title="Permalink to this definition">#</a></dt>
<dd><p>Load a Lattice object from a file</p>
<p>The file format is indicated by the filepath extension.</p>
<dl>
<dt>PARAMETERS</dt><dd><p>filepath        name of the file</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>name            Name of the lattice</dt><dd><p>(default: taken from the file, or ‘’)</p>
</dd>
<dt>energy          Energy of the lattice</dt><dd><p>(default: taken from the file)</p>
</dd>
<dt>periodicity     Number of periods</dt><dd><p>(default: taken from the file, or 1)</p>
</dd>
</dl>
<ul class="simple">
<li><p>all other keywords will be set as Lattice attributes</p></li>
</ul>
</dd>
<dt>MAT-FILE SPECIFIC KEYWORDS</dt><dd><dl class="simple">
<dt>mat_key         name of the Matlab variable containing the lattice.</dt><dd><p>Default: Matlab variable name if there is only one,
otherwise ‘RING’</p>
</dd>
</dl>
<p>check=True      if False, skip the coherence tests
quiet=False     If True, suppress the warning for non-standard classes
keep_all=False  if True, keep RingParam elements as Markers</p>
</dd>
</dl>
<p>Known extensions are:</p>
<p>.mat        Matlab binary mat-file
.m          Matlab text m-file
.repr       Text representation of a python AT Lattice
.lat        Tracy format
.lte        Elegant format</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.modify_elements">
<span class="sig-name descname"><span class="pre">modify_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem_modify</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.modify_elements" title="Permalink to this definition">#</a></dt>
<dd><p>Modify selected elements, in-place or in a lattice copy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>elem_modify</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.10)"><em>Callable</em></a>) – element selection function.
If <code class="docutils literal notranslate"><span class="pre">elem_modify(elem)</span></code> returns <code class="docutils literal notranslate"><span class="pre">None</span></code>, the element is
unchanged. Otherwise, <code class="docutils literal notranslate"><span class="pre">elem_modify(elem)</span></code> must return a
dictionary of attribute name and values, to be set to elem.</p></li>
<li><p><strong>copy</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.10)"><em>Optional</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>]</em>) – If True, return a shallow copy of the lattice.
Only the modified elements are copied.
If False, the modification is done in-place</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>newring</strong> – New lattice if copy is True, None if copy is False</p>
</dd>
</dl>
<p>Keyword Arguments:</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.ohmi_envelope">
<span class="sig-name descname"><span class="pre">ohmi_envelope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_lattice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.ohmi_envelope" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the equilibrium beam envelope in a
circular accelerator using Ohmi’s beam envelope formalism [1]</p>
<p>emit0, beamdata, emit = ohmi_envelope(ring[, refpts])</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            Lattice object.
refpts=None     elements at which data is returned. It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>an integer in the range [-len(ring), len(ring)-1]
selecting the element according to python indexing
rules. As a special case, len(ring) is allowed and
refers to the end of the last element,</p></li>
<li><p>an ordered list of such integers without duplicates,</p></li>
<li><p>a numpy array of booleans of maximum length
len(ring)+1, where selected elements are True.</p></li>
</ol>
</div></blockquote>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>orbit=None          Avoids looking for the closed orbit if it is</dt><dd><p>already known ((6,) array)</p>
</dd>
<dt>keep_lattice=False  Assume no lattice change since the previous</dt><dd><p>tracking</p>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>emit0               emittance data at the start/end of the ring
beamdata            beam parameters at the start of the ring
emit                emittance data at the points refered to by refpts,</p>
<blockquote>
<div><p>if refpts is None an empty structure is returned.</p>
</div></blockquote>
<p>emit is a record array with fields:
r66                 (6, 6) equilibrium envelope matrix R
r44                 (4, 4) betatron emittance matrix (dpp = 0)
m66                 (6, 6) transfer matrix from the start of the ring
orbit6              (6,) closed orbit
emitXY              (2,) betatron emittance projected on xxp and yyp
emitXYZ             (3,) 6x6 emittance projected on xxp, yyp, ldp</p>
<p>beamdata is a record array with fields:
tunes               tunes of the 3 normal modes
damping_rates       damping rates of the 3 normal modes
mode_matrices       R-matrices of the 3 normal modes
mode_emittances     equilibrium emittances of the 3 normal modes</p>
<p>Field values can be obtained with either
emit[‘r66’]    or
emit.r66</p>
</dd>
<dt>REFERENCES</dt><dd><p>[1] K.Ohmi et al. Phys.Rev.E. Vol.49. (1994)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.plot_acceptance">
<span class="sig-name descname"><span class="pre">plot_acceptance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.plot_acceptance" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the acceptance at repfts observation points
Grid Coordiantes ordering is as follows: CARTESIAN: (x,y), RADIAL/RECURSIVE
(r, theta). Scalar inputs can be used for 1D grid.
The grid can be changed using grid_mode input:
at.GridMode.CARTESIAN: (x,y) grid
at.GridMode.RADIAL: (r,theta) grid
at.GridMode.RECURSIVE: (r,theta) recursive boundary search</p>
<p>Example usage:
ring.plot_acceptance(planes, npoints, amplitudes)
plt.show()</p>
<p>PARAMETERS
PARAMETERS</p>
<blockquote>
<div><p>ring            ring use for tracking
planes          max. dimension 2, defines the plane where to search</p>
<blockquote>
<div><p>for the acceptance, allowed values are: x,xp,y,yp,dp,ct</p>
</div></blockquote>
<p>npoints         number of points in each dimension shape (len(planes),)
amplitudes      max. amplitude  or initial step in RECURSIVE in each</p>
<blockquote>
<div><p>dimension
shape (len(planes),), for RADIAL/RECURSIVE grid:
r = sqrt(x**2+y**2)</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>acceptance=None tuple containing pre-computed acceptance</dt><dd><p>(boundary, survived, grid)</p>
</dd>
</dl>
<p>nturns=1024     Number of turns for the tracking
refpts=None     Observation refpts, default start of the machine
dp=None         static momentum offset
offset=None     initial orbit, default closed orbit
bounds=None     Allows to define boundaries for the grid default</p>
<blockquote>
<div><p>values are:
GridMode.CARTESIAN: ((-1,1),(0,1))
GridMode.RADIAL/RECURSIVE: ((0,1),(pi,0))</p>
</div></blockquote>
<dl class="simple">
<dt>grid_mode       at.GridMode.CARTESIAN/RADIAL: track full vector</dt><dd><p>(default) at.GridMode.RECURSIVE: recursive search</p>
</dd>
<dt>use_mp=False    Use python multiprocessing (patpass, default use</dt><dd><p>lattice_pass). In case multi-processing is not
enabled GridMode is forced to
RECURSIVE (most efficient in single core)</p>
</dd>
</dl>
<p>divider=2       Value of the divider used in RECURSIVE boundary search
verbose=True    Print out some inform
start_method    This parameter allows to change the python</p>
<blockquote>
<div><p>multiprocessing start method, default=None uses the
python defaults that is considered safe.
Available parameters: ‘fork’, ‘spawn’, ‘forkserver’.
Default for linux is fork, default for MacOS and
Windows is spawn. fork may used for MacOS to speed-up
the calculation or to solve Runtime Errors, however
it is considered unsafe.</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>Returns 3 lists containing the 2D acceptance, the grid that was
tracked and the particles of the grid that survived. The length
of the lists=refpts. In case len(refpts)=1 the acceptance, grid,
survived arrays are returned directly.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.plot_beta">
<span class="sig-name descname"><span class="pre">plot_beta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.plot_beta" title="Permalink to this definition">#</a></dt>
<dd><p>Plot beta functions and dispersion</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            Lattice object</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl>
<dt>method=linopt6  Method used for the analysis of the transfer matrix.</dt><dd><p>See get_optics.
linopt6: default
linopt2: faster if no longitudinal motion and</p>
<blockquote>
<div><p>no H/V coupling,</p>
</div></blockquote>
</dd>
<dt>orbit           avoids looking for the closed orbit if is already known</dt><dd><p>((6,) array)</p>
</dd>
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
<dt>ddp=1.0E-8      momentum deviation used for computation of</dt><dd><p>chromaticities and dispersion</p>
</dd>
<dt>twiss_in=None   Initial conditions for transfer line optics. Record</dt><dd><p>array as output by linopt, or dictionary. Keys:
‘R’ or ‘alpha’ and ‘beta’   (mandatory)
‘closed_orbit’,             (default 0)
‘dispersion’                (default 0)
If present, the attribute ‘R’ will be used, otherwise
the attributes ‘alpha’ and ‘beta’ will be used. All
other attributes are ignored.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.plot_trajectory">
<span class="sig-name descname"><span class="pre">plot_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nturns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.plot_trajectory" title="Permalink to this definition">#</a></dt>
<dd><p>plot a particle’s trajectory</p>
<dl class="simple">
<dt>PARAMETERS</dt><dd><p>ring            Lattice object
r_in            6xN array: input coordinates of N particles
nturns=1        Number of turns</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>keep_lattice    Assume no lattice change since the previous tracking.</dt><dd><p>Defaults to False</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.radiation_off">
<span class="sig-name descname"><span class="pre">radiation_off</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cavity_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quadrupole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wiggler_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sextupole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">octupole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multipole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.radiation_off" title="Permalink to this definition">#</a></dt>
<dd><p>Turn acceleration and radiation off and return the lattice</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cavity_pass='IdentityPass'</strong> – PassMethod set on cavities</p></li>
<li><p><strong>dipole_pass='auto'</strong> – PassMethod set on dipoles</p></li>
<li><p><strong>quadrupole_pass=None</strong> – PassMethod set on quadrupoles</p></li>
<li><p><strong>wiggler_pass='auto'</strong> – PassMethod set on wigglers</p></li>
<li><p><strong>copy=False</strong> – <p>If <code class="docutils literal notranslate"><span class="pre">False</span></code>, the modification is done in-place,
If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return a shallow copy of the lattice. Only the
radiating elements are copied with PassMethod modified.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>a shallow copy means that all non-radiating
elements are shared with the original lattice.
Any further modification will affect in both lattices.</p>
</div>
</p></li>
</ul>
</dd>
</dl>
<p>For PassMethod names, the convention is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>:        no change</p></li>
<li><p>‘auto’:          replace *RadPass by *Pass</p></li>
<li><p>anything else:   set as the new PassMethod</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.radiation_on">
<span class="sig-name descname"><span class="pre">radiation_on</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cavity_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'RFCavityPass'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quadrupole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wiggler_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sextupole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">octupole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multipole_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.radiation_on" title="Permalink to this definition">#</a></dt>
<dd><p>Turn acceleration and radiation on and return the lattice</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cavity_pass='RFCavityPass'</strong> – PassMethod set on cavities</p></li>
<li><p><strong>dipole_pass='auto'</strong> – PassMethod set on dipoles</p></li>
<li><p><strong>quadrupole_pass='auto'</strong> – PassMethod set on quadrupoles</p></li>
<li><p><strong>wiggler_pass='auto'</strong> – PassMethod set on wigglers</p></li>
<li><p><strong>copy=False</strong> – <p>If <code class="docutils literal notranslate"><span class="pre">False</span></code>, the modification is done in-place,
If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return a shallow copy of the lattice. Only the
radiating elements are copied with PassMethod modified.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>a shallow copy means that all non-radiating
elements are shared with the original lattice.
Any further modification will affect in both lattices.</p>
</div>
</p></li>
</ul>
</dd>
</dl>
<p>For PassMethod names, the convention is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>:        no change</p></li>
<li><p>‘auto’:          replace *Pass by *RadPass</p></li>
<li><p>anything else:   set as the new PassMethod</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.radiation_parameters">
<span class="sig-name descname"><span class="pre">radiation_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.radiation_parameters" title="Permalink to this definition">#</a></dt>
<dd><p>Compute ring parameters from the radiation integrals. Valid for
uncoupled lattices with no RF cavity or radiating element.</p>
<dl>
<dt>INPUT</dt><dd><p>ring            Lattice object.</p>
</dd>
<dt>KEYWORD</dt><dd><p>params=None     RingParam object to be updated.
dp=0.0          Ignored if radiation is ON. Momentum deviation.
dct=None        Ignored if radiation is ON. Path lengthening.</p>
<blockquote>
<div><p>If specified, dp is ignored and the off-momentum is
deduced from the path lengthening.</p>
</div></blockquote>
<dl>
<dt>method=linopt6  Method used for the analysis of the transfer matrix.</dt><dd><p>See get_optics.
linopt6: default
linopt2: faster if no longitudinal motion and</p>
<blockquote>
<div><p>no H/V coupling,</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>OUTPUT</dt><dd><p>params          RingParam object. The computed attributes are,</p>
<blockquote>
<div><p>tunes           (3,) fractional (H, V, Long.) tunes
fulltunes       (3,) full tunes
chromaticities  (2,) H, V Chromaticities
alphac          Momentum compaction factor
etac            Frequency slip factor
E0              Energy [eV]
U0              nergy loss / turn [eV]
i1              Radiation integrals - I1 [m]
i2                                    I2 [m^-1]
i3                                    I3 [m^-2]
i4                                    I4 [m^-1]
i5                                    I5 [m^-1]
emittances      (3,) Mode emittances
J               (3,) Damping partition numbers
Tau             (3,) Damping times [s]
sigma_e         Energy spread
sigma_l         Bunch length [m]
voltage         Total accelerating voltage [V]
phi_s           Synchrotron phase [rad]
f_s             Synchrotron frequency [Hz]</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.refcount">
<span class="sig-name descname"><span class="pre">refcount</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.refcount" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the number of reference points</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(in Python v3.10)"><em>Sequence</em></a><em>[</em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>]</em>) – Lattice description</p></li>
<li><p><strong>refpts</strong> (<em>Refpts</em>) – <p>refpts may be:</p>
<ol class="arabic simple">
<li><p>an integer or a sequence of integers
(0 indicating the first element)</p></li>
<li><p>a sequence of booleans marking the selected elements</p></li>
<li><p>a callable <code class="docutils literal notranslate"><span class="pre">filtfunc</span></code> such that <code class="docutils literal notranslate"><span class="pre">filtfunc(elem)</span></code> is True for
selected elements</p></li>
</ol>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nrefs</strong> (<em>int</em>) – The number of reference points</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.replace">
<span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.replace" title="Permalink to this definition">#</a></dt>
<dd><p>Return a shallow copy of the lattice replacing the selected
elements by a deep copy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>refpts</strong> (<em>Refpts</em>) – element selector</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.rotate" title="Permalink to this definition">#</a></dt>
<dd><p>Return a new lattice rotated left by n elements</p>
<dl class="field-list simple">
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.save" title="Permalink to this definition">#</a></dt>
<dd><p>Save a Lattice object</p>
<p>The file format is indicated by the filepath extension.</p>
<dl class="simple">
<dt>PARAMETERS</dt><dd><p>ring            Lattice object
filepath        name of the file</p>
</dd>
<dt>MAT-FILE SPECIFIC KEYWORDS</dt><dd><p>mat_key=’RING’  Name of the Matlab variable</p>
</dd>
</dl>
<p>Known extensions are:</p>
<p>.mat        Matlab binary mat-file
.m          Matlab text m-file
.repr       Text representation of a python AT Lattice</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.sbreak">
<span class="sig-name descname"><span class="pre">sbreak</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">break_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">break_elems</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.sbreak" title="Permalink to this definition">#</a></dt>
<dd><p>Insert elements at selected locations in the lattice</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>break_s</strong> – location or array of locations of breakpoints</p></li>
<li><p><strong>break_elems</strong> – elements to be inserted at breakpoints (array of
elements as long as break_s or single element
duplicated as necessary). Default: Marker(‘sbreak’)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>newring</strong> – A new lattice with new elements inserted at breakpoints</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.select">
<span class="sig-name descname"><span class="pre">select</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.select" title="Permalink to this definition">#</a></dt>
<dd><p>Return an iterator over selected elements in a lattice</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(in Python v3.10)"><em>Sequence</em></a><em>[</em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>]</em>) – Lattice description</p></li>
<li><p><strong>refpts</strong> (<em>Refpts</em>) – <p>refpts may be:</p>
<ol class="arabic simple">
<li><p>an integer or a sequence of integers
(0 indicating the first element)</p></li>
<li><p>a sequence of booleans marking the selected elements</p></li>
<li><p>a callable <code class="docutils literal notranslate"><span class="pre">filtfunc</span></code> such that <code class="docutils literal notranslate"><span class="pre">filtfunc(elem)</span></code> is True for
selected elements</p></li>
</ol>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>elem_iter</strong> (<em>Iterator[Element]</em>) – Iterator over the elements in <code class="docutils literal notranslate"><span class="pre">ring</span></code>
selected by <code class="docutils literal notranslate"><span class="pre">refpts</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_cavity">
<span class="sig-name descname"><span class="pre">set_cavity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Voltage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">TimeLag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cavpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_cavity" title="Permalink to this definition">#</a></dt>
<dd><p>Set the parameters of the RF cavities</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> (<a class="reference internal" href="#at.lattice.lattice_object.Lattice" title="at.lattice.lattice_object.Lattice"><em>Lattice</em></a>) – lattice description</p></li>
<li><p><strong>Frequency</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.10)"><em>Optional</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>]</em>) – RF frequency [Hz]</p></li>
<li><p><strong>Voltage</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.10)"><em>Optional</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>]</em>) – RF voltage [V]</p></li>
<li><p><strong>TimeLag</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.10)"><em>Optional</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>]</em>) – RF time shift [-ct]</p></li>
<li><p><strong>cavpts</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.10)"><em>Optional</em></a><em>[</em><em>Refpts</em><em>]</em>) – Cavity location. If None, look for ring.cavpts, or
otherwise take all cavities</p></li>
<li><p><strong>array</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.10)"><em>Optional</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>]</em>) – If False, the value is applied as described for
set_rf_voltage, set_rf_timelag and set_rf_frequency
If True, directly apply the value to the selected
cavities. The value must be broadcastable to the number
of cavities.</p></li>
<li><p><strong>copy</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.10)"><em>Optional</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>]</em>) – If True, returns a shallow copy of ring with new
cavity elements. Otherwise, modify ring in-place</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_cavity_phase">
<span class="sig-name descname"><span class="pre">set_cavity_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">ELossMethod.TRACKING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cavpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_cavity_phase" title="Permalink to this definition">#</a></dt>
<dd><p>Adjust the TimeLag attribute of RF cavities based on frequency,
voltage and energy loss per turn, so that the synchronous phase is zero.
An error occurs if all cavities do not have the same frequency.</p>
<p>!!!!WARNING!!!: This function changes the time reference,
this should be avoided</p>
<blockquote>
<div><dl class="simple">
<dt>PARAMETERS</dt><dd><p>ring        lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><dl class="simple">
<dt>method=ELossMethod.INTEGRAL</dt><dd><p>method for energy loss computation.
See “get_energy_loss”.</p>
</dd>
<dt>cavpts=None         Cavity location. If None, use all cavities.</dt><dd><p>This allows to ignore harmonic cavities.</p>
</dd>
<dt>copy=False          If True, returns a shallow copy of ring with new</dt><dd><p>cavity elements. Otherwise, modify ring in-place.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_rf_frequency">
<span class="sig-name descname"><span class="pre">set_rf_frequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_rf_frequency" title="Permalink to this definition">#</a></dt>
<dd><p>Set the RF frequency</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring            lattice description
frequency       RF frequency [Hz]. Default: nominal frequency.</p>
</dd>
<dt>KEYWORDS</dt><dd><p>dp=0.0          Momentum deviation.
dct=0.0         Path length deviation
cavpts=None     If None, look for ring.cavpts, or otherwise take all</p>
<blockquote>
<div><p>cavities.</p>
</div></blockquote>
<dl class="simple">
<dt>array=False     If False, frequency is applied to the selected cavities</dt><dd><p>with the lowest frequency. The frequency of all the
other selected cavities is scaled by the same ratio.
If True, directly apply frequency to the selected
cavities. The value must be broadcastable to the number
of cavities.</p>
</dd>
<dt>copy=False      If True, returns a shallow copy of ring with new</dt><dd><p>cavity elements. Otherwise, modify ring in-place</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_rf_timelag">
<span class="sig-name descname"><span class="pre">set_rf_timelag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timelag</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_rf_timelag" title="Permalink to this definition">#</a></dt>
<dd><p>Set the RF time lag</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> (<a class="reference internal" href="#at.lattice.lattice_object.Lattice" title="at.lattice.lattice_object.Lattice"><em>Lattice</em></a>) – Lattice description</p></li>
<li><p><strong>timelag</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) – RF time lag</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>cavpts=None</strong> – Cavity location. If None, look for ring.cavpts,
otherwise take all cavities.</p></li>
<li><p><strong>array=False</strong> – <p>If False, return the frequency of the selected cavities
with the lowest frequency.</p>
<p>If True, return the frequency of all selected cavities</p>
</p></li>
<li><p><strong>copy=False</strong> – If True, returns a shallow copy of <code class="docutils literal notranslate"><span class="pre">ring</span></code> with new
cavity elements. Otherwise, modify <code class="docutils literal notranslate"><span class="pre">ring</span></code> in-place.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_rf_voltage">
<span class="sig-name descname"><span class="pre">set_rf_voltage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voltage</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_rf_voltage" title="Permalink to this definition">#</a></dt>
<dd><p>Set the RF voltage for the full ring</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> (<a class="reference internal" href="#at.lattice.lattice_object.Lattice" title="at.lattice.lattice_object.Lattice"><em>Lattice</em></a>) – Lattice description</p></li>
<li><p><strong>voltage</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) – Total RF voltage (full ring)</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>cavpts=None</strong> – Cavity location. If None, look for ring.cavpts,
otherwise take all cavities.</p></li>
<li><p><strong>array=False</strong> – <p>If False, return the frequency of the selected cavities
with the lowest frequency.</p>
<p>If True, return the frequency of all selected cavities</p>
</p></li>
<li><p><strong>copy=False</strong> – If True, returns a shallow copy of <code class="docutils literal notranslate"><span class="pre">ring</span></code> with new
cavity elements. Otherwise, modify <code class="docutils literal notranslate"><span class="pre">ring</span></code> in-place.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_shift">
<span class="sig-name descname"><span class="pre">set_shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dxs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dzs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_shift" title="Permalink to this definition">#</a></dt>
<dd><p>Sets the translations of a list of elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(in Python v3.10)"><em>Sequence</em></a><em>[</em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>]</em>) – Lattice description</p></li>
<li><p><strong>dxs</strong> – Sequence of horizontal displacements values as long as
ring or scalar value applied to all elements [m]</p></li>
<li><p><strong>dzs</strong> – Sequence of vertical displacements values as long as
ring or scalar value applied to all elements [m]</p></li>
<li><p><strong>relative</strong> – If True, the displacement is added to the previous one</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_tilt">
<span class="sig-name descname"><span class="pre">set_tilt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tilts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_tilt" title="Permalink to this definition">#</a></dt>
<dd><p>Sets the tilts of a list of elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(in Python v3.10)"><em>Sequence</em></a><em>[</em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>]</em>) – Lattice description</p></li>
<li><p><strong>tilts</strong> – Sequence of tilt values as long as ring or
scalar tilt value applied to all elements</p></li>
<li><p><strong>relative</strong> – If True, the rotation is added to the previous one</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.set_value_refpts">
<span class="sig-name descname"><span class="pre">set_value_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrvalues</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">increment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.set_value_refpts" title="Permalink to this definition">#</a></dt>
<dd><p>Set the values of an attribute of an array of elements based on
their refpts</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ring</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(in Python v3.10)"><em>Sequence</em></a><em>[</em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>]</em>) – Lattice description</p></li>
<li><p><strong>refpts</strong> (<em>Refpts</em>) – <p>refpts may be:</p>
<ol class="arabic simple">
<li><p>an integer or a sequence of integers
(0 indicating the first element)</p></li>
<li><p>a sequence of booleans marking the selected elements</p></li>
<li><p>a callable <code class="docutils literal notranslate"><span class="pre">filtfunc</span></code> such that <code class="docutils literal notranslate"><span class="pre">filtfunc(elem)</span></code> is True for
selected elements</p></li>
</ol>
</p></li>
<li><p><strong>attrname</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Attribute name</p></li>
<li><p><strong>attrvalues</strong> – Attribute values</p></li>
<li><p><strong>index</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.10)"><em>Optional</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>]</em>) – index of the value to set if <code class="docutils literal notranslate"><span class="pre">attrname</span></code> is
an array. if <code class="docutils literal notranslate"><span class="pre">None</span></code>, the full array is replaced by <code class="docutils literal notranslate"><span class="pre">attrvalue</span></code></p></li>
<li><p><strong>increment</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.10)"><em>Optional</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>]</em>) – <p>Add values to the initial values.</p>
<p>If False the initial value is replaced (Default)</p>
</p></li>
<li><p><strong>copy</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.10)"><em>Optional</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>]</em>) – <p>If <code class="docutils literal notranslate"><span class="pre">False</span></code>, the modification is done in-place,</p>
<p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return a shallow copy of the lattice. Only the
modified elements are copied.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>a shallow copy means that all non-modified
elements are shared with the original lattice.
Any further modification will affect in both lattices.</p>
</div>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.slice">
<span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.slice" title="Permalink to this definition">#</a></dt>
<dd><p>Create a new lattice by slicing the range of interest into small
elements</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size=None</strong> – Length of a slice. Default: computed from the
range and number of points: <code class="docutils literal notranslate"><span class="pre">size</span> <span class="pre">=</span> <span class="pre">(s_max-s_min)/slices</span></code>.</p></li>
<li><p><strong>slices=1</strong> – Number of slices in the specified range. Ignored if
size is specified. Default: no slicing</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>newring</strong> – New Lattice object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.tapering">
<span class="sig-name descname"><span class="pre">tapering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">multipoles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.tapering" title="Permalink to this definition">#</a></dt>
<dd><p>Scales magnet strength with local energy to cancel the closed orbit
and optics errors due to synchrotron radiations. PolynomB is used for
dipoles such that the machine geometry is maintained. This is the ideal
tapering scheme where magnets and multipoles components (PolynomB and
PolynomA) are scaled individually.
!!! WARNING: This method works only for lattices without errors and
corrections: if not all corrections and field errors will also be
scaled !!!
tapering(ring) or ring.tapering()
PARAMETERS</p>
<blockquote>
<div><p>ring            lattice description.</p>
</div></blockquote>
<dl>
<dt>KEYWORDS</dt><dd><p>multipoles=True scale all multipoles
method          Method for energy loss computation</p>
<blockquote>
<div><p>(see get_energy_loss)</p>
</div></blockquote>
<p>niter=1         number of iteration
XYStep=1.0e-8   transverse step for numerical computation
DPStep=1.0E-6   momentum deviation used for computation of orbit6</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.uint32_refpts">
<span class="sig-name descname"><span class="pre">uint32_refpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.uint32_refpts" title="Permalink to this definition">#</a></dt>
<dd><p>Returns an integer array of element indices, selecting ring elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>refpts</strong> (<em>Refpts</em>) – <p>refpts may be:</p>
<ol class="arabic simple">
<li><p>an integer or a sequence of integers
(0 indicating the first element)</p></li>
<li><p>a sequence of booleans marking the selected elements</p></li>
<li><p>a callable <code class="docutils literal notranslate"><span class="pre">filtfunc</span></code> such that <code class="docutils literal notranslate"><span class="pre">filtfunc(elem)</span></code> is True for
selected elements</p></li>
</ol>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>uint32_ref</strong> (<em>Uint32Refpts</em>) – uint32 numpy array used for indexing
<code class="docutils literal notranslate"><span class="pre">Elements</span></code> in a lattice.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.update" title="Permalink to this definition">#</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.10)"><span class="pre">None</span></a></span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.10)"><span class="pre">None</span></a></span></span></dt>
<dd><p>Update the lattice attributes with the given values</p>
<dl class="field-list simple">
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.BRho">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BRho</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#at.lattice.lattice_object.Lattice.BRho" title="Permalink to this definition">#</a></dt>
<dd><p>Magnetic rigidity [T.m]</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.attrs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">attrs</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Dict</span></em><a class="headerlink" href="#at.lattice.lattice_object.Lattice.attrs" title="Permalink to this definition">#</a></dt>
<dd><p>Dictionary of lattice attributes</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.beta">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">beta</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#at.lattice.lattice_object.Lattice.beta" title="Permalink to this definition">#</a></dt>
<dd><p>Relativistic <span class="math notranslate nohighlight">\(\beta\)</span> of the particles</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.circumference">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">circumference</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#at.lattice.lattice_object.Lattice.circumference" title="Permalink to this definition">#</a></dt>
<dd><p>Ring circumference (full ring) [m]</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id0">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">energy</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#id0" title="Permalink to this definition">#</a></dt>
<dd><p>Lattice energy</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.energy_loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">energy_loss</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.energy_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the energy loss per turn [eV]</p>
<dl>
<dt>PARAMETERS</dt><dd><p>ring                        lattice description</p>
</dd>
<dt>KEYWORDS</dt><dd><dl>
<dt>method=ELossMethod.INTEGRAL method for energy loss computation</dt><dd><p>The enum class ELossMethod declares 2 values
INTEGRAL: The losses are obtained from</p>
<blockquote>
<div><p>Losses = Cgamma / 2pi * EGeV^4 * i2
Takes into account bending magnets and wigglers.</p>
</div></blockquote>
<dl class="simple">
<dt>TRACKING: The losses are obtained by tracking without cavities.</dt><dd><p>Needs radiation ON, takes into account all radiating elements.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.gamma">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gamma</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#at.lattice.lattice_object.Lattice.gamma" title="Permalink to this definition">#</a></dt>
<dd><p>Relativistic <span class="math notranslate nohighlight">\(\gamma\)</span> of the particles</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id19">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">harmonic_number</span></span><a class="headerlink" href="#id19" title="Permalink to this definition">#</a></dt>
<dd><p>Ring harmonic number (full ring)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.i_range">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">i_range</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.uint32</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#at.lattice.lattice_object.Lattice.i_range" title="Permalink to this definition">#</a></dt>
<dd><p>Range of elements inside the range of interest</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.mcf">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mcf</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.mcf" title="Permalink to this definition">#</a></dt>
<dd><p>Momentum compaction factor</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id20">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">particle</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="at.lattice.particle_object.html#at.lattice.particle_object.Particle" title="at.lattice.particle_object.Particle"><span class="pre">at.lattice.particle_object.Particle</span></a></em><a class="headerlink" href="#id20" title="Permalink to this definition">#</a></dt>
<dd><p>Circulating particle</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.radiation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">radiation</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></em><a class="headerlink" href="#at.lattice.lattice_object.Lattice.radiation" title="Permalink to this definition">#</a></dt>
<dd><p>If True, at least one element modifies the beam energy</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.revolution_frequency">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">revolution_frequency</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#at.lattice.lattice_object.Lattice.revolution_frequency" title="Permalink to this definition">#</a></dt>
<dd><p>Revolution frequency (fullring) [Hz]</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.rf_frequency">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rf_frequency</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#at.lattice.lattice_object.Lattice.rf_frequency" title="Permalink to this definition">#</a></dt>
<dd><p>Fundamental RF frequency [Hz]. The special value <a class="reference internal" href="at.lattice.cavity_access.html#at.lattice.cavity_access.Frf" title="at.lattice.cavity_access.Frf"><code class="xref py py-class docutils literal notranslate"><span class="pre">at.Frf.NOMINAL</span></code></a> means nominal frequency.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.rf_timelag">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rf_timelag</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#at.lattice.lattice_object.Lattice.rf_timelag" title="Permalink to this definition">#</a></dt>
<dd><p>Time lag of the fundamental mode [m]</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.rf_voltage">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rf_voltage</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#at.lattice.lattice_object.Lattice.rf_voltage" title="Permalink to this definition">#</a></dt>
<dd><p>RF voltage of the full ring [V]</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.s_range">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">s_range</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.s_range" title="Permalink to this definition">#</a></dt>
<dd><p>[s_min, s_max]. <code class="docutils literal notranslate"><span class="pre">None</span></code> means the full cell.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>Range of interest</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="at.lattice.lattice_object.Lattice.slip_factor">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">slip_factor</span></span><a class="headerlink" href="#at.lattice.lattice_object.Lattice.slip_factor" title="Permalink to this definition">#</a></dt>
<dd><p>Slip factor</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.lattice_object.lattice_filter">
<span class="sig-name descname"><span class="pre">lattice_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lattice</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.lattice_filter" title="Permalink to this definition">#</a></dt>
<dd><p>Copy lattice parameters and run through all lattice elements</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> – Dictionary of Lattice attributes</p></li>
<li><p><strong>lattice</strong> – Input <code class="docutils literal notranslate"><span class="pre">Lattice</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p>lattice <code class="docutils literal notranslate"><span class="pre">Elements</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.lattice_object.no_filter">
<span class="sig-name descname"><span class="pre">no_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elems</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.no_filter" title="Permalink to this definition">#</a></dt>
<dd><p>Run through all elements without any check</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> – Dictionary of Lattice attributes</p></li>
<li><p><strong>elems</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Iterable" title="(in Python v3.10)"><em>Iterable</em></a><em>[</em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>]</em>) – Iterable of lattice <code class="docutils literal notranslate"><span class="pre">Elements</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p>lattice <code class="docutils literal notranslate"><span class="pre">Elements</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.lattice_object.params_filter">
<span class="sig-name descname"><span class="pre">params_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elem_filter</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.params_filter" title="Permalink to this definition">#</a></dt>
<dd><p>Run through all elements, looking for energy and periodicity.
Remove the Energy attribute of non-radiating elements</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> – Dictionary of Lattice attributes</p></li>
<li><p><strong>elem_filter</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.10)"><em>Callable</em></a><em>[</em><em>[</em><em>...</em><em>]</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Iterable" title="(in Python v3.10)"><em>Iterable</em></a><em>[</em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>]</em><em>]</em>) – Next <code class="docutils literal notranslate"><span class="pre">Elements</span></code> filter</p></li>
<li><p><strong>args</strong> – Arguments forwarded to <strong>elem_filter</strong></p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p>lattice <code class="docutils literal notranslate"><span class="pre">Elements</span></code></p>
</dd>
</dl>
<dl class="simple">
<dt>energy is taken from:</dt><dd><ol class="arabic simple">
<li><p>The params dictionary</p></li>
<li><p>Cavity elements</p></li>
<li><p>Any other element</p></li>
</ol>
</dd>
<dt>periodicity is taken from:</dt><dd><ol class="arabic simple">
<li><p>The params dictionary</p></li>
<li><p>Sum of the bending angles of magnets</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="at.lattice.lattice_object.type_filter">
<span class="sig-name descname"><span class="pre">type_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elems</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#at.lattice.lattice_object.type_filter" title="Permalink to this definition">#</a></dt>
<dd><p>Run through all elements and check element validity.
Analyse elements for radiation state</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> – Dictionary of Lattice attributes</p></li>
<li><p><strong>elems</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Iterable" title="(in Python v3.10)"><em>Iterable</em></a><em>[</em><a class="reference internal" href="at.lattice.elements.html#at.lattice.elements.Element" title="at.lattice.elements.Element"><em>Element</em></a><em>]</em>) – Iterable of lattice <code class="docutils literal notranslate"><span class="pre">Elements</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p>lattice <code class="docutils literal notranslate"><span class="pre">Elements</span></code></p>
</dd>
</dl>
</dd></dl>

</section>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="at.lattice.elements.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">at.lattice.elements</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="at.lattice.options.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">at.lattice.options</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2022, ATCollab.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>