\hypertarget{namespaceat_1_1tracking_1_1patpass}{}\doxysection{at.\+tracking.\+patpass Namespace Reference}
\label{namespaceat_1_1tracking_1_1patpass}\index{at.tracking.patpass@{at.tracking.patpass}}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceat_1_1tracking_1_1patpass_a9c6a6f36f1beda34bdbdb8583f0441bc}\label{namespaceat_1_1tracking_1_1patpass_a9c6a6f36f1beda34bdbdb8583f0441bc}} 
def {\bfseries format\+\_\+results} (results, r\+\_\+in, losses)
\item 
def \mbox{\hyperlink{namespaceat_1_1tracking_1_1patpass_a13fd6cb2f7a3cf52f0a15661f3bb96f6}{patpass}} (ring, r\+\_\+in, nturns=1, refpts=None, pool\+\_\+size=None, start\+\_\+method=None, $\ast$$\ast$kwargs)
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceat_1_1tracking_1_1patpass_a0182fd463589eacf63713e113e818318}\label{namespaceat_1_1tracking_1_1patpass_a0182fd463589eacf63713e113e818318}} 
{\bfseries globring} = None
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Simple parallelisation of atpass() using multiprocessing.
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespaceat_1_1tracking_1_1patpass_a13fd6cb2f7a3cf52f0a15661f3bb96f6}\label{namespaceat_1_1tracking_1_1patpass_a13fd6cb2f7a3cf52f0a15661f3bb96f6}} 
\index{at.tracking.patpass@{at.tracking.patpass}!patpass@{patpass}}
\index{patpass@{patpass}!at.tracking.patpass@{at.tracking.patpass}}
\doxysubsubsection{\texorpdfstring{patpass()}{patpass()}}
{\footnotesize\ttfamily def at.\+tracking.\+patpass.\+patpass (\begin{DoxyParamCaption}\item[{}]{ring,  }\item[{}]{r\+\_\+in,  }\item[{}]{nturns = {\ttfamily 1},  }\item[{}]{refpts = {\ttfamily None},  }\item[{}]{pool\+\_\+size = {\ttfamily None},  }\item[{}]{start\+\_\+method = {\ttfamily None},  }\item[{$\ast$$\ast$}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Simple parallel implementation of atpass().  If more than one particle
is supplied, use multiprocessing to run each particle in a separate
process. In case a single particle is provided or the ring contains
ImpedanceTablePass element, atpass is returned

INPUT:
    ring            lattice description
    r_in:           6xN array: input coordinates of N particles
    nturns:         number of passes through the lattice line
    refpts          elements at which data is returned. It can be:
                    1) an integer in the range [-len(ring), len(ring)-1]
                       selecting the element according to python indexing
                       rules. As a special case, len(ring) is allowed and
                       refers to the end of the last element,
                    2) an ordered list of such integers without duplicates,
                    3) a numpy array of booleans of maximum length
                       len(ring)+1, where selected elements are True.
                    Defaults to None, meaning no refpts, equivelent to
                    passing an empty array for calculation purposes.
    losses          Activate loss maps
    pool_size       number of processes, if None the min(npart,nproc)
                    is used
    start_method    This parameter allows to change the python
                    multiprocessing start method, default=None uses the
                    python defaults that is considered safe.
                    Available parameters: 'fork', 'spawn', 'forkserver'.
                    Default for linux is fork, default for MacOS and
                    Windows is spawn. fork may used for MacOS to speed-up
                    the calculation or to solve Runtime Errors, however it
                    is considered unsafe.
The following keywords overload the lattice value:
    particle:   circulating particle. Default: lattice.particle if
                existing, otherwise Particle('relativistic')
    energy      lattice energy

If 'energy' is not available, relativistic tracking if forced, rest_energy
is ignored.

 OUTPUT:
    (6, N, R, T) array containing output coordinates of N particles
    at R reference points for T turns.
    If losses ==True: {islost,turn,elem,coord} dictionnary containing
    flag for particles lost (True -> particle lost), turn, element and
    coordinates at which the particle is lost. Set to zero for particles
    that survived
\end{DoxyVerb}
 