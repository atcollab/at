<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of atRDTdispersionmeasuredcorrection</title>
  <meta name="keywords" content="atRDTdispersionmeasuredcorrection">
  <meta name="description" content="ATRDTDISPERSIONMEASUREDCORRECTION Makes correction of dispersion based on">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../../index.html">Home</a> &gt;  <a href="../../../../index.html">atmat</a> &gt; <a href="../../../index.html">pubtools</a> &gt; <a href="../../index.html">LatticeTuningFunctions</a> &gt; <a href="../index.html">correction</a> &gt; <a href="index.html">RDT</a> &gt; atRDTdispersionmeasuredcorrection.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../../index.html"><img alt="<" border="0" src="../../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for atmat/pubtools/LatticeTuningFunctions/correction/RDT&nbsp;<img alt=">" border="0" src="../../../../../right.png"></a></td></tr></table>-->

<h1>atRDTdispersionmeasuredcorrection
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../../up.png"></a></h2>
<div class="box"><strong>ATRDTDISPERSIONMEASUREDCORRECTION Makes correction of dispersion based on</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../../up.png"></a></h2>
<div class="box"><strong>function [rcor,inCOD,qs,ss]=atRDTdispersionmeasuredcorrection(rerr,rfit,r0,indBPM,indQCor,indSCor,inCOD,neigSteerer,correctflags,scalefactor,wdisp,ModelRM,steererlimit,printouttext) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">ATRDTDISPERSIONMEASUREDCORRECTION Makes correction of dispersion based on
RDTS
 function [...
    rcor,...            1) corrected lattice
    inCOD,...           2) initial COD (dpp is stored here)
    hs,vs...            3) required steerers strengths (total)
    ]=atdispersionfreesteering(...
     rerr,...           1) AT lattice to correct, dispersion will be taken
                           from this lattice
     rfit,...           2) AT lattice with fitted errors
                           optics will be taken from this lattice
     r0, ...            3) 2xNbpm reference rdt to correct to
     indBPM,...         4) Nbx1 bpm indexes       (default: monitor)
     indQCor,...        5) Nqx1 quad. cor indexes (default: quadrupole)
     indSCor,...        6) Nsx1 skew. cor indexes (default: sextupole)
     inCOD,...          7) 6x1 initial COD guess  (default: 6x1 zero)
     neigSteerer,...    8) 2xNiter eigenvectors for correction H and V at
                          each iteration (default: [Nh/2 Nv/2])
     correctflags,...   9) correct [ mean0](default: [ true])
     scalefactor,...   10) scale factor to correction (default: 1.0)
     [wdisph wtunes wdispv],...
                       11) dispersion and tune weight:
                           dispersionH*wdisph and orbith*(1-wdisph-wtune)
                           dispersionV*wdispv and orbith*(1-wdispv)                          
                           (default: 0.7 0.1 0.7)
     ModelRM,...       12) ModelRM.Disp(N/S)Quad = 6x1 cell of dispersion 
                           response mat. if [] compute RM (default: [])
                           (default 0*2xNb, or from r0 if reftune is r0)
     steererlimit      13) 2x1 limit of steerers abs(steerer)&lt;steererlimit
                           (default: [], no limits)
     printouttext      14) if 1 or true, display rms orbit
     )

 features impelemented:
 - limit correctors strengths
 - ddp correction
 - sum of steerers = 0
 - 6D orbit with BPM errors
 - initial coordinate
 - correction to reference rdt tune dispersion from r0 lattice
 - retrival of normal and skew quadrupole components also from alignment
   errors and rotations
 - use atsetfieldvalues, atgetcells


 http://journals.aps.org/prab/abstract/10.1103/PhysRevSTAB.14.034002

see also: qemsvd_mod findorbit6Err getresponsematrices</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../../matlabicon.gif)">
<li><a href="EquivalentGradientsFromAlignments6D.html" class="code" title="function [kn,ks,ind]=EquivalentGradientsFromAlignments6D(r,inCOD)">EquivalentGradientsFromAlignments6D</a>	EQUIVALENTGRADIENTSFROMALIGNMENTS6D Estimated normal quad gradients from sext offsets</li><li><a href="qemrdtresp_mod.html" class="code" title="function [fx,fz,qcor]=qemrdtresp_mod(mach,bpmidx,qcoridx)">qemrdtresp_mod</a>	QEMRDTRESP  compute resonance driving terms at BPM locations</li><li><a href="semrdtresp_mod.html" class="code" title="function [f1,f2,skew]=semrdtresp_mod(mach,bpmidx,skewidx)">semrdtresp_mod</a>	SEMRDT compute resonance driving terms at BPM locations</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../../../matlabicon.gif)">
<li><a href="testRDTdispersionfreesteering.html" class="code" title="">testRDTdispersionfreesteering</a>	test errors and correction functions</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [rcor,inCOD,qs,ss]=atRDTdispersionmeasuredcorrection(</a><span class="keyword">...</span>
0002     rerr,<span class="keyword">...</span>
0003     rfit,<span class="keyword">...</span>
0004     r0,<span class="keyword">...</span>
0005     indBPM,<span class="keyword">...</span>
0006     indQCor,<span class="keyword">...</span>
0007     indSCor,<span class="keyword">...</span>
0008     inCOD,<span class="keyword">...</span>
0009     neigSteerer,<span class="keyword">...</span>
0010     correctflags,<span class="keyword">...</span>
0011     scalefactor,<span class="keyword">...</span>
0012     wdisp,<span class="keyword">...</span>
0013     ModelRM,<span class="keyword">...</span>
0014     steererlimit,<span class="keyword">...</span>
0015     printouttext)
0016 <span class="comment">%ATRDTDISPERSIONMEASUREDCORRECTION Makes correction of dispersion based on</span>
0017 <span class="comment">%RDTS</span>
0018 <span class="comment">% function [...</span>
0019 <span class="comment">%    rcor,...            1) corrected lattice</span>
0020 <span class="comment">%    inCOD,...           2) initial COD (dpp is stored here)</span>
0021 <span class="comment">%    hs,vs...            3) required steerers strengths (total)</span>
0022 <span class="comment">%    ]=atdispersionfreesteering(...</span>
0023 <span class="comment">%     rerr,...           1) AT lattice to correct, dispersion will be taken</span>
0024 <span class="comment">%                           from this lattice</span>
0025 <span class="comment">%     rfit,...           2) AT lattice with fitted errors</span>
0026 <span class="comment">%                           optics will be taken from this lattice</span>
0027 <span class="comment">%     r0, ...            3) 2xNbpm reference rdt to correct to</span>
0028 <span class="comment">%     indBPM,...         4) Nbx1 bpm indexes       (default: monitor)</span>
0029 <span class="comment">%     indQCor,...        5) Nqx1 quad. cor indexes (default: quadrupole)</span>
0030 <span class="comment">%     indSCor,...        6) Nsx1 skew. cor indexes (default: sextupole)</span>
0031 <span class="comment">%     inCOD,...          7) 6x1 initial COD guess  (default: 6x1 zero)</span>
0032 <span class="comment">%     neigSteerer,...    8) 2xNiter eigenvectors for correction H and V at</span>
0033 <span class="comment">%                          each iteration (default: [Nh/2 Nv/2])</span>
0034 <span class="comment">%     correctflags,...   9) correct [ mean0](default: [ true])</span>
0035 <span class="comment">%     scalefactor,...   10) scale factor to correction (default: 1.0)</span>
0036 <span class="comment">%     [wdisph wtunes wdispv],...</span>
0037 <span class="comment">%                       11) dispersion and tune weight:</span>
0038 <span class="comment">%                           dispersionH*wdisph and orbith*(1-wdisph-wtune)</span>
0039 <span class="comment">%                           dispersionV*wdispv and orbith*(1-wdispv)</span>
0040 <span class="comment">%                           (default: 0.7 0.1 0.7)</span>
0041 <span class="comment">%     ModelRM,...       12) ModelRM.Disp(N/S)Quad = 6x1 cell of dispersion</span>
0042 <span class="comment">%                           response mat. if [] compute RM (default: [])</span>
0043 <span class="comment">%                           (default 0*2xNb, or from r0 if reftune is r0)</span>
0044 <span class="comment">%     steererlimit      13) 2x1 limit of steerers abs(steerer)&lt;steererlimit</span>
0045 <span class="comment">%                           (default: [], no limits)</span>
0046 <span class="comment">%     printouttext      14) if 1 or true, display rms orbit</span>
0047 <span class="comment">%     )</span>
0048 <span class="comment">%</span>
0049 <span class="comment">% features impelemented:</span>
0050 <span class="comment">% - limit correctors strengths</span>
0051 <span class="comment">% - ddp correction</span>
0052 <span class="comment">% - sum of steerers = 0</span>
0053 <span class="comment">% - 6D orbit with BPM errors</span>
0054 <span class="comment">% - initial coordinate</span>
0055 <span class="comment">% - correction to reference rdt tune dispersion from r0 lattice</span>
0056 <span class="comment">% - retrival of normal and skew quadrupole components also from alignment</span>
0057 <span class="comment">%   errors and rotations</span>
0058 <span class="comment">% - use atsetfieldvalues, atgetcells</span>
0059 <span class="comment">%</span>
0060 <span class="comment">%</span>
0061 <span class="comment">% http://journals.aps.org/prab/abstract/10.1103/PhysRevSTAB.14.034002</span>
0062 <span class="comment">%</span>
0063 <span class="comment">%see also: qemsvd_mod findorbit6Err getresponsematrices</span>
0064 
0065 
0066 
0067 <span class="comment">% response matrix kicks</span>
0068 <span class="comment">%kval=1e-5;</span>
0069 delta=1e-3;
0070 
0071 <span class="comment">% default arguments</span>
0072 <span class="keyword">if</span> nargin&lt;14
0073     printouttext=true;
0074 <span class="keyword">end</span>
0075 <span class="keyword">if</span> nargin&lt;13
0076     steererlimit=[];
0077 <span class="keyword">end</span>
0078 
0079 <span class="keyword">if</span> nargin&lt;6
0080     <span class="keyword">if</span> printouttext
0081         disp(<span class="string">'get BPM and Correctors indexes'</span>); <span class="keyword">end</span>;
0082     indBPM=finc(atgetcells(rfit,<span class="string">'Class'</span>,<span class="string">'Monitor'</span>));
0083     indQCor=finc(atgetcells(rfit,<span class="string">'Class'</span>,<span class="string">'Quadrupole'</span>));
0084     indSCor=finc(atgetcells(rfit,<span class="string">'Class'</span>,<span class="string">'Sextupole'</span>));
0085 <span class="keyword">end</span>
0086 
0087 <span class="keyword">if</span> nargin&lt;7
0088     inCOD=[0 0 0 0 0 0]';
0089 <span class="keyword">end</span>
0090 
0091 <span class="keyword">if</span> nargin&lt;8
0092     neigSteerer=[length(indQCor) length(indSCor)]/2;
0093 <span class="keyword">end</span>
0094 
0095 <span class="keyword">if</span> nargin&lt;9
0096     correctflags=true;
0097 <span class="keyword">end</span>
0098 
0099 <span class="keyword">if</span> nargin&lt;10
0100     <span class="keyword">if</span> printouttext
0101         disp(<span class="string">' --- scale set to 1.0'</span>); <span class="keyword">end</span>;
0102     scalefactor=1.0;
0103 <span class="keyword">end</span>
0104 
0105 <span class="keyword">if</span> nargin&lt;11
0106     <span class="keyword">if</span> printouttext, disp(<span class="string">' --- wdisph=0.7 wtune=0.1 wdispv=0.7'</span>); <span class="keyword">end</span>;
0107     wdisp=[.7 .1 .7];
0108 <span class="keyword">end</span>
0109 
0110 <span class="keyword">if</span> nargin&lt;12
0111     <span class="keyword">if</span> printouttext, disp(<span class="string">' --- computing orbit Response matrix'</span>); <span class="keyword">end</span>;
0112     ModelRM=[];
0113 <span class="keyword">end</span>
0114 
0115 
0116 <span class="keyword">if</span> scalefactor&lt;0 || scalefactor&gt;1
0117     <span class="keyword">if</span> printouttext
0118         disp(<span class="string">' --- scale factor out of range. Set to 1.0'</span>); <span class="keyword">end</span>;
0119     scalefactor=1.0;
0120 <span class="keyword">end</span>
0121 
0122 
0123 <span class="comment">% load or compute response matrix</span>
0124 <span class="keyword">if</span> isempty(ModelRM)
0125     <span class="comment">% get orbit RM</span>
0126     <span class="keyword">if</span> printouttext
0127         disp(<span class="string">'get RM'</span>); <span class="keyword">end</span>;
0128     
0129     
0130         ModelRM=getresponsematrices(<span class="keyword">...</span>
0131             rfit,<span class="keyword">...</span><span class="comment">          %1 AT lattice</span>
0132             indBPM,<span class="keyword">...</span><span class="comment">      %2 bpm indexes in at lattice</span>
0133             [],<span class="keyword">...</span><span class="comment">     %3 h cor indexes</span>
0134             [],<span class="keyword">...</span><span class="comment">     %4 v cor indexes</span>
0135             indSCor,<span class="keyword">...</span><span class="comment">     %5 skew cor indexes</span>
0136             indQCor,<span class="keyword">...</span><span class="comment">     %6 quad cor indexes</span>
0137             [],<span class="keyword">...</span>
0138             inCOD,<span class="keyword">...</span><span class="comment">       %7 initial coordinates</span>
0139             [10 11 12]<span class="keyword">...</span><span class="comment">        %8 specifiy rm to be computed</span>
0140             );
0141         
0142     
0143 <span class="keyword">end</span>
0144 
0145 <span class="comment">% load RM computed by getresponsematrices</span>
0146 
0147 drmQ=ModelRM.DispQCor;
0148 drmS=ModelRM.DispSCor;
0149 
0150 
0151 tuneQ=[ModelRM.TuneQCor{1};ModelRM.TuneQCor{2}];
0152 
0153 <span class="comment">% quad RDT RM</span>
0154 [~,~,ind]=<a href="EquivalentGradientsFromAlignments6D.html" class="code" title="function [kn,ks,ind]=EquivalentGradientsFromAlignments6D(r,inCOD)">EquivalentGradientsFromAlignments6D</a>(rfit,inCOD);
0155 indAllQuad=ind;
0156 indAllSkew=ind;
0157 
0158 <span class="comment">%indAllQuad=[indQCor indSCor];</span>
0159 <span class="comment">%indAllSkew=[indQCor indSCor];</span>
0160 
0161 [respqx,respqz]=<a href="qemrdtresp_mod.html" class="code" title="function [fx,fz,qcor]=qemrdtresp_mod(mach,bpmidx,qcoridx)">qemrdtresp_mod</a>(rfit,indBPM,indAllQuad);    <span class="comment">% RDT response matrix assumes K=1</span>
0162 QL=atgetfieldvalues(rfit,indAllQuad,<span class="string">'Length'</span>);          <span class="comment">% quadrupole lengths</span>
0163 QL(QL==0)=1;<span class="comment">% thin lens magnets</span>
0164 
0165 <span class="comment">% convert response from KL to K as for dispersion response matrix</span>
0166 <span class="comment">% this is needed to merge the RM with the dispersion RM in the final</span>
0167 <span class="comment">% computation of correction.</span>
0168 lengthsmat=repmat(QL',length(indBPM),1);
0169 respqx=respqx.*lengthsmat;
0170 respqz=respqz.*lengthsmat;
0171 
0172 [~,qkcor]=ismember(indQCor,indAllQuad);
0173 rdtQ=[<span class="keyword">...</span>
0174     real(respqx(:,qkcor));<span class="keyword">...</span>
0175     imag(respqx(:,qkcor));<span class="keyword">...</span>
0176     real(respqz(:,qkcor));<span class="keyword">...</span>
0177     imag(respqz(:,qkcor))];
0178 
0179 
0180 <span class="comment">% skew RDT RM</span>
0181 [respsx,respsz]=<a href="semrdtresp_mod.html" class="code" title="function [f1,f2,skew]=semrdtresp_mod(mach,bpmidx,skewidx)">semrdtresp_mod</a>(rfit,indBPM,indAllSkew);    <span class="comment">% RDT response matrix assumes K=1</span>
0182 SL=atgetfieldvalues(rfit,indAllSkew,<span class="string">'Length'</span>);          <span class="comment">% quadrupole lengths</span>
0183 SL(SL==0)=1;<span class="comment">% thin lens magnets</span>
0184 lengthsmat=repmat(SL',length(indBPM),1);
0185 respsx=respsx.*lengthsmat;
0186 respsz=respsz.*lengthsmat;
0187 
0188 [~,skcor]=ismember(indSCor,indAllSkew);
0189 rdtS=[<span class="keyword">...</span>
0190     real(respsx(:,skcor));<span class="keyword">...</span>
0191     imag(respsx(:,skcor));<span class="keyword">...</span>
0192     real(respsz(:,skcor));<span class="keyword">...</span>
0193     imag(respsz(:,skcor))];
0194 
0195 
0196 inCOD=[0 0 0 0 0 0]';
0197 [l,t,~]=atlinopt(r0,0,indBPM);
0198 refdispersion=zeros(2,length(indBPM));
0199 refdispersion(1,:)=arrayfun(@(a)a.Dispersion(1),l);
0200 refdispersion(2,:)=arrayfun(@(a)a.Dispersion(3),l);
0201 reftune=t;
0202 
0203 [KQnoer,KSnoer,~]=<a href="EquivalentGradientsFromAlignments6D.html" class="code" title="function [kn,ks,ind]=EquivalentGradientsFromAlignments6D(r,inCOD)">EquivalentGradientsFromAlignments6D</a>(r0,inCOD);
0204 <span class="comment">%KQnoer=atgetfieldvalues(r0,indAllQuad,'PolynomB',{1,2});</span>
0205 <span class="comment">%KSnoer=atgetfieldvalues(r0,indAllSkew,'PolynomA',{1,2});</span>
0206 
0207 fx=respqx*KQnoer;
0208 fz=respqz*KQnoer;
0209 rdtvecq=[<span class="keyword">...</span>
0210     real(fx);<span class="keyword">...</span>
0211     imag(fx);<span class="keyword">...</span>
0212     real(fz);<span class="keyword">...</span>
0213     imag(fz)]';
0214 
0215 fx=respsx*KSnoer;
0216 fz=respsz*KSnoer;
0217 rdtvecs=[<span class="keyword">...</span>
0218     real(fx);<span class="keyword">...</span>
0219     imag(fx);<span class="keyword">...</span>
0220     real(fz);<span class="keyword">...</span>
0221     imag(fz)]';
0222 
0223 refrdt(1,:)=rdtvecq;
0224 refrdt(2,:)=rdtvecs;
0225 
0226 
0227 
0228 <span class="comment">% get rdt vectors to correct</span>
0229 [KQi,KSi,~]=<a href="EquivalentGradientsFromAlignments6D.html" class="code" title="function [kn,ks,ind]=EquivalentGradientsFromAlignments6D(r,inCOD)">EquivalentGradientsFromAlignments6D</a>(rfit,inCOD);
0230 <span class="comment">%KQ=atgetfieldvalues(rerr,indAllQuad,'PolynomB',{1,2});</span>
0231 <span class="comment">%KS=atgetfieldvalues(rerr,indAllSkew,'PolynomA',{1,2});</span>
0232 
0233 fx=respqx*KQi;
0234 fz=respqz*KQi;
0235 rq0=[<span class="keyword">...</span>
0236     real(fx);<span class="keyword">...</span>
0237     imag(fx);<span class="keyword">...</span>
0238     real(fz);<span class="keyword">...</span>
0239     imag(fz)]';
0240 
0241 fx=respsx*KSi;
0242 fz=respsz*KSi;
0243 rs0=[<span class="keyword">...</span>
0244     real(fx);<span class="keyword">...</span>
0245     imag(fx);<span class="keyword">...</span>
0246     real(fz);<span class="keyword">...</span>
0247     imag(fz)]';
0248 
0249 
0250 alpha=mcf(rfit);
0251 indrfc=find(atgetcells(rfit,<span class="string">'Frequency'</span>));
0252 
0253 <span class="comment">% get initial dispersion</span>
0254 
0255 d=finddispersion6Err(rerr,indBPM,indrfc,alpha,delta,inCOD);
0256 dx0=d(1,:);
0257 dy0=d(3,:);
0258 
0259 <span class="comment">% get initial tune</span>
0260 [~,t0,~]=atlinopt(rerr,0,1);
0261 
0262 <span class="comment">%rerr0=rerr;</span>
0263  qs0=atgetfieldvalues(rfit,indQCor,<span class="string">'PolynomB'</span>,{1,2});
0264  ss0=atgetfieldvalues(rfit,indSCor,<span class="string">'PolynomA'</span>,{1,2});
0265  qse0=atgetfieldvalues(rerr,indQCor,<span class="string">'PolynomB'</span>,{1,2});
0266  sse0=atgetfieldvalues(rerr,indSCor,<span class="string">'PolynomA'</span>,{1,2});
0267       
0268 <span class="comment">% iterate correction</span>
0269 Niter=size(neigSteerer,1);
0270 <span class="keyword">for</span> iter=1:Niter
0271     
0272     <span class="keyword">if</span> printouttext
0273         disp([<span class="string">'RDT Disp. Tune Steering iter '</span> num2str(iter,<span class="string">'%d, '</span>) <span class="keyword">...</span>
0274             <span class="string">' n-eig: '</span> num2str(neigSteerer(iter,:),<span class="string">'%d, '</span>) <span class="keyword">...</span>
0275             <span class="string">' alpha: '</span> num2str(wdisp,<span class="string">'%2.2f '</span>)]);
0276     <span class="keyword">end</span>
0277     
0278     <span class="comment">% initial corrector strengths</span>
0279     corq0=atgetfieldvalues(rfit,indQCor,<span class="string">'PolynomB'</span>,{1,2});
0280     cors0=atgetfieldvalues(rfit,indSCor,<span class="string">'PolynomA'</span>,{1,2});
0281     corqe0=atgetfieldvalues(rerr,indQCor,<span class="string">'PolynomB'</span>,{1,2});
0282     corse0=atgetfieldvalues(rerr,indSCor,<span class="string">'PolynomA'</span>,{1,2});
0283     
0284     
0285     <span class="comment">% get current rdt vectors to correct</span>
0286     [KQe,KSe,~]=<a href="EquivalentGradientsFromAlignments6D.html" class="code" title="function [kn,ks,ind]=EquivalentGradientsFromAlignments6D(r,inCOD)">EquivalentGradientsFromAlignments6D</a>(rfit,inCOD);
0287     <span class="comment">%KQ=atgetfieldvalues(rerr,indAllQuad,'PolynomB',{1,2});</span>
0288     <span class="comment">%KS=atgetfieldvalues(rerr,indAllSkew,'PolynomA',{1,2});</span>
0289     
0290     fx=respqx*KQe;
0291     fz=respqz*KQe;
0292     rq=[<span class="keyword">...</span>
0293         real(fx);<span class="keyword">...</span>
0294         imag(fx);<span class="keyword">...</span>
0295         real(fz);<span class="keyword">...</span>
0296         imag(fz)]';
0297     
0298     fx=respsx*KSe;
0299     fz=respsz*KSe;
0300     rs=[<span class="keyword">...</span>
0301         real(fx);<span class="keyword">...</span>
0302         imag(fx);<span class="keyword">...</span>
0303         real(fz);<span class="keyword">...</span>
0304         imag(fz)]';
0305     
0306     <span class="comment">% get current dispersion</span>
0307     d=finddispersion6Err(rerr,indBPM,indrfc,alpha,delta,inCOD);
0308     dx=d(1,:);
0309     dy=d(3,:);
0310     <span class="comment">% get current tune</span>
0311     [~,t,~]=atlinopt(rerr,0,1);
0312     
0313     
0314     <span class="comment">% subtract reference orbit</span>
0315     rq=rq-refrdt(1,:);
0316     rs=rs-refrdt(2,:);
0317     <span class="comment">% subtract reference dispersion</span>
0318     dx=dx-refdispersion(1,:);
0319     dy=dy-refdispersion(2,:);
0320     <span class="comment">% subtract reference tune</span>
0321     t=t-reftune;
0322     
0323     <span class="comment">% weigths between RDT, tune and dispersion</span>
0324     rq=rq*(1-wdisp(1)-wdisp(2));
0325     rs=rs*(1-wdisp(3));
0326     dx=dx*(wdisp(1));
0327     dy=dy*(wdisp(3));
0328     t=t*(wdisp(2));
0329     
0330     <span class="comment">% build RMs</span>
0331     <span class="keyword">if</span>  correctflags(1) <span class="comment">% mean0 no dpp</span>
0332         RMQ=[rdtQ*(1-wdisp(1)-wdisp(2));drmQ{1}*(wdisp(1));tuneQ*(wdisp(2));ones(size(indQCor))];
0333         <span class="comment">%RMQ=[rdtQ*(1-wdisp(1));drmQ{1}*(wdisp(1));ones(size(indQCor))];</span>
0334         RMS=[rdtS*(1-wdisp(3));drmS{3}*(wdisp(3));ones(size(indSCor))];
0335     <span class="keyword">elseif</span> ~correctflags(1) <span class="comment">% no dpp no mean0</span>
0336         RMQ=[rdtQ*(1-wdisp(1)-wdisp(2));drmQ{1}*(wdisp(1));tuneQ*(wdisp(2))];
0337         <span class="comment">%RMQ=[rdtQ*(1-wdisp(1));drmQ{1}*(wdisp(1))];</span>
0338         RMS=[rdtS*(1-wdisp(3));drmS{3}*(wdisp(3))];
0339     <span class="keyword">end</span>
0340     
0341     <span class="comment">% compute correction</span>
0342     <span class="keyword">if</span> correctflags(1) <span class="comment">% mean = 0</span>
0343         vecq=[rq dx t 0]';
0344         <span class="comment">%vecq=[rq dx 0]';</span>
0345         vecs=[rs dy 0]';
0346     <span class="keyword">else</span> <span class="comment">% no constraint on correctors mean</span>
0347         vecq=[rq dx t]';
0348         <span class="comment">%vecq=[rq dx]';</span>
0349         vecs=[rs dy]';
0350     <span class="keyword">end</span>
0351     
0352     dcq=qemsvd_mod(RMQ,vecq,neigSteerer(iter,1));
0353     dcs=qemsvd_mod(RMS,vecs,neigSteerer(iter,2));
0354     
0355     <span class="comment">% get total correctors values and apply scaling</span>
0356     
0357     qs=corq0-dcq*scalefactor;
0358     ss=cors0-dcs*scalefactor;
0359     qse=corqe0-dcq*scalefactor;
0360     sse=corse0-dcs*scalefactor;
0361     
0362     <span class="comment">% limit steerers strengths</span>
0363     <span class="keyword">if</span> ~isempty(steererlimit)
0364         qs(abs(qs)&gt;steererlimit(1))=steererlimit(1);
0365         ss(abs(ss)&gt;steererlimit(2))=steererlimit(2);
0366         qse(abs(qse)&gt;steererlimit(1))=steererlimit(1);
0367         sse(abs(sse)&gt;steererlimit(2))=steererlimit(2);
0368     <span class="keyword">end</span>
0369     
0370     <span class="comment">% apply correction in lattice fitted and errors (for dispersion)</span>
0371     rfit=atsetfieldvalues(rfit,indQCor,<span class="string">'PolynomB'</span>,{1,2},qs);
0372     rfit=atsetfieldvalues(rfit,indSCor,<span class="string">'PolynomA'</span>,{1,2},ss);
0373     
0374     rerr=atsetfieldvalues(rerr,indQCor,<span class="string">'PolynomB'</span>,{1,2},qse);
0375     rerr=atsetfieldvalues(rerr,indSCor,<span class="string">'PolynomA'</span>,{1,2},sse);
0376    
0377     <span class="comment">% lattice corrected</span>
0378     rcor=rfit;
0379 <span class="keyword">end</span>
0380 
0381 
0382 <span class="comment">% get current rdt vectors to correct</span>
0383 [KQ,KS,~]=<a href="EquivalentGradientsFromAlignments6D.html" class="code" title="function [kn,ks,ind]=EquivalentGradientsFromAlignments6D(r,inCOD)">EquivalentGradientsFromAlignments6D</a>(rcor,inCOD);
0384 <span class="comment">%KQ=atgetfieldvalues(rcor,indQCor,'PolynomB',{1,2});</span>
0385 <span class="comment">%KS=atgetfieldvalues(rcor,indAllSkew,'PolynomA',{1,2});</span>
0386 
0387 fx=respqx*KQ;
0388 fz=respqz*KQ;
0389 rqc=[<span class="keyword">...</span>
0390     real(fx);<span class="keyword">...</span>
0391     imag(fx);<span class="keyword">...</span>
0392     real(fz);<span class="keyword">...</span>
0393     imag(fz)]';
0394 
0395 fx=respsx*KS;
0396 fz=respsz*KS;
0397 rsc=[<span class="keyword">...</span>
0398     real(fx);<span class="keyword">...</span>
0399     imag(fx);<span class="keyword">...</span>
0400     real(fz);<span class="keyword">...</span>
0401     imag(fz)]';
0402 
0403 <span class="comment">% get current dispersion</span>
0404 d=finddispersion6Err(rcor,indBPM,indrfc,alpha,delta,inCOD);
0405 dxc=d(1,:);
0406 dyc=d(3,:);
0407 <span class="comment">% get current tune</span>
0408 [~,tc,~]=atlinopt(rcor,0,1);
0409 
0410 
0411 <span class="keyword">if</span> printouttext
0412     <span class="comment">% display results</span>
0413     disp([<span class="string">'        before'</span> <span class="string">'    '</span> <span class="string">'--&gt;'</span> <span class="string">'    '</span> <span class="string">'after'</span>])
0414     disp([<span class="string">'rq: '</span> num2str(std(rq0-refrdt(1,:))*1e3,<span class="string">'%3.3f'</span>) <span class="string">' -&gt; '</span> num2str(std(rqc-refrdt(1,:))*1e3,<span class="string">'%3.3f'</span>) <span class="string">''</span>]);
0415     disp([<span class="string">'rs: '</span> num2str(std(rs0-refrdt(2,:))*1e3,<span class="string">'%3.3f'</span>) <span class="string">' -&gt; '</span> num2str(std(rsc-refrdt(2,:))*1e3,<span class="string">'%3.3f'</span>) <span class="string">''</span>]);
0416     disp([<span class="string">'dX: '</span> num2str(std(dx0-refdispersion(1,:))*1e3,<span class="string">'%3.3f'</span>) <span class="string">' -&gt; '</span> num2str(std(dxc-refdispersion(1,:))*1e3,<span class="string">'%3.3f'</span>) <span class="string">'mm'</span>])
0417     disp([<span class="string">'dY: '</span> num2str(std(dy0-refdispersion(2,:))*1e3,<span class="string">'%3.3f'</span>) <span class="string">' -&gt; '</span> num2str(std(dyc-refdispersion(2,:))*1e3,<span class="string">'%3.3f'</span>) <span class="string">'mm'</span>])
0418     disp([<span class="string">'tX: '</span> num2str((t0(1)-reftune(1)),<span class="string">'%3.3f'</span>) <span class="string">' -&gt; '</span> num2str((tc(1)-reftune(1)),<span class="string">'%3.3f'</span>) <span class="string">''</span>])
0419     disp([<span class="string">'tY: '</span> num2str((t0(2)-reftune(2)),<span class="string">'%3.3f'</span>) <span class="string">' -&gt; '</span> num2str((tc(2)-reftune(2)),<span class="string">'%3.3f'</span>) <span class="string">''</span>])
0420     disp([<span class="string">'    '</span> <span class="string">'min'</span> <span class="string">'    '</span> <span class="string">'mean'</span> <span class="string">'    '</span> <span class="string">'max'</span>])
0421     disp([<span class="string">'qs:'</span>  num2str([min(qs-qs0) mean(qs-qs0) max(qs-qs0)]*1e0,<span class="string">' %2.2f '</span>) <span class="string">' 1/m2'</span>])
0422     disp([<span class="string">'ss:'</span>  num2str([min(ss-ss0) mean(ss-ss0) max(ss-ss0)]*1e0,<span class="string">' %2.2f '</span>) <span class="string">' 1/m2'</span>])
0423     disp([<span class="string">'dpp: '</span> num2str(inCOD(5))])
0424     
0425    
0426 <span class="comment">%     figure;</span>
0427 <span class="comment">%     subplot(4,1,1);</span>
0428 <span class="comment">%     plot(rq0-refrdt(1,:),'r'); hold on;</span>
0429 <span class="comment">%     plot(rqc-refrdt(1,:),'b');</span>
0430 <span class="comment">%     legend('before','after')</span>
0431 <span class="comment">%     subplot(4,1,2);</span>
0432 <span class="comment">%     plot(rs0-refrdt(2,:),'r'); hold on;</span>
0433 <span class="comment">%     plot(rsc-refrdt(2,:),'b');</span>
0434 <span class="comment">%     subplot(4,1,3);</span>
0435 <span class="comment">%     plot(dx0-refdispersion(1,:),'r'); hold on;</span>
0436 <span class="comment">%     plot(dxc-refdispersion(1,:),'b');</span>
0437 <span class="comment">%     subplot(4,1,4);</span>
0438 <span class="comment">%     plot(dy0-refdispersion(2,:),'r'); hold on;</span>
0439 <span class="comment">%     plot(dyc-refdispersion(2,:),'b');</span>
0440 <span class="comment">%     saveas(gca,['RDTdispCor' num2str(wdisp,'%2.2f_') '.fig']);</span>
0441 <span class="comment">%     export_fig(['RDTdispCor' num2str(wdisp,'%2.2f_') '.jpg']);</span>
0442 <span class="comment">% %</span>
0443 <span class="comment">%</span>
0444 <span class="keyword">end</span>
0445 
0446 
0447 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Mon 05-Mar-2018 10:51:40 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>