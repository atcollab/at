<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of distance2curve</title>
  <meta name="keywords" content="distance2curve">
  <meta name="description" content="DISTANCE2CURVE Gets the minimum distance from a point to a general curvilinear n-dimensional arc">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">atmat</a> &gt; <a href="../index.html">pubtools</a> &gt; <a href="index.html">distance2curve</a> &gt; distance2curve.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for atmat/pubtools/distance2curve&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>distance2curve
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>DISTANCE2CURVE Gets the minimum distance from a point to a general curvilinear n-dimensional arc</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [xy,distance,t_a] = distance2curve(curvexy,mapxy,interpmethod) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">DISTANCE2CURVE Gets the minimum distance from a point to a general curvilinear n-dimensional arc
 usage: [xy,distance,t] = distance2curve(curvexy,mapxy) % uses linear curve segments
 usage: [xy,distance,t] = distance2curve(curvexy,mapxy,interpmethod)

 Identifies the closest point along a general space curve (a 1-d path
 in some space) to some new set of points. The curve may be piecewise
 linear or a parametric spline or pchip model.

 arguments: (input)
  curvexy - An nxp real numeric array containing the points of the
        curve. For 2-dimensional curves, p == 2. This will be a list
        of points (each row of the array is a new point) that
        define the curve. The curve may cross itself in space.
        Closed curves are acceptable, in which case the first
        and last points would be identical. (Sorry, but periodic
        end conditions are not an option for the spline at this time.)

        Since a curve makes no sense in less than 2 dimensions,
        p &gt;= 2 is required.

  mapxy - an mxp real numeric array, where m is the number of new points
        to be mapped to the curve in term of their closest distance.

        These points which will be mapped to the existing curve
        in terms of the minimium (euclidean, 2-norm) distance
        to the curve. Each row of this array will be a different
        point.

  interpmethod - (OPTIONAL) string flag - denotes the method
        used to compute the arc length of the curve.

        method may be any of 'linear', 'spline', or 'pchip',
        or any simple contraction thereof, such as 'lin',
        'sp', or even 'p'.
        
        interpmethod == 'linear' --&gt; Uses a linear chordal
               approximation to define the curve.
               This method is the most efficient.

        interpmethod == 'pchip' --&gt; Fits a parametric pchip
               approximation.

        interpmethod == 'spline' --&gt; Uses a parametric spline
               approximation to fit the curves. Generally for
               a smooth curve, this method may be most accurate.

        DEFAULT: 'linear'

 arguments: (output)
  xy - an mxp array, contains the closest point identified along
       the curve to each of the points provided in mapxy.

  distance - an mx1 vector, the actual distance to the curve,
       in terms minimum Euclidean distance.

  t  - fractional arc length along the interpolating curve to that
       point. This is the same value that interparc would use to
       produce the points in xy.


 Example:
 % Find the closest points and the distance to a polygonal line from
 % several test points.

 curvexy = [0 0;1 0;2 1;0 .5;0 0];
 mapxy = [3 4;.5 .5;3 -1];
 [xy,distance,t] = distance2curve(curvexy,mapxy,'linear')
 % xy =
 %                          2                         1
 %          0.470588235294118         0.617647058823529
 %                        1.5                       0.5
 % distance =
 %           3.16227766016838
 %          0.121267812518166
 %           2.12132034355964
 % t =
 %          0.485194315877587
 %          0.802026225550702
 %           0.34308419095021


 plot(curvexy(:,1),curvexy(:,2),'k-o',mapxy(:,1),mapxy(:,2),'r*')
 hold on
 plot(xy(:,1),xy(:,2),'g*')
 line([mapxy(:,1),xy(:,1)]',[mapxy(:,2),xy(:,2)]','color',[0 0 1])
 axis equal


 Example:
 % Solve for the nearest point on the curve of a 3-d quasi-elliptical
 % arc (sampled and interpolated from 20 points) mapping a set of points
 % along a surrounding circle onto the ellipse. This is the example
 % used to generate the screenshot figure.
 t = linspace(0,2*pi,20)';
 curvexy = [cos(t) - 1,3*sin(t) + cos(t) - 1.25,(t/2 + cos(t)).*sin(t)];
 
 s = linspace(0,2*pi,100)';
 mapxy = 5*[cos(s),sin(s),sin(s)];
 xy = distance2curve(curvexy,mapxy,'spline');
 
 plot3(curvexy(:,1),curvexy(:,2),curvexy(:,3),'ko')
 line([mapxy(:,1),xy(:,1)]',[mapxy(:,2),xy(:,2)]',[mapxy(:,3),xy(:,3)]','color',[0 0 1])
 axis equal
 axis square
 box on
 grid on
 view(26,-6)


 Example:
 % distance2curve is fairly fast, at least for the linear case.
 % Map 1e6 points onto a polygonal curve in 10 dimensions.
 curvexy = cumsum(rand(10,10));
 mapxy = rand(1000000,10)*5;
 tic,[xy,distance] = distance2curve(curvexy,mapxy,'linear');toc
 % Elapsed time is 2.867453 seconds.


 See also: interparc, spline, pchip, interp1, arclength

 Author: John D'Errico
 e-mail: woodchips@rochester.rr.com
 Release: 1.0
 Release date: 9/22/2010</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function d = ipdm(data1,varargin)</a></li><li><a href="#_sub2" class="code">function d = distcomp(set1,set2,params)</a></li><li><a href="#_sub3" class="code">function params=parse_pv_pairs(params,pv_pairs)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [xy,distance,t_a] = distance2curve(curvexy,mapxy,interpmethod)</a>
0002 <span class="comment">%DISTANCE2CURVE Gets the minimum distance from a point to a general curvilinear n-dimensional arc</span>
0003 <span class="comment">% usage: [xy,distance,t] = distance2curve(curvexy,mapxy) % uses linear curve segments</span>
0004 <span class="comment">% usage: [xy,distance,t] = distance2curve(curvexy,mapxy,interpmethod)</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Identifies the closest point along a general space curve (a 1-d path</span>
0007 <span class="comment">% in some space) to some new set of points. The curve may be piecewise</span>
0008 <span class="comment">% linear or a parametric spline or pchip model.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% arguments: (input)</span>
0011 <span class="comment">%  curvexy - An nxp real numeric array containing the points of the</span>
0012 <span class="comment">%        curve. For 2-dimensional curves, p == 2. This will be a list</span>
0013 <span class="comment">%        of points (each row of the array is a new point) that</span>
0014 <span class="comment">%        define the curve. The curve may cross itself in space.</span>
0015 <span class="comment">%        Closed curves are acceptable, in which case the first</span>
0016 <span class="comment">%        and last points would be identical. (Sorry, but periodic</span>
0017 <span class="comment">%        end conditions are not an option for the spline at this time.)</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%        Since a curve makes no sense in less than 2 dimensions,</span>
0020 <span class="comment">%        p &gt;= 2 is required.</span>
0021 <span class="comment">%</span>
0022 <span class="comment">%  mapxy - an mxp real numeric array, where m is the number of new points</span>
0023 <span class="comment">%        to be mapped to the curve in term of their closest distance.</span>
0024 <span class="comment">%</span>
0025 <span class="comment">%        These points which will be mapped to the existing curve</span>
0026 <span class="comment">%        in terms of the minimium (euclidean, 2-norm) distance</span>
0027 <span class="comment">%        to the curve. Each row of this array will be a different</span>
0028 <span class="comment">%        point.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%  interpmethod - (OPTIONAL) string flag - denotes the method</span>
0031 <span class="comment">%        used to compute the arc length of the curve.</span>
0032 <span class="comment">%</span>
0033 <span class="comment">%        method may be any of 'linear', 'spline', or 'pchip',</span>
0034 <span class="comment">%        or any simple contraction thereof, such as 'lin',</span>
0035 <span class="comment">%        'sp', or even 'p'.</span>
0036 <span class="comment">%</span>
0037 <span class="comment">%        interpmethod == 'linear' --&gt; Uses a linear chordal</span>
0038 <span class="comment">%               approximation to define the curve.</span>
0039 <span class="comment">%               This method is the most efficient.</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%        interpmethod == 'pchip' --&gt; Fits a parametric pchip</span>
0042 <span class="comment">%               approximation.</span>
0043 <span class="comment">%</span>
0044 <span class="comment">%        interpmethod == 'spline' --&gt; Uses a parametric spline</span>
0045 <span class="comment">%               approximation to fit the curves. Generally for</span>
0046 <span class="comment">%               a smooth curve, this method may be most accurate.</span>
0047 <span class="comment">%</span>
0048 <span class="comment">%        DEFAULT: 'linear'</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% arguments: (output)</span>
0051 <span class="comment">%  xy - an mxp array, contains the closest point identified along</span>
0052 <span class="comment">%       the curve to each of the points provided in mapxy.</span>
0053 <span class="comment">%</span>
0054 <span class="comment">%  distance - an mx1 vector, the actual distance to the curve,</span>
0055 <span class="comment">%       in terms minimum Euclidean distance.</span>
0056 <span class="comment">%</span>
0057 <span class="comment">%  t  - fractional arc length along the interpolating curve to that</span>
0058 <span class="comment">%       point. This is the same value that interparc would use to</span>
0059 <span class="comment">%       produce the points in xy.</span>
0060 <span class="comment">%</span>
0061 <span class="comment">%</span>
0062 <span class="comment">% Example:</span>
0063 <span class="comment">% % Find the closest points and the distance to a polygonal line from</span>
0064 <span class="comment">% % several test points.</span>
0065 <span class="comment">%</span>
0066 <span class="comment">% curvexy = [0 0;1 0;2 1;0 .5;0 0];</span>
0067 <span class="comment">% mapxy = [3 4;.5 .5;3 -1];</span>
0068 <span class="comment">% [xy,distance,t] = distance2curve(curvexy,mapxy,'linear')</span>
0069 <span class="comment">% % xy =</span>
0070 <span class="comment">% %                          2                         1</span>
0071 <span class="comment">% %          0.470588235294118         0.617647058823529</span>
0072 <span class="comment">% %                        1.5                       0.5</span>
0073 <span class="comment">% % distance =</span>
0074 <span class="comment">% %           3.16227766016838</span>
0075 <span class="comment">% %          0.121267812518166</span>
0076 <span class="comment">% %           2.12132034355964</span>
0077 <span class="comment">% % t =</span>
0078 <span class="comment">% %          0.485194315877587</span>
0079 <span class="comment">% %          0.802026225550702</span>
0080 <span class="comment">% %           0.34308419095021</span>
0081 <span class="comment">%</span>
0082 <span class="comment">%</span>
0083 <span class="comment">% plot(curvexy(:,1),curvexy(:,2),'k-o',mapxy(:,1),mapxy(:,2),'r*')</span>
0084 <span class="comment">% hold on</span>
0085 <span class="comment">% plot(xy(:,1),xy(:,2),'g*')</span>
0086 <span class="comment">% line([mapxy(:,1),xy(:,1)]',[mapxy(:,2),xy(:,2)]','color',[0 0 1])</span>
0087 <span class="comment">% axis equal</span>
0088 <span class="comment">%</span>
0089 <span class="comment">%</span>
0090 <span class="comment">% Example:</span>
0091 <span class="comment">% % Solve for the nearest point on the curve of a 3-d quasi-elliptical</span>
0092 <span class="comment">% % arc (sampled and interpolated from 20 points) mapping a set of points</span>
0093 <span class="comment">% % along a surrounding circle onto the ellipse. This is the example</span>
0094 <span class="comment">% % used to generate the screenshot figure.</span>
0095 <span class="comment">% t = linspace(0,2*pi,20)';</span>
0096 <span class="comment">% curvexy = [cos(t) - 1,3*sin(t) + cos(t) - 1.25,(t/2 + cos(t)).*sin(t)];</span>
0097 <span class="comment">%</span>
0098 <span class="comment">% s = linspace(0,2*pi,100)';</span>
0099 <span class="comment">% mapxy = 5*[cos(s),sin(s),sin(s)];</span>
0100 <span class="comment">% xy = distance2curve(curvexy,mapxy,'spline');</span>
0101 <span class="comment">%</span>
0102 <span class="comment">% plot3(curvexy(:,1),curvexy(:,2),curvexy(:,3),'ko')</span>
0103 <span class="comment">% line([mapxy(:,1),xy(:,1)]',[mapxy(:,2),xy(:,2)]',[mapxy(:,3),xy(:,3)]','color',[0 0 1])</span>
0104 <span class="comment">% axis equal</span>
0105 <span class="comment">% axis square</span>
0106 <span class="comment">% box on</span>
0107 <span class="comment">% grid on</span>
0108 <span class="comment">% view(26,-6)</span>
0109 <span class="comment">%</span>
0110 <span class="comment">%</span>
0111 <span class="comment">% Example:</span>
0112 <span class="comment">% % distance2curve is fairly fast, at least for the linear case.</span>
0113 <span class="comment">% % Map 1e6 points onto a polygonal curve in 10 dimensions.</span>
0114 <span class="comment">% curvexy = cumsum(rand(10,10));</span>
0115 <span class="comment">% mapxy = rand(1000000,10)*5;</span>
0116 <span class="comment">% tic,[xy,distance] = distance2curve(curvexy,mapxy,'linear');toc</span>
0117 <span class="comment">% % Elapsed time is 2.867453 seconds.</span>
0118 <span class="comment">%</span>
0119 <span class="comment">%</span>
0120 <span class="comment">% See also: interparc, spline, pchip, interp1, arclength</span>
0121 <span class="comment">%</span>
0122 <span class="comment">% Author: John D'Errico</span>
0123 <span class="comment">% e-mail: woodchips@rochester.rr.com</span>
0124 <span class="comment">% Release: 1.0</span>
0125 <span class="comment">% Release date: 9/22/2010</span>
0126 
0127 <span class="comment">% check for errors, defaults, etc...</span>
0128 <span class="keyword">if</span> (nargin &lt; 2)
0129   error(<span class="string">'DISTANCE2CURVE:insufficientarguments'</span>, <span class="keyword">...</span>
0130     <span class="string">'at least curvexy and mapxy must be supplied'</span>)
0131 <span class="keyword">elseif</span> nargin &gt; 3
0132   error(<span class="string">'DISTANCE2CURVE:abundantarguments'</span>, <span class="keyword">...</span>
0133     <span class="string">'Too many arguments were supplied'</span>)
0134 <span class="keyword">end</span>
0135 
0136 <span class="comment">% get the dimension of the space our points live in</span>
0137 [n,p] = size(curvexy);
0138 
0139 <span class="keyword">if</span> isempty(curvexy) || isempty(mapxy)
0140   <span class="comment">% empty begets empty. you might say this was a pointless exercise.</span>
0141   xy = zeros(0,p);
0142   distance = zeros(0,p);
0143   t_a = zeros(0,p);
0144   <span class="keyword">return</span>
0145 <span class="keyword">end</span>
0146 
0147 <span class="comment">% do curvexy and mapxy live in the same space?</span>
0148 <span class="keyword">if</span> size(mapxy,2) ~= p
0149   error(<span class="string">'DISTANCE2CURVE:improperpxorpy'</span>, <span class="keyword">...</span>
0150     <span class="string">'curvexy and mapxy do not appear to live in the same dimension spaces'</span>)
0151 <span class="keyword">end</span>
0152 
0153 <span class="comment">% do the points live in at least 2 dimensions?</span>
0154 <span class="keyword">if</span> p &lt; 2
0155   error(<span class="string">'DISTANCE2CURVE:improperpxorpy'</span>, <span class="keyword">...</span>
0156     <span class="string">'The points MUST live in at least 2 dimensions for any curve to be defined.'</span>)
0157 <span class="keyword">end</span>
0158 
0159 <span class="comment">% how many points to be mapped to the curve?</span>
0160 m = size(mapxy,1);
0161 
0162 <span class="comment">% make sure that curvexy and mapxy are doubles, as uint8, etc</span>
0163 <span class="comment">% would cause problems down the line.</span>
0164 curvexy = double(curvexy);
0165 mapxy = double(mapxy);
0166 
0167 <span class="comment">% test for complex inputs</span>
0168 <span class="keyword">if</span> ~isreal(curvexy) || ~isreal(mapxy)
0169   error(<span class="string">'DISTANCE2CURVE:complexinputs'</span>,<span class="string">'curvexy and mapxy may not be complex'</span>)
0170 <span class="keyword">end</span>
0171 
0172 <span class="comment">% default for interpmethod</span>
0173 <span class="keyword">if</span> (nargin &lt; 3) || isempty(interpmethod)
0174   interpmethod = <span class="string">'linear'</span>;
0175 <span class="keyword">elseif</span> ~ischar(interpmethod)
0176   error(<span class="string">'DISTANCE2CURVE:invalidinterpmethod'</span>, <span class="keyword">...</span>
0177     <span class="string">'Invalid method indicated. Only ''linear'',''pchip'',''spline'' allowed'</span>)
0178 <span class="keyword">else</span>
0179   validmethods = {<span class="string">'linear'</span> <span class="string">'pchip'</span> <span class="string">'spline'</span>};
0180   ind = strmatch(lower(interpmethod),validmethods);
0181   <span class="keyword">if</span> isempty(ind) || (length(ind) &gt; 1)
0182     error(<span class="string">'DISTANCE2CURVE:invalidinterpmethod'</span>, <span class="keyword">...</span>
0183       <span class="string">'Invalid method indicated. Only ''linear'',''pchip'',''spline'' allowed'</span>)
0184   <span class="keyword">end</span>
0185   interpmethod = validmethods{ind};
0186 <span class="keyword">end</span>
0187 
0188 <span class="comment">% if the curve is a single point, stop here</span>
0189 <span class="keyword">if</span> n == 1
0190   <span class="comment">% return the appropriate parameters</span>
0191   xy = repmat(curvexy,m,1);
0192   t_a = zeros(m,1);
0193   
0194   <span class="comment">% 2 norm distance, or sqrt of sum of squares of differences</span>
0195   distance = sqrt(sum(bsxfun(@minus,curvexy,mapxy).^2,2));
0196   
0197   <span class="comment">% we can drop out here</span>
0198   <span class="keyword">return</span>
0199 <span class="keyword">end</span>
0200 
0201 <span class="comment">% compute the chordal linear arclengths, and scale to [0,1].</span>
0202 seglen = sqrt(sum(diff(curvexy,[],1).^2,2));
0203 t0 = [0;cumsum(seglen)/sum(seglen)];
0204 
0205 <span class="comment">% We need to build some parametric splines.</span>
0206 <span class="comment">% compute the splines, storing the polynomials in one 3-d array</span>
0207 ppsegs = cell(1,p);
0208 <span class="comment">% the breaks for the splines will be t0, unless spline got fancy</span>
0209 <span class="comment">% on us here.</span>
0210 breaks = t0;
0211 <span class="keyword">for</span> i = 1:p
0212   <span class="keyword">switch</span> interpmethod
0213     <span class="keyword">case</span> <span class="string">'linear'</span>
0214       dt = diff(t0);
0215       ind = 1:(n-1);
0216       ppsegs{i} = [(curvexy(ind + 1,i) - curvexy(ind,i))./dt,curvexy(ind,i)];
0217     <span class="keyword">case</span> <span class="string">'pchip'</span>
0218       spl = pchip(t0,curvexy(:,i));
0219       ppsegs{i} = spl.coefs;
0220     <span class="keyword">case</span> <span class="string">'spline'</span>
0221       spl = spline(t0,curvexy(:,i));
0222       breaks = spl.breaks';
0223       nc = numel(spl.coefs);
0224       <span class="keyword">if</span> nc &lt; 4
0225         <span class="comment">% just pretend it has cubic segments</span>
0226         spl.coefs = [zeros(1,4-nc),spl{i}.coefs];
0227         spl.order = 4;
0228       <span class="keyword">end</span>
0229       ppsegs{i} = spl.coefs;
0230   <span class="keyword">end</span>
0231 <span class="keyword">end</span>
0232 
0233 <span class="comment">% how many breaks did we find in the spline? This is</span>
0234 <span class="comment">% only a thing to worry about for a spline based on few points,</span>
0235 <span class="comment">% when the function spline.m may choose to use only two breaks.</span>
0236 nbr = numel(breaks);
0237 
0238 <span class="comment">% for each point in mapxy, find the closest point to those</span>
0239 <span class="comment">% in curvexy. This part we can do in a vectorized form.</span>
0240 pointdistances = <a href="#_sub1" class="code" title="subfunction d = ipdm(data1,varargin)">ipdm</a>(mapxy,curvexy,<span class="string">'metric'</span>,2, <span class="keyword">...</span>
0241   <span class="string">'result'</span>,<span class="string">'structure'</span>,<span class="string">'subset'</span>,<span class="string">'nearestneighbor'</span>);
0242 
0243 <span class="comment">% initialize the return variables, using the closest point</span>
0244 <span class="comment">% found in the set curvexy.</span>
0245 xy = curvexy(pointdistances.columnindex,:);
0246 distance = pointdistances.distance;
0247 t = t0(pointdistances.columnindex);
0248 
0249 <span class="comment">% we must now do at least some looping, still vectorized where possible.</span>
0250 <span class="comment">% the piecewise linear case is simpler though, so do it separately.</span>
0251 <span class="keyword">if</span> strcmp(interpmethod,<span class="string">'linear'</span>);
0252   <span class="comment">% loop over the individual points, vectorizing in the number of</span>
0253   <span class="comment">% segments, when there are many segments, but not many points to map.</span>
0254   <span class="keyword">if</span> n &gt;= (5*m)
0255     <span class="comment">% many segments, so loop over the points in mapxy</span>
0256     <span class="keyword">for</span> i = 1:m
0257       <span class="comment">% the i'th point in mapxy</span>
0258       xyi = mapxy(i,:);
0259       
0260       <span class="comment">% Compute the location (in t) of the minimal distance</span>
0261       <span class="comment">% point to xyi, for all lines.</span>
0262       tnum = zeros(nbr - 1,1);
0263       tden = tnum;
0264       <span class="keyword">for</span> j = 1:p
0265         ppj = ppsegs{j};
0266         tden = tden + ppj(:,1).^2;
0267         tnum = tnum + ppj(:,1).*(xyi(j) - ppj(:,2));
0268       <span class="keyword">end</span>
0269       tmin = tnum./tden;
0270       
0271       <span class="comment">% toss out any element of tmin that is less than or equal to</span>
0272       <span class="comment">% zero, or or is greater than dt for that segment.</span>
0273       tmin((tmin &lt;= 0) | (tmin &gt;= diff(t0))) = NaN;
0274       
0275       <span class="comment">% for any segments with a valid minimum distance inside the</span>
0276       <span class="comment">% segment itself, compute that distance.</span>
0277       dmin = zeros(nbr - 1,1);
0278       <span class="keyword">for</span> j = 1:p
0279         ppi = ppsegs{j};
0280         dmin = dmin + (ppi(:,1).*tmin + ppi(:,2) - xyi(j)).^2;
0281       <span class="keyword">end</span>
0282       dmin = sqrt(dmin);
0283       
0284       <span class="comment">% what is the minimum distance among these segments?</span>
0285       [mindist,minind] = min(dmin);
0286       
0287       <span class="keyword">if</span> ~isnan(mindist) &amp;&amp; (distance(i) &gt; mindist)
0288         <span class="comment">% there is a best segment, better than the</span>
0289         <span class="comment">% closest point from curvexy.</span>
0290         distance(i) = mindist;
0291         t(i) = tmin(minind) + t0(minind);
0292         
0293         <span class="keyword">for</span> j = 1:p
0294           ppj = ppsegs{j};
0295           xy(i,j) = ppj(minind,1).*tmin(minind) + ppj(minind,2);
0296         <span class="keyword">end</span>
0297         
0298       <span class="keyword">end</span>
0299     <span class="keyword">end</span>
0300   <span class="keyword">else</span>
0301     <span class="keyword">for</span> i = 1:(n-1)
0302       <span class="comment">% the i'th segment of the curve</span>
0303       t1 = t0(i);
0304       t2 = t0(i+1);
0305       
0306       <span class="comment">% Compute the location (in t) of the minimal distance</span>
0307       <span class="comment">% point to mapxy, for all points.</span>
0308       tnum = zeros(m,1);
0309       tden = 0;
0310       <span class="keyword">for</span> j = 1:p
0311         ppj = ppsegs{j};
0312         tden = tden + ppj(i,1).^2;
0313         tnum = tnum + ppj(i,1).*(mapxy(:,j) - ppj(i,2));
0314       <span class="keyword">end</span>
0315       tmin = tnum./tden;
0316       
0317       <span class="comment">% We only care about those points for this segment where there</span>
0318       <span class="comment">% is a minimal distance to the segment that is internal to the</span>
0319       <span class="comment">% segment.</span>
0320       k = find((tmin &gt; 0) &amp; (tmin &lt; (t2-t1)));
0321       nk = numel(k);
0322       
0323       <span class="keyword">if</span> nk &gt; 0
0324         <span class="comment">% for any points with a valid minimum distance inside the</span>
0325         <span class="comment">% segment itself, compute that distance.</span>
0326         dmin = zeros(nk,1);
0327         xymin = zeros(nk,p);
0328         <span class="keyword">for</span> j = 1:p
0329           ppj = ppsegs{j};
0330           xymin(:,j) = ppj(i,1).*tmin(k) + ppj(i,2);
0331           dmin = dmin + (xymin(:,j) - mapxy(k,j)).^2;
0332         <span class="keyword">end</span>
0333         dmin = sqrt(dmin);
0334         
0335         L = dmin &lt; distance(k);
0336         <span class="comment">% this segment has a closer point</span>
0337         <span class="comment">% closest point from curvexy.</span>
0338         <span class="keyword">if</span> any(L)
0339           distance(k(L)) = dmin(L);
0340           t(k(L)) = tmin(k(L)) + t0(i);
0341           xy(k(L),:) = xymin(L,:);
0342         <span class="keyword">end</span>
0343       <span class="keyword">end</span>
0344     <span class="keyword">end</span>
0345   <span class="keyword">end</span>
0346   
0347   <span class="comment">% for the linear case, t is identical to the fractional arc length</span>
0348   <span class="comment">% along the curve.</span>
0349   t_a = t;
0350   
0351 <span class="keyword">else</span>
0352   <span class="comment">% cubic segments. here it is simplest to loop over the</span>
0353   <span class="comment">% distinct curve segments. We need not test the endpoints</span>
0354   <span class="comment">% of the segments, since the call to ipdm did that part.</span>
0355   xytrans = zeros(1,p);
0356   polydiff = @(dp) dp(1:6).*[6 5 4 3 2 1];
0357   <span class="keyword">for</span> j = 1:(n-1)
0358     <span class="comment">% the j'th curve segment</span>
0359     t1 = t0(j);
0360     t2 = t0(j+1);
0361 
0362     <span class="comment">% for a polynomial in t that looks like</span>
0363     <span class="comment">% P(t) = a1*t^3 + a2*t^2 + a3*t + a4, in each dimension,</span>
0364     <span class="comment">% extract the polynomial pieces for the 6th degree polynomial</span>
0365     <span class="comment">% in t for the square of the Euclidean distance to the curve.</span>
0366     <span class="comment">% Thus, (P_x(t) - x0)^2 + (P_y(t) - y0)^2 + ...</span>
0367     <span class="comment">%</span>
0368     <span class="comment">% a1^2*t^6</span>
0369     <span class="comment">% 2*a1*a2*t^5</span>
0370     <span class="comment">% (2*a1*a3 + a2^2)*t^4</span>
0371     <span class="comment">% (2*a2*a3 - 2*a1*x0 + 2*a1*a4)*t^3</span>
0372     <span class="comment">% (a3^2 - 2*a2*x0 + 2*a2*a4)*t^2</span>
0373     <span class="comment">% (-2*a3*x0 + 2*a3*a4)*t</span>
0374     <span class="comment">% x0^2 - 2*a4*x0 + a4^2</span>
0375     <span class="comment">%</span>
0376     <span class="comment">% here, only the parts of this distance that are independent of</span>
0377     <span class="comment">% the point itself are computed. so the x0 terms are not built</span>
0378     <span class="comment">% yet. All of the terms with a4 in them will go away because</span>
0379     <span class="comment">% of the translation.</span>
0380     distpoly0 = zeros(1,7);
0381     <span class="keyword">for</span> i = 1:p
0382       ppi = ppsegs{i};
0383       <span class="comment">% this will allow us to translate each poly to pass through</span>
0384       <span class="comment">% (0,0) (i.e., at t = 0)</span>
0385       xytrans(i) = ppi(j,4);
0386       distpoly0(1:2) = distpoly0(1:2) + ppi(j,1).*[ppi(j,1),2*ppi(j,2)];
0387       distpoly0(3) = distpoly0(3) + 2.*ppi(j,1).*ppi(j,3) + ppi(j,2).^2;
0388       distpoly0(4) = distpoly0(4) + 2.*ppi(j,2).*ppi(j,3);
0389       distpoly0(5) = distpoly0(5) + ppi(j,3).^2;
0390     <span class="keyword">end</span>
0391 
0392     <span class="keyword">for</span> i = 1:m
0393       <span class="comment">% the i'th point, translated by xytrans. The translation does</span>
0394       <span class="comment">% not change the distance to this segment, but it does make</span>
0395       <span class="comment">% the computations more robust to numerical problems.</span>
0396       xyi = mapxy(i,:) - xytrans;
0397       
0398       <span class="comment">% update the poly for this particular point</span>
0399       <span class="comment">% (-2*a1*x0)*t^3</span>
0400       <span class="comment">% (-2*a2*x0)*t^2</span>
0401       <span class="comment">% (-2*a3*x0)*t</span>
0402       <span class="comment">% x0^2</span>
0403       distpoly = distpoly0;
0404       <span class="keyword">for</span> k = 1:p
0405         ppk = ppsegs{k};
0406         distpoly(4:6) = distpoly(4:6) - 2.*ppk(j,1:3).*xyi(k);
0407         distpoly(7) = distpoly(7) + xyi(k).^2;
0408       <span class="keyword">end</span>
0409       
0410       <span class="comment">% find any minima of this polynomial in the interval (0,t2-t1).</span>
0411       <span class="comment">% we can ignore solutions that happen at the endpoints of the</span>
0412       <span class="comment">% interval, since those are already covered by ipdm.</span>
0413       <span class="comment">%</span>
0414       <span class="comment">% merely compute the zeros of the derivative polynomial</span>
0415       diffpoly = polydiff(distpoly);
0416       tstationary = roots(diffpoly);
0417       <span class="comment">% discard any with an imaginary part, those that are less</span>
0418       <span class="comment">% than 0, or greater than t2-t1.</span>
0419       k = (imag(tstationary) ~= 0) | <span class="keyword">...</span>
0420         (real(tstationary) &lt;= 0) | <span class="keyword">...</span>
0421         (real(tstationary) &gt;= (t2 - t1));
0422       tstationary(k) = [];
0423       
0424       <span class="comment">% for any solutions that remain, compute the distance.</span>
0425       <span class="keyword">if</span> ~isempty(tstationary)
0426         mindist = zeros(size(tstationary));
0427         xyij = zeros(numel(tstationary),p);
0428         <span class="keyword">for</span> k = 1:p
0429           xyij(:,k) = polyval(ppsegs{k}(j,:),tstationary);
0430           mindist = mindist + (mapxy(i,k) - xyij(:,k)).^2;
0431         <span class="keyword">end</span>
0432         mindist = sqrt(mindist);
0433         <span class="comment">% just in case there is more than one stationary point</span>
0434         [mindist,ind] = min(mindist);
0435         
0436         <span class="keyword">if</span> mindist &lt; distance(i)
0437           <span class="comment">% we found a point on this segment that is better</span>
0438           <span class="comment">% than the endpoint values for that segment.</span>
0439           distance(i) = mindist;
0440           xy(i,:) = xyij(ind,:);
0441           t(i) = tstationary(ind) + t0(j);
0442         <span class="keyword">end</span>
0443       <span class="keyword">end</span> <span class="comment">% if ~isempty(tstationary)</span>
0444     <span class="keyword">end</span> <span class="comment">% for i = 1:n</span>
0445   <span class="keyword">end</span> <span class="comment">% for j = 1:(n-1)</span>
0446   
0447   <span class="comment">% do we need to return t_a? t_a is the same number that interparc</span>
0448   <span class="comment">% uses, whereas t as we have computed it so far is just the fractional</span>
0449   <span class="comment">% chordal arclength.</span>
0450   <span class="comment">%</span>
0451   <span class="comment">% Don't bother doing this last piece unless that argument is requested,</span>
0452   <span class="comment">% since it takes some additional work to do.</span>
0453   <span class="keyword">if</span> nargout &gt;= 2
0454     <span class="comment">% build new piecewise polynomials for each segment that</span>
0455     <span class="comment">% represent (dx/dt)^2 + (dy/dt)^2 + ...</span>
0456     <span class="comment">%</span>
0457     <span class="comment">% Since each poly must be cubic at this point, the result will be</span>
0458     <span class="comment">% a 4th degree piecewise polynomial.</span>
0459     kernelcoefs = zeros(nbr-1,5);
0460     <span class="keyword">for</span> i = 1:p
0461       ppi = ppsegs{i};
0462       kernelcoefs = kernelcoefs + [9*ppi(:,1).^2, <span class="keyword">...</span>
0463         12*ppi(:,1).*ppi(:,2), <span class="keyword">...</span>
0464         4*ppi(:,2).^2 + 6*ppi(:,1).*ppi(:,3), <span class="keyword">...</span>
0465         4*ppi(:,2).*ppi(:,3), ppi(:,3).^2];
0466     <span class="keyword">end</span>
0467     
0468     <span class="comment">% get the arc length for each segment. quadgk will suffice here</span>
0469     <span class="comment">% since we need to integrate the sqrt of each poly</span>
0470     arclengths = zeros(nbr-1,1);
0471     <span class="keyword">for</span> i = 1:(nbr - 1)
0472       lengthfun = @(t) sqrt(polyval(kernelcoefs(i,:),t));
0473       arclengths(i) = quadgk(lengthfun,0,t0(i+1) - t0(i));
0474     <span class="keyword">end</span>
0475     
0476     <span class="comment">% get the cumulative arclengths, then scale by the sum</span>
0477     <span class="comment">% this gives us fractional arc lengths.</span>
0478     arclengths = cumsum(arclengths);
0479     totallength = arclengths(end);
0480     arclengths = [0;arclengths/totallength];
0481     
0482     <span class="comment">% where does each point fall in terms of fractional cumulative</span>
0483     <span class="comment">% chordal arclength? (i.e., t0?)</span>
0484     [tbin,tbin] = histc(t,t0);
0485     tbin(tbin &lt; 1) = 1; <span class="comment">% being careful at the bottom end</span>
0486     tbin(tbin &gt;= nbr) = nbr - 1; <span class="comment">% if the point fell at the very top...</span>
0487     
0488     <span class="comment">% the total length below the segment in question</span>
0489     t_a = arclengths(tbin);
0490     <span class="comment">% now get the piece in the tbin segment</span>
0491     <span class="keyword">for</span> i = 1:m
0492       lengthfun = @(t) sqrt(polyval(kernelcoefs(tbin(i),:),t));
0493       t_a(i) = t_a(i) + quadgk(lengthfun,0,t(i) - t0(tbin(i)))/totallength;
0494     <span class="keyword">end</span>
0495     
0496   <span class="keyword">end</span>
0497   
0498 <span class="keyword">end</span> <span class="comment">% if strcmp(interpmethod,'linear');</span>
0499 
0500 
0501 <span class="comment">% ==========================================================</span>
0502 <a name="_sub1" href="#_subfunctions" class="code">function d = ipdm(data1,varargin)</a>
0503 <span class="comment">% ipdm: Inter-Point Distance Matrix</span>
0504 <span class="comment">% usage: d = ipdm(data1)</span>
0505 <span class="comment">% usage: d = ipdm(data1,data2)</span>
0506 <span class="comment">% usage: d = ipdm(data1,prop,value)</span>
0507 <span class="comment">% usage: d = ipdm(data1,data2,prop,value)</span>
0508 <span class="comment">%</span>
0509 <span class="comment">% Arguments: (input)</span>
0510 <span class="comment">%  data1 - array of data points, each point is one row. p dimensional</span>
0511 <span class="comment">%          data will be represented by matrix with p columns.</span>
0512 <span class="comment">%          If only data1 is provided, then the distance matrix</span>
0513 <span class="comment">%          is computed between all pairs of rows of data1.</span>
0514 <span class="comment">%</span>
0515 <span class="comment">%          If your data is one dimensional, it MUST form a column</span>
0516 <span class="comment">%          vector. A row vector of length n will be interpreted as</span>
0517 <span class="comment">%          an n-dimensional data set.</span>
0518 <span class="comment">%</span>
0519 <span class="comment">%  data2 - second array, supplied only if distances are to be computed</span>
0520 <span class="comment">%          between two sets of points.</span>
0521 <span class="comment">%</span>
0522 <span class="comment">%</span>
0523 <span class="comment">% Class support: data1 and data2 are assumed to be either</span>
0524 <span class="comment">% single or double precision. I have not tested this code to</span>
0525 <span class="comment">% verify its success on integer data of any class.</span>
0526 <span class="comment">%</span>
0527 <span class="comment">%</span>
0528 <span class="comment">% Additional parameters are expected to be property/value pairs.</span>
0529 <span class="comment">% Property/value pairs are pairs of arguments, the first of which</span>
0530 <span class="comment">% (properties) must always be a character string. These strings</span>
0531 <span class="comment">% may be shortened as long as the shortening is unambiguous.</span>
0532 <span class="comment">% Capitalization is ignored. Valid properties for ipdm are:</span>
0533 <span class="comment">%</span>
0534 <span class="comment">%  'Metric', 'Subset', 'Limit', 'Result'</span>
0535 <span class="comment">%</span>
0536 <span class="comment">%  'Metric' - numeric flag - defines the distance metric used</span>
0537 <span class="comment">%          metric = 2 --&gt; (DEFAULT) Euclidean distance = 2-norm</span>
0538 <span class="comment">%                         The standard distance metric.</span>
0539 <span class="comment">%</span>
0540 <span class="comment">%          metric = 1 --&gt; 1-norm = sum of absolute differences</span>
0541 <span class="comment">%                         Also sometimes known as the &quot;city block</span>
0542 <span class="comment">%                         metric&quot;, since this is the sum of the</span>
0543 <span class="comment">%                         differences in each dimension.</span>
0544 <span class="comment">%</span>
0545 <span class="comment">%          metric = inf --&gt; infinity-norm = maximum difference</span>
0546 <span class="comment">%                         over all dimensions. The name refers</span>
0547 <span class="comment">%                         to the limit of the p-norm, as p</span>
0548 <span class="comment">%                         approaches infinity.</span>
0549 <span class="comment">%</span>
0550 <span class="comment">%          metric = 0 --&gt; minimum difference over all dimensions.</span>
0551 <span class="comment">%                         This is not really a useful norm in</span>
0552 <span class="comment">%                         practice.</span>
0553 <span class="comment">%</span>
0554 <span class="comment">%          Note: while other distance metrics exist, IMHO, these</span>
0555 <span class="comment">%          seemed to be the common ones.</span>
0556 <span class="comment">%</span>
0557 <span class="comment">%</span>
0558 <span class="comment">%  'Result' - A string variable that denotes the style of returned</span>
0559 <span class="comment">%          result. Valid result types are 'Array', 'Structure'.</span>
0560 <span class="comment">%          Capitalization is ignored, and the string may be</span>
0561 <span class="comment">%          shortened if you wish.</span>
0562 <span class="comment">%</span>
0563 <span class="comment">%          result = 'Array' --&gt; (DEFAULT) A matrix of all</span>
0564 <span class="comment">%                         interpoint distances will be generated.</span>
0565 <span class="comment">%                         This array may be large. If this option</span>
0566 <span class="comment">%                         is specified along with a minimum or</span>
0567 <span class="comment">%                         maximum value, then those elements above</span>
0568 <span class="comment">%                         or below the limiting values will be</span>
0569 <span class="comment">%                         set as -inf or +inf, as appropriate.</span>
0570 <span class="comment">%</span>
0571 <span class="comment">%                         When any of 'LargestFew', 'SmallestFew',</span>
0572 <span class="comment">%                         or 'NearestNeighbor' are set, then the</span>
0573 <span class="comment">%                         resulting array will be a sparse matrix</span>
0574 <span class="comment">%                         if 'array' is specified as the result.</span>
0575 <span class="comment">%</span>
0576 <span class="comment">%          result = 'Structure' --&gt; A list of all computed distances,</span>
0577 <span class="comment">%                         defined as a structure. This structure</span>
0578 <span class="comment">%                         will have fields named 'rowindex',</span>
0579 <span class="comment">%                         'columnindex', and 'distance'.</span>
0580 <span class="comment">%</span>
0581 <span class="comment">%                         This option will be useful when a subset</span>
0582 <span class="comment">%                         criterion for the distances has been</span>
0583 <span class="comment">%                         specified, since then the distance matrix</span>
0584 <span class="comment">%                         may be very sparsely populated. Distances</span>
0585 <span class="comment">%                         for pairs outside of the criterion will</span>
0586 <span class="comment">%                         not be returned.</span>
0587 <span class="comment">%</span>
0588 <span class="comment">%</span>
0589 <span class="comment">%  'Subset' - Character string, any of:</span>
0590 <span class="comment">%</span>
0591 <span class="comment">%          'All', 'Maximum', 'Minimum', 'LargestFew', 'SmallestFew',</span>
0592 <span class="comment">%          'NearestNeighbor', 'FarthestNeighbor', or empty</span>
0593 <span class="comment">%</span>
0594 <span class="comment">%          Like properties, capitalization is ignored here, and</span>
0595 <span class="comment">%          any unambiguous shortening of the word is acceptable.</span>
0596 <span class="comment">%</span>
0597 <span class="comment">%          DEFAULT = 'All'</span>
0598 <span class="comment">%</span>
0599 <span class="comment">%          Some interpoint distance matrices can be huge. Often</span>
0600 <span class="comment">%          these matrices are too large to be fully retained in</span>
0601 <span class="comment">%          memory, yet only the pair of points with the largest</span>
0602 <span class="comment">%          or smallest distance may be needed. When only some</span>
0603 <span class="comment">%          subset of the complete set of distances is of interest,</span>
0604 <span class="comment">%          these options allow you to specify which distances will</span>
0605 <span class="comment">%          be returned.</span>
0606 <span class="comment">%</span>
0607 <span class="comment">%          If 'result' is defined to be an array, then a sparse</span>
0608 <span class="comment">%          matrix will be returned for the 'LargestFew', 'SmallestFew',</span>
0609 <span class="comment">%          'NearestNeighbor', and 'FarthestNeighbor' subset classes.</span>
0610 <span class="comment">%          'Minimum' and 'Maximum' will yield full matrices by</span>
0611 <span class="comment">%          default. If a structure is specified, then only those</span>
0612 <span class="comment">%          elements which have been identified will be returned.</span>
0613 <span class="comment">%</span>
0614 <span class="comment">%          Where a subset is specified, its limiting value is</span>
0615 <span class="comment">%          specified by the 'Limit' property. Call that value k.</span>
0616 <span class="comment">%</span>
0617 <span class="comment">%</span>
0618 <span class="comment">%          'All' --&gt;     (DEFAULT) Return all interpoint distances</span>
0619 <span class="comment">%</span>
0620 <span class="comment">%          'Minimum' --&gt; Only look for those distances above</span>
0621 <span class="comment">%                        the cutoff k. All other distances will</span>
0622 <span class="comment">%                        be returned as -inf.</span>
0623 <span class="comment">%</span>
0624 <span class="comment">%          'Maximum' --&gt; Only look for those distances below</span>
0625 <span class="comment">%                        the cutoff k. All other distances will</span>
0626 <span class="comment">%                        be returned as +inf.</span>
0627 <span class="comment">%</span>
0628 <span class="comment">%          'SmallestFew' --&gt; Only return the subset of the k</span>
0629 <span class="comment">%                        smallest distances. Where only one data</span>
0630 <span class="comment">%                        set is provided, only the upper triangle</span>
0631 <span class="comment">%                        of the inter-point distance matrix will</span>
0632 <span class="comment">%                        be generated since that matrix is symmetric.</span>
0633 <span class="comment">%</span>
0634 <span class="comment">%          'LargestFew' --&gt; Only return the subset of the k</span>
0635 <span class="comment">%                        largest distances. Where only one data</span>
0636 <span class="comment">%                        set is provided, only the upper triangle</span>
0637 <span class="comment">%                        of the inter-point distance matrix will</span>
0638 <span class="comment">%                        be generated since that matrix is symmetric.</span>
0639 <span class="comment">%</span>
0640 <span class="comment">%          'NearestNeighbor' --&gt; Only return the single nearest</span>
0641 <span class="comment">%                        neighbor in data2 to each point in data1.</span>
0642 <span class="comment">%                        No limiting value is required for this</span>
0643 <span class="comment">%                        option. If multiple points have the same</span>
0644 <span class="comment">%                        nearest distance, then return the first</span>
0645 <span class="comment">%                        such point found. With only one input set,</span>
0646 <span class="comment">%                        a point will not be its own nearest</span>
0647 <span class="comment">%                        neighbor.</span>
0648 <span class="comment">%</span>
0649 <span class="comment">%                        Note that exact replicates in a single set</span>
0650 <span class="comment">%                        will cause problems, since a sparse matrix</span>
0651 <span class="comment">%                        is returned by default. Since they will have</span>
0652 <span class="comment">%                        a zero distance, they will not show up in</span>
0653 <span class="comment">%                        the sparse matrix. A structure return will</span>
0654 <span class="comment">%                        show those points as having a zero distance</span>
0655 <span class="comment">%                        though.</span>
0656 <span class="comment">%</span>
0657 <span class="comment">%          'FarthestNeighbor' --&gt; Only return the single farthest</span>
0658 <span class="comment">%                        neighbor to each point. No limiting value</span>
0659 <span class="comment">%                        is required for this option. If multiple</span>
0660 <span class="comment">%                        points have the same farthest distance,</span>
0661 <span class="comment">%                        then return the first such point found.</span>
0662 <span class="comment">%</span>
0663 <span class="comment">%</span>
0664 <span class="comment">%  'Limit' - scalar numeric value or []. Used only when some</span>
0665 <span class="comment">%           Subset is specified.</span>
0666 <span class="comment">%</span>
0667 <span class="comment">%          DEFAULT = []</span>
0668 <span class="comment">%</span>
0669 <span class="comment">%</span>
0670 <span class="comment">%  'ChunkSize' - allows a user with lower RAM limits</span>
0671 <span class="comment">%          to force the code to only grab smaller chunks of RAM</span>
0672 <span class="comment">%          at a time (where possible). This parameter is specified</span>
0673 <span class="comment">%          in bytes of RAM. The default is 32 megabytes, or 2^22</span>
0674 <span class="comment">%          elements in any piece of the distance matrix. Only some</span>
0675 <span class="comment">%          options will break the problem into chunks, thus as long</span>
0676 <span class="comment">%          as a full matrix is expected to be returned, there seems</span>
0677 <span class="comment">%          no reason to break the problem up into pieces.</span>
0678 <span class="comment">%</span>
0679 <span class="comment">%          DEFAULT = 2^25</span>
0680 <span class="comment">%</span>
0681 <span class="comment">%</span>
0682 <span class="comment">% Arguments: (output)</span>
0683 <span class="comment">%  d     - array of interpoint distances, or a struct wth the</span>
0684 <span class="comment">%          fields {'rowindex', 'columnindex', 'distance'}.</span>
0685 <span class="comment">%</span>
0686 <span class="comment">%          d(i,j) represents the distance between point i</span>
0687 <span class="comment">%          (from data1) and point j (from data2).</span>
0688 <span class="comment">%</span>
0689 <span class="comment">%          If only one (n1 x p) array is supplied, then d will</span>
0690 <span class="comment">%          be an array of size == [n1,n1].</span>
0691 <span class="comment">%</span>
0692 <span class="comment">%          If two arrays (of sizes n1 x p and n2 x p) then d</span>
0693 <span class="comment">%          will be an array of size == [n1,n2].</span>
0694 <span class="comment">%</span>
0695 <span class="comment">%</span>
0696 <span class="comment">% Efficiency considerations:</span>
0697 <span class="comment">%  Where possible, this code will use bsxfun to compute its</span>
0698 <span class="comment">%  distances.</span>
0699 <span class="comment">%</span>
0700 <span class="comment">%</span>
0701 <span class="comment">% Example:</span>
0702 <span class="comment">%  Compute the interpoint distances between all pairs of points</span>
0703 <span class="comment">%  in a list of 5 points, in 2 dimensions and using Euclidean</span>
0704 <span class="comment">%  distance as the distance metric.</span>
0705 <span class="comment">%</span>
0706 <span class="comment">%  A = randn(5,2);</span>
0707 <span class="comment">%  d = ipdm(A,'metric',2)</span>
0708 <span class="comment">%  d =</span>
0709 <span class="comment">%            0       2.3295       3.2263       2.0263       2.8244</span>
0710 <span class="comment">%       2.3295            0       1.1485      0.31798       1.0086</span>
0711 <span class="comment">%       3.2263       1.1485            0       1.4318       1.8479</span>
0712 <span class="comment">%       2.0263      0.31798       1.4318            0       1.0716</span>
0713 <span class="comment">%       2.8244       1.0086       1.8479       1.0716            0</span>
0714 <span class="comment">%</span>
0715 <span class="comment">% (see the demo file for many other examples)</span>
0716 <span class="comment">%</span>
0717 <span class="comment">% See also: pdist</span>
0718 <span class="comment">%</span>
0719 <span class="comment">% Author: John D'Errico</span>
0720 <span class="comment">% e-mail: woodchips@rochester.rr.com</span>
0721 <span class="comment">% Release: 1.0</span>
0722 <span class="comment">% Release date: 2/26/08</span>
0723 
0724 <span class="comment">% Default property values</span>
0725 params.Metric = 2;
0726 params.Result = <span class="string">'array'</span>;
0727 params.Subset = <span class="string">'all'</span>;
0728 params.Limit = [];
0729 params.ChunkSize = 2^25;
0730 
0731 <span class="comment">% untangle the arguments</span>
0732 <span class="keyword">if</span> nargin&lt;1
0733   <span class="comment">% if called with no arguments, then the user probably</span>
0734   <span class="comment">% needs help. Give it to them.</span>
0735   help <a href="#_sub1" class="code" title="subfunction d = ipdm(data1,varargin)">ipdm</a>
0736   <span class="keyword">return</span>
0737 <span class="keyword">end</span>
0738 
0739 <span class="comment">% were two sets of data provided?</span>
0740 pvpairs = {};
0741 <span class="keyword">if</span> nargin==1
0742   <span class="comment">% only 1 set of data provided</span>
0743   dataflag = 1;
0744   data2 = [];
0745 <span class="keyword">else</span>
0746   <span class="keyword">if</span> ischar(varargin{1})
0747     dataflag = 1;
0748     data2 = [];
0749     pvpairs = varargin;
0750   <span class="keyword">else</span>
0751     dataflag = 2;
0752     data2 = varargin{1};
0753     <span class="keyword">if</span> nargin&gt;2
0754       pvpairs = varargin(2:end);
0755     <span class="keyword">end</span>
0756   <span class="keyword">end</span>
0757 <span class="keyword">end</span>
0758 
0759 <span class="comment">% get data sizes for later</span>
0760 [n1,dim] = size(data1);
0761 <span class="keyword">if</span> dataflag == 2
0762   n2 = size(data2,1);
0763 <span class="keyword">end</span>
0764 
0765 <span class="comment">% Test the class of the input variables</span>
0766 <span class="keyword">if</span> ~(isa(data1,<span class="string">'double'</span>) || isa(data1,<span class="string">'single'</span>)) || <span class="keyword">...</span>
0767     ((dataflag == 2) &amp;&amp; ~(isa(data2,<span class="string">'double'</span>) || isa(data2,<span class="string">'single'</span>)))
0768   error(<span class="string">'data points must be either single or double precision variables.'</span>)
0769 <span class="keyword">end</span>
0770 
0771 <span class="comment">% do we need to process any property/value pairs?</span>
0772 <span class="keyword">if</span> nargin&gt;2
0773   params = <a href="#_sub3" class="code" title="subfunction params=parse_pv_pairs(params,pv_pairs)">parse_pv_pairs</a>(params,pvpairs);
0774   
0775   <span class="comment">% check for problems in the properties</span>
0776   
0777   <span class="comment">% was a legal Subset provided?</span>
0778   <span class="keyword">if</span> ~isempty(params.Subset) &amp;&amp; ~ischar(params.Subset)
0779     error(<span class="string">'If provided, ''Subset'' must be character'</span>)
0780   <span class="keyword">elseif</span> isempty(params.Subset)
0781     params.Subset = <span class="string">'all'</span>;
0782   <span class="keyword">end</span>
0783   valid = {<span class="string">'all'</span>,<span class="string">'maximum'</span>,<span class="string">'minimum'</span>,<span class="string">'largestfew'</span>,<span class="string">'smallestfew'</span>, <span class="keyword">...</span>
0784     <span class="string">'nearestneighbor'</span>,<span class="string">'farthestneighbor'</span>};
0785   ind = find(strncmpi(params.Subset,valid,length(params.Subset)));
0786   <span class="keyword">if</span> (length(ind)==1)
0787     params.Subset = valid{ind};
0788   <span class="keyword">else</span>
0789     error([<span class="string">'Invalid Subset: '</span>,params.Subset])
0790   <span class="keyword">end</span>
0791   
0792   <span class="comment">% was a limit provided?</span>
0793   <span class="keyword">if</span> ~ismember(params.Subset,{<span class="string">'all'</span>,<span class="string">'nearestneighbor'</span>,<span class="string">'farthestneighbor'</span>}) &amp;&amp; <span class="keyword">...</span>
0794       isempty(params.Limit)
0795     error(<span class="string">'No limit provided, but a Subset that requires a limit value was specified'</span>)
0796   <span class="keyword">end</span>
0797   <span class="comment">% check the limit values for validity</span>
0798   <span class="keyword">if</span> length(params.Limit)&gt;1
0799     error(<span class="string">'Limit must be scalar or empty'</span>)
0800   <span class="keyword">end</span>
0801   
0802   <span class="keyword">switch</span> params.Subset
0803     <span class="keyword">case</span> {<span class="string">'largestfew'</span>, <span class="string">'smallestfew'</span>}
0804       <span class="comment">% must be at least 1, and an integer</span>
0805       <span class="keyword">if</span> (params.Limit&lt;1) || (round(params.Limit)~=params.Limit)
0806         error(<span class="string">'Limit must be a positive integer for LargestFew or NearestFew'</span>)
0807       <span class="keyword">end</span>
0808   <span class="keyword">end</span>
0809   
0810   <span class="comment">% was a legal Result provided?</span>
0811   <span class="keyword">if</span> isempty(params.Result)
0812     params.result = <span class="string">'Array'</span>;
0813   <span class="keyword">elseif</span> ~ischar(params.Result)
0814     error(<span class="string">'If provided, ''Result'' must be character or empty'</span>)
0815   <span class="keyword">end</span>
0816   valid = {<span class="string">'array'</span>,<span class="string">'structure'</span>};
0817   ind = find(strncmpi(params.Result,valid,length(params.Result)));
0818   <span class="keyword">if</span> (length(ind)==1)
0819     params.Result = valid{ind};
0820   <span class="keyword">else</span>
0821     error([<span class="string">'Invalid Result: '</span>,params.Subset])
0822   <span class="keyword">end</span>
0823 
0824   <span class="comment">% check for the metric</span>
0825   <span class="keyword">if</span> isempty(params.Metric)
0826     params.Metric = 2;
0827   <span class="keyword">elseif</span> (length(params.Metric)~=1) || ~ismember(params.Metric,[0 1 2 inf])
0828     error(<span class="string">'If supplied, ''Metric'' must be a scalar, and one of [0 1 2 inf]'</span>)
0829   <span class="keyword">end</span>
0830 <span class="keyword">end</span> <span class="comment">% if nargin&gt;2</span>
0831   
0832 <span class="comment">% If Metric was given as 2, but the dimension is only 1, then it will</span>
0833 <span class="comment">% be slightly faster (and equivalent) to use the 1-norm Metric.</span>
0834 <span class="keyword">if</span> (dim == 1) &amp;&amp; (params.Metric == 2)
0835   params.Metric = 1;
0836 <span class="keyword">end</span>
0837 
0838 <span class="comment">% Can we use bsxfun to compute the interpoint distances?</span>
0839 <span class="comment">% Older Matlab releases will not have bsxfun, but if it is</span>
0840 <span class="comment">% around, it will ne both faster and less of a memory hog.</span>
0841 params.usebsxfun = (5==exist(<span class="string">'bsxfun'</span>,<span class="string">'builtin'</span>));
0842 
0843 <span class="comment">% check for dimension mismatch if 2 sets</span>
0844 <span class="keyword">if</span> (dataflag==2) &amp;&amp; (size(data2,2)~=dim)
0845   error(<span class="string">'If 2 point sets provided, then both must have the same number of columns'</span>)
0846 <span class="keyword">end</span>
0847 
0848 <span class="comment">% Total number of distances to compute, in case I must do it in batches</span>
0849 <span class="keyword">if</span> dataflag==1
0850   n2 = n1;
0851 <span class="keyword">end</span>
0852 ntotal = n1*n2;
0853 
0854 <span class="comment">% FINALLY!!! Compute inter-point distances</span>
0855 <span class="keyword">switch</span> params.Subset
0856   <span class="keyword">case</span> <span class="string">'all'</span>
0857     <span class="comment">% The complete set of interpoint distances. There is no need</span>
0858     <span class="comment">% to break this into chunks, since we must return all distances.</span>
0859     <span class="comment">% If that is too much to compute in memory, then it will fail</span>
0860     <span class="comment">% anyway when we try to store the result. bsxfun will at least</span>
0861     <span class="comment">% do the computation efficiently.</span>
0862     
0863     <span class="comment">% One set or two?</span>
0864     <span class="keyword">if</span> dataflag == 1
0865       d = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1,data1,params);
0866     <span class="keyword">else</span>
0867         d = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1,data2,params);
0868     <span class="keyword">end</span>
0869     
0870     <span class="comment">% Must we return it as a struct?</span>
0871     <span class="keyword">if</span> params.Result(1) == <span class="string">'s'</span>
0872       [rind,cind] = ndgrid(1:size(d,1),1:size(d,2));
0873       ds.rowindex = rind(:);
0874       ds.columnindex = cind(:);
0875       ds.distance = d(:);
0876       d = ds;
0877     <span class="keyword">end</span>
0878     
0879   <span class="keyword">case</span> {<span class="string">'minimum'</span> <span class="string">'maximum'</span>}
0880     <span class="comment">% There is no reason to break this into pieces if the result</span>
0881     <span class="comment">% sill be filled in the end with +/- inf. Only break it up</span>
0882     <span class="comment">% if the final result is a struct.</span>
0883     <span class="keyword">if</span> ((ntotal*8)&lt;=params.ChunkSize) || (params.Result(1) == <span class="string">'a'</span>)
0884       <span class="comment">% its small enough to do it all at once</span>
0885       
0886       <span class="comment">% One set or two?</span>
0887       <span class="keyword">if</span> dataflag == 1
0888         d = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1,data1,params);
0889       <span class="keyword">else</span>
0890           d = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1,data2,params);
0891       <span class="keyword">end</span>
0892       
0893       <span class="comment">% Must we return it as a struct?</span>
0894       <span class="keyword">if</span> params.Result(1) == <span class="string">'a'</span>
0895         <span class="comment">% its an array, fill the unwanted distances with +/- inf</span>
0896         <span class="keyword">if</span> params.Subset(2) == <span class="string">'i'</span>
0897           <span class="comment">% minimum</span>
0898           d(d&lt;=params.Limit) = -inf;
0899         <span class="keyword">else</span>
0900           <span class="comment">% maximum</span>
0901           d(d&gt;=params.Limit) = +inf;
0902         <span class="keyword">end</span>
0903       <span class="keyword">else</span>
0904         <span class="comment">% a struct will be returned</span>
0905         <span class="keyword">if</span> params.Subset(2) == <span class="string">'i'</span>
0906           <span class="comment">% minimum</span>
0907           [dist.rowindex,dist.columnindex] = find(d&gt;=params.Limit);
0908         <span class="keyword">else</span>
0909           <span class="comment">% maximum</span>
0910           [dist.rowindex,dist.columnindex] = find(d&lt;=params.Limit);
0911         <span class="keyword">end</span>
0912         dist.distance = d(dist.rowindex + n1*(dist.columnindex-1));
0913         d = dist;
0914       <span class="keyword">end</span>
0915       
0916     <span class="keyword">else</span>
0917       <span class="comment">% we need to break this into chunks. This branch</span>
0918       <span class="comment">% will always return a struct.</span>
0919       
0920       <span class="comment">% this is the number of rows of data1 that we will</span>
0921       <span class="comment">% process at a time.</span>
0922       bs = floor(params.ChunkSize/(8*n2));
0923       bs = min(n1,max(1,bs));
0924       
0925       <span class="comment">% Accumulate the result into a cell array. Do it this</span>
0926       <span class="comment">% way because we don't know in advance how many elements</span>
0927       <span class="comment">% that we will find satisfying the minimum or maximum</span>
0928       <span class="comment">% limit specified.</span>
0929       accum = cell(0,1);
0930       
0931       <span class="comment">% now loop over the chunks</span>
0932       batch = 1:bs;
0933       <span class="keyword">while</span> ~isempty(batch)
0934         
0935         <span class="comment">% One set or two?</span>
0936         <span class="keyword">if</span> dataflag == 1
0937           dist = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1(batch,:),data1,params);
0938         <span class="keyword">else</span>
0939           dist = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1(batch,:),data2,params);
0940         <span class="keyword">end</span>
0941         
0942         <span class="comment">% big or small as requested</span>
0943         <span class="keyword">if</span> (<span class="string">'i'</span>==params.Subset(2))
0944           <span class="comment">% minimum value specified</span>
0945           [I,J,V] = find(dist&gt;=params.Limit);
0946         <span class="keyword">else</span>
0947           <span class="comment">% maximum limit</span>
0948           [I,J] = find(dist&lt;=params.Limit);
0949           I = I(:);
0950           J = J(:);
0951           V = dist(I + (J-1)*length(batch));
0952           I = I + (batch(1)-1);
0953         <span class="keyword">end</span>
0954 
0955         <span class="comment">% and stuff them into the cell structure</span>
0956         <span class="keyword">if</span> ~isempty(V)
0957           accum{end+1,1} = [I,J,V(:)]; <span class="comment">%#ok</span>
0958         <span class="keyword">end</span>
0959 
0960         <span class="comment">% increment the batch</span>
0961         batch = batch + bs;
0962         <span class="keyword">if</span> batch(end)&gt;n1
0963           batch(batch&gt;n1) = [];
0964         <span class="keyword">end</span>
0965 
0966       <span class="keyword">end</span>
0967 
0968       <span class="comment">% convert the cells into one flat array</span>
0969       accum = cell2mat(accum);
0970 
0971       <span class="keyword">if</span> isempty(accum)
0972         d.rowindex = [];
0973         d.columnindex = [];
0974         d.distance = [];
0975       <span class="keyword">else</span>
0976         <span class="comment">% we found something</span>
0977 
0978         <span class="comment">% sort on the second column, to put them in a reasonable order</span>
0979         accum = sortrows(accum,[2 1]);
0980 
0981         d.rowindex = accum(:,1);
0982         d.columnindex = accum(:,2);
0983         d.distance = accum(:,3);
0984       <span class="keyword">end</span>
0985 
0986     <span class="keyword">end</span>
0987 
0988   <span class="keyword">case</span> {<span class="string">'smallestfew'</span> <span class="string">'largestfew'</span>}
0989     <span class="comment">% find the k smallest/largest distances. k is</span>
0990     <span class="comment">% given by params.Limit</span>
0991 
0992     <span class="comment">% if only 1 set, params.Limit must be less than n*(n-1)/2</span>
0993     <span class="keyword">if</span> dataflag == 1
0994       params.Limit = min(params.Limit,n1*(n1-1)/2);
0995     <span class="keyword">end</span>
0996 
0997     <span class="comment">% is this a large problem?</span>
0998     <span class="keyword">if</span> ((ntotal*8) &lt;= params.ChunkSize)
0999       <span class="comment">% small potatoes</span>
1000 
1001       <span class="comment">% One set or two?</span>
1002       <span class="keyword">if</span> dataflag == 1
1003         dist = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1,data1,params);
1004         <span class="comment">% if only one data set, set the diagonal and</span>
1005         <span class="comment">% below that to +/- inf so we don't find it.</span>
1006         temp = find(tril(ones(n1,n1),0));
1007         <span class="keyword">if</span> params.Subset(1) == <span class="string">'s'</span>
1008           dist(temp) = inf;
1009         <span class="keyword">else</span>
1010           dist(temp) = -inf;
1011         <span class="keyword">end</span>
1012       <span class="keyword">else</span>
1013         dist = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1,data2,params);
1014       <span class="keyword">end</span>
1015 
1016       <span class="comment">% sort the distances to find those we need</span>
1017       <span class="keyword">if</span> (<span class="string">'s'</span>==params.Subset(1))
1018         <span class="comment">% smallestfew</span>
1019         [val,tags] = sort(dist(:),<span class="string">'ascend'</span>);
1020       <span class="keyword">else</span>
1021         <span class="comment">% largestfew</span>
1022         [val,tags] = sort(dist(:),<span class="string">'descend'</span>);
1023       <span class="keyword">end</span>
1024       val = val(1:params.Limit);
1025       tags = tags(1:params.Limit);
1026 
1027       <span class="comment">% recover the row and column index from the linear</span>
1028       <span class="comment">% index returned by sort in tags.</span>
1029       [d.rowindex,d.columnindex] = ind2sub([n1,size(dist,2)],tags);
1030 
1031       <span class="comment">% create the matrix as a sparse one or a struct?</span>
1032       <span class="keyword">if</span> params.Result(1)==<span class="string">'a'</span>
1033         <span class="comment">% its an array, so make the array sparse.</span>
1034         d = sparse(d.rowindex,d.columnindex,val,n1,size(dist,2));
1035       <span class="keyword">else</span>
1036         <span class="comment">% a structure</span>
1037         d.distance = val;
1038       <span class="keyword">end</span>
1039 
1040     <span class="keyword">else</span>
1041       <span class="comment">% chunks</span>
1042 
1043       <span class="comment">% this is the number of rows of data1 that we will</span>
1044       <span class="comment">% process at a time.</span>
1045       bs = floor(params.ChunkSize/(8*n2));
1046       bs = min(n1,max(1,bs));
1047 
1048       <span class="comment">% We need to find the extreme cases. There are two possible</span>
1049       <span class="comment">% algorithms, depending on how many total elements we will</span>
1050       <span class="comment">% search for.</span>
1051       <span class="comment">% 1. Only a very few total elements.</span>
1052       <span class="comment">% 2. A relatively large number of total elements, forming</span>
1053       <span class="comment">%    a significant fraction of the total set.</span>
1054       <span class="comment">%</span>
1055       <span class="comment">% Case #1 would suggest to retain params.Limit numberr of</span>
1056       <span class="comment">% elements from each batch, then at the end, sort them all</span>
1057       <span class="comment">% to find the best few. Case #2 will result in too many</span>
1058       <span class="comment">% elements to retain, so we must distinguish between these</span>
1059       <span class="comment">% alternatives.</span>
1060       <span class="keyword">if</span> (8*params.Limit*n1/bs) &lt;= params.ChunkSize
1061         <span class="comment">% params.Limit is small enough to fall into case #1.</span>
1062 
1063         <span class="comment">% Accumulate the result into a cell array. Do it this</span>
1064         <span class="comment">% way because we don't know in advance how many elements</span>
1065         <span class="comment">% that we will find satisfying the minimum or maximum</span>
1066         <span class="comment">% limit specified.</span>
1067         accum = cell(0,1);
1068 
1069         <span class="comment">% now loop over the chunks</span>
1070         batch = (1:bs)';
1071         <span class="keyword">while</span> ~isempty(batch)
1072           <span class="comment">% One set or two?</span>
1073           <span class="keyword">if</span> dataflag == 1
1074             dist = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1(batch,:),data1,params);
1075             k = find(tril(ones(length(batch),n2),batch(1)-1));
1076             <span class="keyword">if</span> (<span class="string">'s'</span>==params.Subset(1))
1077               dist(k) = inf;
1078             <span class="keyword">else</span>
1079               dist(k) = -inf;
1080             <span class="keyword">end</span>
1081           <span class="keyword">else</span>
1082             dist = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1(batch,:),data2,params);
1083           <span class="keyword">end</span>
1084 
1085           <span class="comment">% big or small as requested, keeping only the best</span>
1086           <span class="comment">% params.Limit number of elements</span>
1087           <span class="keyword">if</span> (<span class="string">'s'</span>==params.Subset(1))
1088             <span class="comment">% minimum value specified</span>
1089             [tags,tags] = sort(dist(:),1,<span class="string">'ascend'</span>); <span class="comment">%#ok</span>
1090             tags = tags(1:bs);
1091             [I,J] = ndgrid(batch,1:n2);
1092             ijv = [I(tags),J(tags),dist(tags)];
1093           <span class="keyword">else</span>
1094             <span class="comment">% maximum limit</span>
1095             [tags,tags] = sort(dist(:),1,<span class="string">'descend'</span>); <span class="comment">%#ok</span>
1096             tags = tags(1:bs);
1097             [I,J] = ndgrid(batch,1:n2);
1098             ijv = [I(tags),J(tags),dist(tags)];
1099           <span class="keyword">end</span>
1100           <span class="comment">% and stuff them into the cell structure</span>
1101           accum{end+1,1} = ijv; <span class="comment">%#ok</span>
1102 
1103           <span class="comment">% increment the batch</span>
1104           batch = batch + bs;
1105           <span class="keyword">if</span> batch(end)&gt;n1
1106             batch(batch&gt;n1) = [];
1107           <span class="keyword">end</span>
1108         <span class="keyword">end</span>
1109 
1110         <span class="comment">% convert the cells into one flat array</span>
1111         accum = cell2mat(accum);
1112 
1113         <span class="comment">% keep only the params.Limit best of those singled out</span>
1114         accum = sortrows(accum,3);
1115         <span class="keyword">if</span> (<span class="string">'s'</span>==params.Subset(1))
1116           <span class="comment">% minimum value specified</span>
1117           accum = accum(1:params.Limit,:);
1118         <span class="keyword">else</span>
1119           <span class="comment">% minimum value specified</span>
1120           accum = accum(end + 1 - (1:params.Limit),:);
1121         <span class="keyword">end</span>
1122         d.rowindex = accum(:,1);
1123         d.columnindex = accum(:,2);
1124         d.distance = accum(:,3);
1125 
1126         <span class="comment">% create the matrix as a sparse one or a struct?</span>
1127         <span class="keyword">if</span> params.Result(1)==<span class="string">'a'</span>
1128           <span class="comment">% its an array, so make the array sparse.</span>
1129           d = sparse(d.rowindex,d.columnindex,d.distance,n1,size(dist,2));
1130         <span class="keyword">end</span>
1131 
1132       <span class="keyword">else</span>
1133         <span class="comment">% params.Limit forces us into the domain of case #2.</span>
1134         <span class="comment">% Here we cannot retain params.Limit elements from each chunk.</span>
1135         <span class="comment">% so we will grab each chunk and append it to the best elements</span>
1136         <span class="comment">% found so far, then filter out the best after each chunk is</span>
1137         <span class="comment">% done. This may be slower than we want, but its the only way.</span>
1138         ijv = zeros(0,3);
1139 
1140         <span class="comment">% loop over the chunks</span>
1141         batch = (1:bs)';
1142         <span class="keyword">while</span> ~isempty(batch)
1143           <span class="comment">% One set or two?</span>
1144           <span class="keyword">if</span> dataflag == 1
1145             dist = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1(batch,:),data1,params);
1146             k = find(tril(ones(length(batch),n2),batch(1)-1));
1147             <span class="keyword">if</span> (<span class="string">'s'</span>==params.Subset(1))
1148               dist(k) = inf;
1149             <span class="keyword">else</span>
1150               dist(k) = -inf;
1151             <span class="keyword">end</span>
1152           <span class="keyword">else</span>
1153             dist = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1(batch,:),data2,params);
1154           <span class="keyword">end</span>
1155 
1156           [I,J] = ndgrid(batch,1:n2);
1157           ijv = [ijv;[I(:),J(:),dist(:)]]; <span class="comment">%#ok</span>
1158 
1159           <span class="comment">% big or small as requested, keeping only the best</span>
1160           <span class="comment">% params.Limit number of elements</span>
1161           <span class="keyword">if</span> size(ijv,1) &gt; params.Limit
1162             <span class="keyword">if</span> (<span class="string">'s'</span>==params.Subset(1))
1163               <span class="comment">% minimum value specified</span>
1164               [tags,tags] = sort(ijv(:,3),1,<span class="string">'ascend'</span>); <span class="comment">%#ok</span>
1165             <span class="keyword">else</span>
1166               [tags,tags] = sort(ijv(:,3),1,<span class="string">'ascend'</span>); <span class="comment">%#ok</span>
1167             <span class="keyword">end</span>
1168             ijv = ijv(tags(1:params.Limit),:);
1169           <span class="keyword">end</span>
1170 
1171           <span class="comment">% increment the batch</span>
1172           batch = batch + bs;
1173           <span class="keyword">if</span> batch(end)&gt;n1
1174             batch(batch&gt;n1) = [];
1175           <span class="keyword">end</span>
1176         <span class="keyword">end</span>
1177 
1178         <span class="comment">% They are fully trimmed down. stuff a structure</span>
1179         d.rowindex = ijv(:,1);
1180         d.columnindex = ijv(:,2);
1181         d.distance = ijv(:,3);
1182 
1183         <span class="comment">% create the matrix as a sparse one or a struct?</span>
1184         <span class="keyword">if</span> params.Result(1)==<span class="string">'a'</span>
1185           <span class="comment">% its an array, so make the array sparse.</span>
1186           d = sparse(d.rowindex,d.columnindex,d.distance,n1,size(dist,2));
1187         <span class="keyword">end</span>
1188 
1189       <span class="keyword">end</span>
1190 
1191     <span class="keyword">end</span>
1192     
1193   <span class="keyword">case</span> {<span class="string">'nearestneighbor'</span> <span class="string">'farthestneighbor'</span>}
1194     <span class="comment">% find the closest/farthest neighbor for every point</span>
1195 
1196     <span class="comment">% is this a large problem? Or a 1-d problem?</span>
1197     <span class="keyword">if</span> dim == 1
1198       <span class="comment">% its a 1-d nearest/farthest neighbor problem. we can</span>
1199       <span class="comment">% special case these easily enough, and all the distance</span>
1200       <span class="comment">% metric options are the same in 1-d.</span>
1201 
1202       <span class="comment">% first split it into the farthest versus nearest cases.</span>
1203       <span class="keyword">if</span> params.Subset(1) == <span class="string">'f'</span>
1204         <span class="comment">% farthest away</span>
1205 
1206         <span class="comment">% One set or two?</span>
1207         <span class="keyword">if</span> dataflag == 1
1208           [d2min,minind] = min(data1);
1209           [d2max,maxind] = max(data1);
1210         <span class="keyword">else</span>
1211           [d2min,minind] = min(data2);
1212           [d2max,maxind] = max(data2);
1213         <span class="keyword">end</span>
1214 
1215         d.rowindex = (1:n1)';
1216         d.columnindex = repmat(maxind,n1,1);
1217         d.distance = repmat(d2max,n1,1);
1218 
1219         <span class="comment">% which endpoint was further away?</span>
1220         k = abs((data1 - d2min)) &gt;= abs((data1 - d2max));
1221         <span class="keyword">if</span> any(k)
1222           d.columnindex(k) = minind;
1223           d.distance(k) = d2min;
1224         <span class="keyword">end</span>
1225 
1226       <span class="keyword">else</span>
1227         <span class="comment">% nearest. this is mainly a sort and some fussing around.</span>
1228         d.rowindex = (1:n1)';
1229         d.columnindex = ones(n1,1);
1230         d.distance = zeros(n1,1);
1231 
1232         <span class="comment">% One set or two?</span>
1233         <span class="keyword">if</span> dataflag == 1
1234           <span class="comment">% if only one data point, then we are done</span>
1235           <span class="keyword">if</span> n1 == 2
1236             <span class="comment">% if exactly two data points, its trivial</span>
1237             d.columnindex = [2 1];
1238             d.distance = repmat(abs(diff(data1)),2,1);
1239           <span class="keyword">elseif</span> n1&gt;2
1240             <span class="comment">% at least three points. do a sort.</span>
1241             [sorted_data,tags] = sort(data1);
1242 
1243             <span class="comment">% handle the first and last points separately</span>
1244             d.columnindex(tags(1)) = tags(2);
1245             d.distance(tags(1)) = sorted_data(2) - sorted_data(1);
1246             d.columnindex(tags(end)) = tags(end-1);
1247             d.distance(tags(end)) = sorted_data(end) - sorted_data(end-1);
1248 
1249             ind = (2:(n1-1))';
1250 
1251             d1 = sorted_data(ind) - sorted_data(ind-1);
1252             d2 = sorted_data(ind+1) - sorted_data(ind);
1253 
1254             k = d1 &lt; d2;
1255             d.distance(tags(ind(k))) = d1(k);
1256             d.columnindex(tags(ind(k))) = tags(ind(k)-1);
1257             k = ~k;
1258             d.distance(tags(ind(k))) = d2(k);
1259             d.columnindex(tags(ind(k))) = tags(ind(k)+1);
1260           <span class="keyword">end</span> <span class="comment">% if n1 == 2</span>
1261         <span class="keyword">else</span>
1262           <span class="comment">% Two sets of data. still really a sort and some fuss.</span>
1263           <span class="keyword">if</span> n2 == 1
1264             <span class="comment">% there is only one point in data2</span>
1265             d.distance = abs(data1 - data2);
1266             <span class="comment">% d.columnindex is already set correctly</span>
1267           <span class="keyword">else</span>
1268             <span class="comment">% At least two points in data2</span>
1269             <span class="comment">% We need to sort all the data points together, but also</span>
1270             <span class="comment">% know which points from each set went where. ind12 and</span>
1271             <span class="comment">% bool12 will help keep track.</span>
1272             ind12 = [1:n1,1:n2]';
1273             bool12 = [zeros(n1,1);ones(n2,1)];
1274             [sorted_data,tags] = sort([data1;data2]);
1275 
1276             ind12 = ind12(tags);
1277             bool12 = bool12(tags);
1278 
1279             <span class="comment">% where did each point end up after the sort?</span>
1280             loc1 = find(~bool12);
1281             loc2 = find(bool12);
1282 
1283             <span class="comment">% for each point in data1, what is the (sorted) data2</span>
1284             <span class="comment">% element which appears most nearly to the left of it?</span>
1285             cs = cumsum(bool12);
1286             leftelement = cs(loc1);
1287 
1288             <span class="comment">% any points which fell below the minimum element in data2</span>
1289             <span class="comment">% will have a zero for the index of the element on their</span>
1290             <span class="comment">% left. fix this.</span>
1291             leftelement = max(1,leftelement);
1292 
1293             <span class="comment">% likewise, any point greater than the max in data2 will</span>
1294             <span class="comment">% have an n2 in left element. this too will be a problem</span>
1295             <span class="comment">% later, so fix it.</span>
1296             leftelement = min(n2-1,leftelement);
1297 
1298             <span class="comment">% distance to the left hand element</span>
1299             dleft = abs(sorted_data(loc1) - sorted_data(loc2(leftelement)));
1300             dright = abs(sorted_data(loc1) - sorted_data(loc2(leftelement+1)));
1301 
1302             <span class="comment">% find the points which are closer to the left element in data2</span>
1303             k = (dleft &lt; dright);
1304             d.distance(ind12(loc1(k))) = dleft(k);
1305             d.columnindex(ind12(loc1(k))) = ind12(loc2(leftelement(k)));
1306             k = ~k;
1307             d.distance(ind12(loc1(k))) = dright(k);
1308             d.columnindex(ind12(loc1(k))) = ind12(loc2(leftelement(k)+1));
1309 
1310           <span class="keyword">end</span> <span class="comment">% if n2 == 1</span>
1311         <span class="keyword">end</span> <span class="comment">% if dataflag == 1</span>
1312       <span class="keyword">end</span> <span class="comment">% if params.Subset(1) == 'f'</span>
1313 
1314       <span class="comment">% create the matrix as a sparse one or a struct?</span>
1315       <span class="keyword">if</span> params.Result(1)==<span class="string">'a'</span>
1316         <span class="comment">% its an array, so make the array sparse.</span>
1317         d = sparse(d.rowindex,d.columnindex,d.distance,n1,n2);
1318       <span class="keyword">end</span>
1319 
1320     <span class="keyword">elseif</span> (ntotal&gt;1000) &amp;&amp; (((params.Metric == 0) &amp;&amp; (params.Subset(1) == <span class="string">'n'</span>)) || <span class="keyword">...</span>
1321         ((params.Metric == inf) &amp;&amp; (params.Subset(1) == <span class="string">'f'</span>)))
1322       <span class="comment">% nearest/farthest neighbour in n&gt;1 dimensions, but for an</span>
1323       <span class="comment">% infinity norm metric. Reduce this to a sequence of</span>
1324       <span class="comment">% 1-d problems, each of which will be faster in general.</span>
1325       <span class="comment">% do this only if the problem is moderately large, since</span>
1326       <span class="comment">% we must overcome the extra overhead of the recursive</span>
1327       <span class="comment">% calls to ipdm.</span>
1328 
1329       <span class="comment">% do the first dimension</span>
1330       <span class="keyword">if</span> dataflag == 1
1331         d = <a href="#_sub1" class="code" title="subfunction d = ipdm(data1,varargin)">ipdm</a>(data1(:,1),data1(:,1),<span class="string">'subset'</span>,params.Subset,<span class="string">'metric'</span>,params.Metric,<span class="string">'result'</span>,<span class="string">'struct'</span>);
1332       <span class="keyword">else</span>
1333         d = <a href="#_sub1" class="code" title="subfunction d = ipdm(data1,varargin)">ipdm</a>(data1(:,1),data2(:,1),<span class="string">'subset'</span>,params.Subset,<span class="string">'metric'</span>,params.Metric,<span class="string">'result'</span>,<span class="string">'struct'</span>);
1334       <span class="keyword">end</span>
1335 
1336       <span class="comment">% its slightly different for nearest versus farthest here</span>
1337       <span class="comment">% now, loop over dimensions</span>
1338       <span class="keyword">for</span> i = 2:dim
1339         <span class="keyword">if</span> dataflag == 1
1340           di = <a href="#_sub1" class="code" title="subfunction d = ipdm(data1,varargin)">ipdm</a>(data1(:,i),data1(:,i),<span class="string">'subset'</span>,params.Subset,<span class="string">'metric'</span>,params.Metric,<span class="string">'result'</span>,<span class="string">'struct'</span>);
1341         <span class="keyword">else</span>
1342           di = <a href="#_sub1" class="code" title="subfunction d = ipdm(data1,varargin)">ipdm</a>(data1(:,i),data2(:,i),<span class="string">'subset'</span>,params.Subset,<span class="string">'metric'</span>,params.Metric,<span class="string">'result'</span>,<span class="string">'struct'</span>);
1343         <span class="keyword">end</span>
1344 
1345         <span class="comment">% did any of the distances change?</span>
1346         <span class="keyword">if</span> params.Metric == 0
1347           <span class="comment">% the 0 norm, with nearest neighbour, so take the</span>
1348           <span class="comment">% smallest distance in any dimension.</span>
1349           k = d.distance &gt; di.distance;
1350         <span class="keyword">else</span>
1351           <span class="comment">% inf norm. so take the largest distance across dimensions</span>
1352           k = d.distance &lt; di.distance;
1353         <span class="keyword">end</span>
1354 
1355         <span class="keyword">if</span> any(k)
1356           d.distance(k) = di.distance(k);
1357           d.columnindex(k) = di.columnindex(k);
1358         <span class="keyword">end</span>
1359       <span class="keyword">end</span>
1360 
1361       <span class="comment">% create the matrix as a sparse one or a struct?</span>
1362       <span class="keyword">if</span> params.Result(1)==<span class="string">'a'</span>
1363         <span class="comment">% its an array, so make the array sparse.</span>
1364         d = sparse(d.rowindex,d.columnindex,d.distance,n1,n2);
1365       <span class="keyword">end</span>
1366 
1367     <span class="keyword">elseif</span> ((ntotal*8) &lt;= params.ChunkSize)
1368       <span class="comment">% None of the other special cases apply, so do it using brute</span>
1369       <span class="comment">% force for the small potatoes problem.</span>
1370 
1371       <span class="comment">% One set or two?</span>
1372       <span class="keyword">if</span> dataflag == 1
1373         dist = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1,data1,params);
1374       <span class="keyword">else</span>
1375         dist = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1,data2,params);
1376       <span class="keyword">end</span>
1377 
1378       <span class="comment">% if only one data set and if a nearest neighbor</span>
1379       <span class="comment">% problem, set the diagonal to +inf so we don't find it.</span>
1380       <span class="keyword">if</span> (dataflag==1) &amp;&amp; (n1&gt;1) &amp;&amp; (<span class="string">'n'</span>==params.Subset(1))
1381         diagind = (1:n1) + (0:n1:(n1^2-1));
1382         dist(diagind) = +inf;
1383       <span class="keyword">end</span>
1384 
1385       <span class="keyword">if</span> (<span class="string">'n'</span>==params.Subset(1))
1386         <span class="comment">% nearest</span>
1387         [val,j] = min(dist,[],2);
1388       <span class="keyword">else</span>
1389         <span class="comment">% farthest</span>
1390         [val,j] = max(dist,[],2);
1391       <span class="keyword">end</span>
1392 
1393       <span class="comment">% create the matrix as a sparse one or a struct?</span>
1394       <span class="keyword">if</span> params.Result(1)==<span class="string">'a'</span>
1395         <span class="comment">% its an array, so make the array sparse.</span>
1396         d = sparse((1:n1)',j,val,n1,size(dist,2));
1397       <span class="keyword">else</span>
1398         <span class="comment">% a structure</span>
1399         d.rowindex = (1:n1)';
1400         d.columnindex = j;
1401         d.distance = val;
1402       <span class="keyword">end</span>
1403 
1404     <span class="keyword">else</span>
1405 
1406       <span class="comment">% break it into chunks</span>
1407       bs = floor(params.ChunkSize/(8*n2));
1408       bs = min(n1,max(1,bs));
1409 
1410       <span class="comment">% pre-allocate the result</span>
1411       d.rowindex = (1:n1)';
1412       d.columnindex = zeros(n1,1);
1413       d.distance = zeros(n1,1);
1414 
1415       <span class="comment">% now loop over the chunks</span>
1416       batch = 1:bs;
1417       <span class="keyword">while</span> ~isempty(batch)
1418 
1419         <span class="comment">% One set or two?</span>
1420         <span class="keyword">if</span> dataflag == 1
1421           dist = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1(batch,:),data1,params);
1422         <span class="keyword">else</span>
1423           dist = <a href="#_sub2" class="code" title="subfunction d = distcomp(set1,set2,params)">distcomp</a>(data1(batch,:),data2,params);
1424         <span class="keyword">end</span>
1425 
1426         <span class="comment">% if only one data set and if a nearest neighbor</span>
1427         <span class="comment">% problem, set the diagonal to +inf so we don't find it.</span>
1428         <span class="keyword">if</span> (dataflag==1) &amp;&amp; (n1&gt;1) &amp;&amp; (<span class="string">'n'</span>==params.Subset(1))
1429           diagind = 1:length(batch);
1430           diagind = diagind + (diagind-2+batch(1))*length(batch);
1431           dist(diagind) = +inf;
1432         <span class="keyword">end</span>
1433 
1434         <span class="comment">% big or small as requested</span>
1435         <span class="keyword">if</span> (<span class="string">'n'</span>==params.Subset(1))
1436           <span class="comment">% nearest</span>
1437           [val,j] = min(dist,[],2);
1438         <span class="keyword">else</span>
1439           <span class="comment">% farthest</span>
1440           [val,j] = max(dist,[],2);
1441         <span class="keyword">end</span>
1442 
1443         <span class="comment">% and stuff them into the result structure</span>
1444         d.columnindex(batch) = j;
1445         d.distance(batch) = val;
1446 
1447         <span class="comment">% increment the batch</span>
1448         batch = batch + bs;
1449         <span class="keyword">if</span> batch(end)&gt;n1
1450           batch(batch&gt;n1) = [];
1451         <span class="keyword">end</span>
1452 
1453       <span class="keyword">end</span>
1454 
1455       <span class="comment">% did we need to return a struct or an array?</span>
1456       <span class="keyword">if</span> params.Result(1) == <span class="string">'a'</span>
1457         <span class="comment">% an array. make it a sparse one</span>
1458         d = sparse(d.rowindex,d.columnindex,d.distance,n1,n2);
1459       <span class="keyword">end</span>
1460 
1461     <span class="keyword">end</span> <span class="comment">% if dim == 1</span>
1462 
1463 <span class="keyword">end</span>  <span class="comment">% switch params.Subset</span>
1464 
1465 <span class="comment">% End of mainline</span>
1466 
1467 <span class="comment">% ======================================================</span>
1468 <span class="comment">% begin subfunctions</span>
1469 <span class="comment">% ======================================================</span>
1470 <a name="_sub2" href="#_subfunctions" class="code">function d = distcomp(set1,set2,params)</a>
1471 <span class="comment">% Subfunction to compute all distances between two sets of points</span>
1472 dim = size(set1,2);
1473 <span class="comment">% can we take advantage of bsxfun?</span>
1474 <span class="comment">% Note: in theory, there is no need to loop over the dimensions. We</span>
1475 <span class="comment">% could Just let bsxfun do ALL the work, then wrap a sum around the</span>
1476 <span class="comment">% outside. In practice, this tends to create large intermediate</span>
1477 <span class="comment">% arrays, especially in higher numbers of dimensions. Its also when</span>
1478 <span class="comment">% we might gain here by use of a vectorized code. This will only be</span>
1479 <span class="comment">% a serious gain when the number of points is relatively small and</span>
1480 <span class="comment">% the dimension is large.</span>
1481 <span class="keyword">if</span> params.usebsxfun
1482   <span class="comment">% its a recent enough version of matlab that we can</span>
1483   <span class="comment">% use bsxfun at all.</span>
1484   n1 = size(set1,1);
1485   n2 = size(set2,1);
1486   <span class="keyword">if</span> (dim&gt;1) &amp;&amp; ((n1*n2*dim)&lt;=params.ChunkSize)
1487     <span class="comment">% its a small enough problem that we might gain by full</span>
1488     <span class="comment">% use of bsxfun</span>
1489     <span class="keyword">switch</span> params.Metric
1490       <span class="keyword">case</span> 2
1491         d = sum(bsxfun(@minus,reshape(set1,[n1,1,dim]),reshape(set2,[1,n2,dim])).^2,3);
1492       <span class="keyword">case</span> 1
1493         d = sum(abs(bsxfun(@minus,reshape(set1,[n1,1,dim]),reshape(set2,[1,n2,dim]))),3);
1494       <span class="keyword">case</span> inf
1495         d = max(abs(bsxfun(@minus,reshape(set1,[n1,1,dim]),reshape(set2,[1,n2,dim]))),[],3);
1496       <span class="keyword">case</span> 0
1497         d = min(abs(bsxfun(@minus,reshape(set1,[n1,1,dim]),reshape(set2,[1,n2,dim]))),[],3);
1498     <span class="keyword">end</span>
1499   <span class="keyword">else</span>
1500     <span class="comment">% too big, so that the ChunkSize will have been exceeded, or just 1-d</span>
1501     <span class="keyword">if</span> params.Metric == 2
1502       d = bsxfun(@minus,set1(:,1),set2(:,1)').^2;
1503     <span class="keyword">else</span>
1504       d = abs(bsxfun(@minus,set1(:,1),set2(:,1)'));
1505     <span class="keyword">end</span>
1506     <span class="keyword">for</span> i=2:dim
1507       <span class="keyword">switch</span> params.Metric
1508         <span class="keyword">case</span> 2
1509           d = d + bsxfun(@minus,set1(:,i),set2(:,i)').^2;
1510         <span class="keyword">case</span> 1
1511           d = d + abs(bsxfun(@minus,set1(:,i),set2(:,i)'));
1512         <span class="keyword">case</span> inf
1513           d = max(d,abs(bsxfun(@minus,set1(:,i),set2(:,i)')));
1514         <span class="keyword">case</span> 0
1515           d = min(d,abs(bsxfun(@minus,set1(:,i),set2(:,i)')));
1516       <span class="keyword">end</span>
1517     <span class="keyword">end</span>
1518   <span class="keyword">end</span>
1519 <span class="keyword">else</span>
1520   <span class="comment">% Cannot use bsxfun. Sigh. Do things the hard (and slower) way.</span>
1521   n1 = size(set1,1);
1522   n2 = size(set2,1);
1523   <span class="keyword">if</span> params.Metric == 2
1524     <span class="comment">% Note: While some people might use a different Euclidean</span>
1525     <span class="comment">% norm computation based on expanding the square of the</span>
1526     <span class="comment">% difference of two numbers, that computation is inherantly</span>
1527     <span class="comment">% inaccurate when implemented in floating point arithmetic.</span>
1528     <span class="comment">% While it might be faster, I won't use it here. Sorry.</span>
1529     d = (repmat(set1(:,1),1,n2) - repmat(set2(:,1)',n1,1)).^2;
1530   <span class="keyword">else</span>
1531     d = abs(repmat(set1(:,1),1,n2) - repmat(set2(:,1)',n1,1));
1532   <span class="keyword">end</span>
1533   <span class="keyword">for</span> i=2:dim
1534     <span class="keyword">switch</span> params.Metric
1535       <span class="keyword">case</span> 2
1536         d = d + (repmat(set1(:,i),1,n2) - repmat(set2(:,i)',n1,1)).^2;
1537       <span class="keyword">case</span> 1
1538         d = d + abs(repmat(set1(:,i),1,n2) - repmat(set2(:,i)',n1,1));
1539       <span class="keyword">case</span> inf
1540         d = max(d,abs(repmat(set1(:,i),1,n2) - repmat(set2(:,i)',n1,1)));
1541       <span class="keyword">case</span> 0
1542         d = min(d,abs(repmat(set1(:,i),1,n2) - repmat(set2(:,i)',n1,1)));
1543     <span class="keyword">end</span>
1544   <span class="keyword">end</span>
1545 <span class="keyword">end</span>
1546 <span class="comment">% if 2 norm, then we must sqrt at the end</span>
1547 <span class="keyword">if</span> params.Metric==2
1548   d = sqrt(d);
1549 <span class="keyword">end</span>
1550 
1551 <span class="comment">% ==============================================================</span>
1552 <span class="comment">%    end main ipdm</span>
1553 <span class="comment">%    begin included function - parse_pv_pairs</span>
1554 <span class="comment">% ==============================================================</span>
1555 <a name="_sub3" href="#_subfunctions" class="code">function params=parse_pv_pairs(params,pv_pairs)</a>
1556 <span class="comment">% parse_pv_pairs: parses sets of property value pairs, allows defaults</span>
1557 <span class="comment">% usage: params=parse_pv_pairs(default_params,pv_pairs)</span>
1558 <span class="comment">%</span>
1559 <span class="comment">% arguments: (input)</span>
1560 <span class="comment">%  default_params - structure, with one field for every potential</span>
1561 <span class="comment">%             property/value pair. Each field will contain the default</span>
1562 <span class="comment">%             value for that property. If no default is supplied for a</span>
1563 <span class="comment">%             given property, then that field must be empty.</span>
1564 <span class="comment">%</span>
1565 <span class="comment">%  pv_array - cell array of property/value pairs.</span>
1566 <span class="comment">%             Case is ignored when comparing properties to the list</span>
1567 <span class="comment">%             of field names. Also, any unambiguous shortening of a</span>
1568 <span class="comment">%             field/property name is allowed.</span>
1569 <span class="comment">%</span>
1570 <span class="comment">% arguments: (output)</span>
1571 <span class="comment">%  params   - parameter struct that reflects any updated property/value</span>
1572 <span class="comment">%             pairs in the pv_array.</span>
1573 <span class="comment">%</span>
1574 <span class="comment">% Example usage:</span>
1575 <span class="comment">% First, set default values for the parameters. Assume we</span>
1576 <span class="comment">% have four parameters that we wish to use optionally in</span>
1577 <span class="comment">% the function examplefun.</span>
1578 <span class="comment">%</span>
1579 <span class="comment">%  - 'viscosity', which will have a default value of 1</span>
1580 <span class="comment">%  - 'volume', which will default to 1</span>
1581 <span class="comment">%  - 'pie' - which will have default value 3.141592653589793</span>
1582 <span class="comment">%  - 'description' - a text field, left empty by default</span>
1583 <span class="comment">%</span>
1584 <span class="comment">% The first argument to examplefun is one which will always be</span>
1585 <span class="comment">% supplied.</span>
1586 <span class="comment">%</span>
1587 <span class="comment">%   function examplefun(dummyarg1,varargin)</span>
1588 <span class="comment">%   params.Viscosity = 1;</span>
1589 <span class="comment">%   params.Volume = 1;</span>
1590 <span class="comment">%   params.Pie = 3.141592653589793</span>
1591 <span class="comment">%</span>
1592 <span class="comment">%   params.Description = '';</span>
1593 <span class="comment">%   params=parse_pv_pairs(params,varargin);</span>
1594 <span class="comment">%   params</span>
1595 <span class="comment">%</span>
1596 <span class="comment">% Use examplefun, overriding the defaults for 'pie', 'viscosity'</span>
1597 <span class="comment">% and 'description'. The 'volume' parameter is left at its default.</span>
1598 <span class="comment">%</span>
1599 <span class="comment">%   examplefun(rand(10),'vis',10,'pie',3,'Description','Hello world')</span>
1600 <span class="comment">%</span>
1601 <span class="comment">% params =</span>
1602 <span class="comment">%     Viscosity: 10</span>
1603 <span class="comment">%        Volume: 1</span>
1604 <span class="comment">%           Pie: 3</span>
1605 <span class="comment">%   Description: 'Hello world'</span>
1606 <span class="comment">%</span>
1607 <span class="comment">% Note that capitalization was ignored, and the property 'viscosity'</span>
1608 <span class="comment">% was truncated as supplied. Also note that the order the pairs were</span>
1609 <span class="comment">% supplied was arbitrary.</span>
1610 
1611 npv = length(pv_pairs);
1612 n = npv/2;
1613 
1614 <span class="keyword">if</span> n~=floor(n)
1615   error <span class="string">'Property/value pairs must come in PAIRS.'</span>
1616 <span class="keyword">end</span>
1617 <span class="keyword">if</span> n&lt;=0
1618   <span class="comment">% just return the defaults</span>
1619   <span class="keyword">return</span>
1620 <span class="keyword">end</span>
1621 
1622 <span class="keyword">if</span> ~isstruct(params)
1623   error <span class="string">'No structure for defaults was supplied'</span>
1624 <span class="keyword">end</span>
1625 
1626 <span class="comment">% there was at least one pv pair. process any supplied</span>
1627 propnames = fieldnames(params);
1628 lpropnames = lower(propnames);
1629 <span class="keyword">for</span> i=1:n
1630   p_i = lower(pv_pairs{2*i-1});
1631   v_i = pv_pairs{2*i};
1632 
1633   ind = strmatch(p_i,lpropnames,<span class="string">'exact'</span>);
1634   <span class="keyword">if</span> isempty(ind)
1635     ind = find(strncmp(p_i,lpropnames,length(p_i)));
1636     <span class="keyword">if</span> isempty(ind)
1637       error([<span class="string">'No matching property found for: '</span>,pv_pairs{2*i-1}])
1638     <span class="keyword">elseif</span> length(ind)&gt;1
1639       error([<span class="string">'Ambiguous property name: '</span>,pv_pairs{2*i-1}])
1640     <span class="keyword">end</span>
1641   <span class="keyword">end</span>
1642   p_i = propnames{ind};
1643 
1644   <span class="comment">% override the corresponding default in params.</span>
1645   <span class="comment">% Use setfield for comptability issues with older releases.</span>
1646   params = setfield(params,p_i,v_i); <span class="comment">%#ok</span>
1647 
1648 <span class="keyword">end</span>
1649 
1650 
1651 
1652</pre></div>
<hr><address>Generated on Mon 05-Mar-2018 10:51:40 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>