#include "Lattice.h"
#include <iostream>
#include <cstring>

using namespace std;

// Get the header file
// Generated by setup.py
const string header = {
#include "element.gpuh"
};

Lattice::Lattice(int32_t nbElements,SymplecticIntegrator& integrator,AT_FLOAT energy,int gpuId) : factory(PassMethodFactory(integrator)) {
  elements.reserve(nbElements);
  gpuRing = nullptr;
  memset(&ringParams,0,sizeof(ringParams));
  ringParams.Energy = energy;
  gpu = AbstractGPU::getInstance()->createContext(gpuId);
}

Lattice::~Lattice() {
  for(auto & element : elements)
    delete element;
  if(gpuRing) gpu->freeDevice(gpuRing);
  delete gpu;
}

void Lattice::addElement() {

  try {

    string passMethod = AbstractInterface::getInstance()->getString("PassMethod");
    AbstractElement *elem = factory.createElement(passMethod);
    elements.push_back(elem);

  } catch (string& err) {
    // Try to retrieve name of element (if any)
    string idxStr = "#" + to_string(elements.size());
    string name = "";
    try {
      name = " (" + AbstractInterface::getInstance()->getString("Name") + ")";
    } catch (string&) {}
    string errStr = err + " in element " + idxStr + name;
    throw errStr;
  }

}

AT_FLOAT Lattice::getLength() {
  AT_FLOAT L = 0.0;
  for(auto & element : elements)
    L += element->getLength();
  return L;
}

void Lattice::setTurnCounter(uint64_t count) {
  ringParams.turnCounter = count;
}

uint32_t Lattice::getNbElement() {
  return elements.size();
}

GPUContext *Lattice::getGPUContext() {
  return gpu;
}

void Lattice::generateGPUKernel() {

#ifdef _PROFILE
  double t0,t1;
  t0=AbstractGPU::get_ticks();
#endif

  // Perform post initialisation
  ringParams.Length = getLength();
  for(auto & element : elements)
    element->postInit(&ringParams);

  // Generate code
  std::string code;

  code.append(header);
  AbstractGPU::getInstance()->addUtilsFunctions(code);
  factory.generateUtilsFunctions(code);
  factory.generatePassMethods(code);

  // Store particle coordinates in rout
  string routCode;
  routCode.append("    refIdx = refpts[elem];\n");
  routCode.append("    if(refIdx>=0) {\n");
  routCode.append("      _rout[6 * (refIdx*nbPart) +  0] = r6[0];\n");
  routCode.append("      _rout[6 * (refIdx*nbPart) +  1] = r6[1];\n");
  routCode.append("      _rout[6 * (refIdx*nbPart) +  2] = r6[2];\n");
  routCode.append("      _rout[6 * (refIdx*nbPart) +  3] = r6[3];\n");
  routCode.append("      _rout[6 * (refIdx*nbPart) +  4] = r6[4];\n");
  routCode.append("      _rout[6 * (refIdx*nbPart) +  5] = r6[5];\n");
  routCode.append("    }\n");

  // Lost particle
  string lostCode;
  lostCode.append("    pLost = !isfinite(r6[4]) || !isfinite(r6[5]) ||\n");
  lostCode.append("            (fabs(r6[0]) > 1.0 || fabs(r6[1]) > 1.0) ||\n");
  lostCode.append("            (fabs(r6[2]) > 1.0 || fabs(r6[3]) > 1.0);\n");

  lostCode.append("    if(!lost[threadId] & pLost) {\n");
  lostCode.append("      if( lostAtElem ) {\n");
  lostCode.append("        lostAtElem[threadId] = elem;\n");
  lostCode.append("      }\n");
  lostCode.append("      if( lostAtCoord ) {\n");
  lostCode.append("        lostAtCoord[0 + 6*threadId] = r6[0];\n");
  lostCode.append("        lostAtCoord[1 + 6*threadId] = r6[1];\n");
  lostCode.append("        lostAtCoord[2 + 6*threadId] = r6[2];\n");
  lostCode.append("        lostAtCoord[3 + 6*threadId] = r6[3];\n");
  lostCode.append("        lostAtCoord[4 + 6*threadId] = r6[4];\n");
  lostCode.append("        lostAtCoord[5 + 6*threadId] = r6[5];\n");
  lostCode.append("      }\n");
  lostCode.append("      r6[0] = NAN;\n");
  lostCode.append("      r6[1] = 0;\n");
  lostCode.append("      r6[2] = 0;\n");
  lostCode.append("      r6[3] = 0;\n");
  lostCode.append("      r6[4] = 0;\n");
  lostCode.append("      r6[5] = 0;\n");
  lostCode.append("      lost[threadId] = turn + 1;\n");
  lostCode.append("    }\n");


  // GPU main track function
  // extern C to prevent from mangled name
  code.append("extern \"C\" __global__ void track(RING_PARAM *ringParam,ELEMENT* gpuRing,\n"
              "                                   uint32_t startElem,uint32_t nbElement,uint32_t nbTotalElement,\n"
              "                                   uint64_t nbPart,AT_FLOAT* rin,AT_FLOAT* rout,\n"
              "                                   uint32_t* lost,uint64_t turn,\n"
              "                                   int32_t *refpts,uint32_t nbRef,\n"
              "                                   uint32_t *lostAtElem,AT_FLOAT *lostAtCoord\n"
              "                                   ) {\n");

  code.append("  AT_FLOAT sr6[6];\n");
  code.append("  AT_FLOAT* r6 = sr6;\n");
  code.append("  int threadId = blockIdx.x * blockDim.x + threadIdx.x;\n");
  code.append("  ELEMENT* elemPtr = &gpuRing[startElem];\n");
  code.append("  AT_FLOAT* _rout = rout + 6 * ((uint64_t)turn * (uint64_t)nbPart * (uint64_t)nbRef + (uint64_t)(threadId));\n");
  code.append("  AT_FLOAT fTurn = (AT_FLOAT)(ringParam->turnCounter + turn);\n");
  code.append("  bool pLost;\n");
  code.append("  int32_t refIdx = 0;\n");
  code.append("  int elem = startElem;\n");

  // Copy particle coordinates into registers
  code.append("  sr6[0] = rin[0 + 6*threadId];\n"); // x
  code.append("  sr6[1] = rin[1 + 6*threadId];\n"); // px/p0 = x'(1+d)
  code.append("  sr6[2] = rin[2 + 6*threadId];\n"); // y
  code.append("  sr6[3] = rin[3 + 6*threadId];\n"); // py/p0 = y'(1+d)
  code.append("  sr6[4] = rin[4 + 6*threadId];\n"); // d = (pz-p0)/p0
  code.append("  sr6[5] = rin[5 + 6*threadId];\n"); // c.tau (time lag)

  // Exit if particle lost
  code.append("  if(lost[threadId]) {\n");
  code.append("    if( nbRef > 0 && threadId<nbPart ) {\n"); // don't forget last ref
  code.append("      for(; nbRef > 0 && elem <= startElem+nbElement; elem++) {\n"); // don't forget last ref
  code.append(routCode);
  code.append("      }\n");
  code.append("    }\n");
  code.append("    return;\n");
  code.append("  }\n");

  // Loop over elements
  code.append("  for(; elem < startElem+nbElement; elem++) {\n");
  code.append(routCode);
  code.append("    switch(elemPtr->Type) {\n");
  factory.generatePassMethodsCalls(code);
  code.append("    }\n");
  code.append(lostCode);
  code.append("    elemPtr++;\n");
  code.append("  }\n");

  code.append("  if( elem==nbTotalElement ) {\n");
  code.append(lostCode);
  code.append(routCode);
  code.append("  }\n");

  // Copy back particle coordinates to global mem
  code.append("  rin[0 + 6*threadId] = sr6[0];\n");
  code.append("  rin[1 + 6*threadId] = sr6[1];\n");
  code.append("  rin[2 + 6*threadId] = sr6[2];\n");
  code.append("  rin[3 + 6*threadId] = sr6[3];\n");
  code.append("  rin[4 + 6*threadId] = sr6[4];\n");
  code.append("  rin[5 + 6*threadId] = sr6[5];\n");

  code.append("}\n");

#ifdef _PROFILE
  t1=AbstractGPU::get_ticks();
  cout << "Code generation: " << (t1-t0)*1000.0 << "ms" << endl;
  t0=AbstractGPU::get_ticks();
#endif

  gpu->compile(code);

#ifdef _PROFILE
  t1=AbstractGPU::get_ticks();
  cout << "Code compilation: " << (t1-t0)*1000.0 << "ms" << endl;
#endif

}

void Lattice::fillGPUMemory() {

  // Check ELEMENT structure
  if( sizeof(ELEMENT)%8 != 0 )
    throw string("ELEMENT structure must have a size multiple of 8");

  // Get total memory size
  uint64_t elemSize = elements.size() * sizeof( ELEMENT );
  uint64_t size = elemSize;
  uint64_t privSize = 0;
  for(auto & element : elements)
    privSize += element->getMemorySize();
  size += privSize;

  // Allocate GPU Memory
  if(!gpuRing) gpu->allocDevice(&gpuRing, size);

  // Copy element data
  ELEMENT *memPtr = (ELEMENT *)malloc(size);
  unsigned char *gpuPtr = (unsigned char *)gpuRing + elemSize;
  unsigned char *privPtr = (unsigned char *)memPtr + elemSize;
  ELEMENT *ptr = memPtr;
  for(auto & element : elements) {
    element->fillGPUMemory(ptr, privPtr, gpuPtr);
    ptr++;
    privPtr += element->getMemorySize();
    gpuPtr += element->getMemorySize();
  }

  gpu->hostToDevice(gpuRing,memPtr,size);
  free(memPtr);

}

void Lattice::run(uint64_t nbTurn,uint64_t nbParticles,AT_FLOAT *rin,AT_FLOAT *rout,uint32_t nbRef,
                  uint32_t *refPts,uint32_t *lostAtTurn,uint32_t *lostAtElem,AT_FLOAT *lostAtCoord) {

#ifdef _PROFILE
  double t0 = AbstractGPU::get_ticks();
#endif

  // Copy rin to gpu mem
  void *gpuRin;
  gpu->allocDevice(&gpuRin, nbParticles * 6 * sizeof(AT_FLOAT));
  gpu->hostToDevice(gpuRin, rin, nbParticles * 6 * sizeof(AT_FLOAT));

  // Expand ref indexes
  int32_t *expandedRefPts = new int32_t[elements.size()+1];
  for(size_t i=0;i<=elements.size();i++)
    expandedRefPts[i] = -1;
  for(size_t i=0;i<nbRef;i++)
    expandedRefPts[refPts[i]] = (int32_t)i;
  void *gpuRefs;
  gpu->allocDevice(&gpuRefs, (elements.size() + 1) * sizeof(int32_t));
  gpu->hostToDevice(gpuRefs, expandedRefPts, (elements.size() + 1) * sizeof(int32_t));

  // Lost flags
  // Lost dummy particles are created to fill the thread block
  uint32_t dummyParticles = (GPU_BLOCK_SIZE - nbParticles%GPU_BLOCK_SIZE) % GPU_BLOCK_SIZE;
  uint32_t lostSize = (nbParticles + dummyParticles) * sizeof(uint32_t);
  uint32_t *lost = new uint32_t[nbParticles + dummyParticles];
  for(uint32_t i=0;i<nbParticles;i++) lost[i] = 0;
  for(uint32_t i=nbParticles;i<nbParticles+dummyParticles;i++) lost[i] = 1;
  void *gpuLost;
  gpu->allocDevice(&gpuLost, lostSize);
  gpu->hostToDevice(gpuLost, lost, lostSize);

  // rout
  void *gpuRout = nullptr;
  uint64_t routSize = nbParticles * nbRef * nbTurn * 6 * sizeof(AT_FLOAT);
  if( routSize ) gpu->allocDevice(&gpuRout, routSize);

  // Global ring param
  void *gpuRingParams;
  gpu->allocDevice(&gpuRingParams, sizeof(ringParams));
  gpu->hostToDevice(gpuRingParams,&ringParams,sizeof(ringParams));

  // Lost infos
  void *gpuLostAtElem = nullptr;
  void *gpuLostAtCoord = nullptr;
  if(lostAtElem) gpu->allocDevice(&gpuLostAtElem, nbParticles * sizeof(uint32_t));
  if(lostAtCoord) gpu->allocDevice(&gpuLostAtCoord, nbParticles * 6 * sizeof(AT_FLOAT));

  // Call GPU
  gpu->resetArg();
  uint32_t nbElement = elements.size();
  uint32_t startElem;
  uint32_t nbElemToProcess;
  uint64_t turn;
  gpu->addArg(sizeof(void *),&gpuRingParams);
  gpu->addArg(sizeof(void *),&gpuRing);
  gpu->addArg(sizeof(uint32_t),&startElem);
  gpu->addArg(sizeof(uint32_t),&nbElemToProcess);
  gpu->addArg(sizeof(uint32_t),&nbElement);
  gpu->addArg(sizeof(uint64_t),&nbParticles);
  gpu->addArg(sizeof(void *),&gpuRin);
  gpu->addArg(sizeof(void *),&gpuRout);
  gpu->addArg(sizeof(void *),&gpuLost);
  gpu->addArg(sizeof(uint64_t),&turn);
  gpu->addArg(sizeof(void *),&gpuRefs);
  gpu->addArg(sizeof(uint32_t),&nbRef);
  gpu->addArg(sizeof(void *),&gpuLostAtElem);
  gpu->addArg(sizeof(void *),&gpuLostAtCoord);

  // Turn loop
  for(turn=0;turn<nbTurn;turn++) {
    startElem = 0;
    nbElemToProcess = nbElement;
    gpu->run(GPU_BLOCK_SIZE, nbParticles + dummyParticles);
  }

  // Get back data
  gpu->deviceToHost(lost,gpuLost,lostSize);
  if( routSize ) gpu->deviceToHost(rout,gpuRout,routSize);
  if( lostAtElem ) gpu->deviceToHost(lostAtElem,gpuLostAtElem, nbParticles * sizeof(uint32_t));
  if( lostAtCoord ) gpu->deviceToHost(lostAtCoord,gpuLostAtCoord, nbParticles * 6 * sizeof(AT_FLOAT));

  // format data to AT format
  for(int i=0;i<nbParticles;i++) {
    if( !lost[i] ) {
      // Alive particle
      if( lostAtCoord )
        memset(lostAtCoord+6*i,0,6 * sizeof(AT_FLOAT));
      if( lostAtElem )
        lostAtElem[i] = 0;
      if( lostAtTurn )
        lostAtTurn[i] = nbTurn;
    } else {
      // Dead particle
      if( lostAtTurn )
        lostAtTurn[i] = lost[i] - 1;
    }
  }

  // Free
  gpu->freeDevice(gpuRin);
  if( gpuRout ) gpu->freeDevice(gpuRout);
  gpu->freeDevice(gpuRefs);
  gpu->freeDevice(gpuLost);
  gpu->freeDevice(gpuRingParams);
  if( gpuLostAtElem ) gpu->freeDevice(gpuLostAtElem);
  if( gpuLostAtCoord ) gpu->freeDevice(gpuLostAtCoord);
  delete[] expandedRefPts;
  delete[] lost;

#ifdef _PROFILE
  double t1 = AbstractGPU::get_ticks();
  cout << "GPU tracking: " << (t1-t0)*1000.0 << "ms" << endl;
#endif

}
